<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="郭宇祥的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        C++Primer第四章笔记 - PiKaChe&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 总得留下些什么吧 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>皮卡车</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#第四章表达式"><span class="toc-text">第四章表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#重载运算符（override）"><span class="toc-text">重载运算符（override）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#左值和右值"><span class="toc-text">左值和右值</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级与结合律"><span class="toc-text">优先级与结合律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#求值顺序"><span class="toc-text">求值顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#求值顺序、优先级、结合律"><span class="toc-text">求值顺序、优先级、结合律</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#算数运算符"><span class="toc-text">算数运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逻辑和关系运算符"><span class="toc-text">逻辑和关系运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#关系运算符"><span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相等性测试与字面布尔值"><span class="toc-text">相等性测试与字面布尔值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#赋值运算符"><span class="toc-text">赋值运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值运算满足右结合律"><span class="toc-text">赋值运算满足右结合律</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值运算优先级较低"><span class="toc-text">赋值运算优先级较低</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递增和递减运算符"><span class="toc-text">递增和递减运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#在一条语句中混用解引用和递增运算符"><span class="toc-text">在一条语句中混用解引用和递增运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#成员访问运算符"><span class="toc-text">成员访问运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件运算符"><span class="toc-text">条件运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套条件运算符"><span class="toc-text">嵌套条件运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在输出表达式中使用条件运算符"><span class="toc-text">在输出表达式中使用条件运算符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算符"><span class="toc-text">位运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#举例"><span class="toc-text">举例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#位与"><span class="toc-text">位与</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#位非"><span class="toc-text">位非</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#左移"><span class="toc-text">左移</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移位运算符"><span class="toc-text">移位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#移位运算符（又叫IO运算符）满足左结合律"><span class="toc-text">移位运算符（又叫IO运算符）满足左结合律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sizeof运算符"><span class="toc-text">sizeof运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过sizeof确定数组中的元素个数"><span class="toc-text">通过sizeof确定数组中的元素个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#例子"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#逗号运算符"><span class="toc-text">逗号运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解释语句的含义"><span class="toc-text">解释语句的含义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换"><span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#算数转化"><span class="toc-text">算数转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算数转换"><span class="toc-text">算数转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#整型提升"><span class="toc-text">整型提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#无符号类型的运算对象"><span class="toc-text">无符号类型的运算对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#例子-1"><span class="toc-text">例子</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#其他隐式类型转化"><span class="toc-text">其他隐式类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#数组转化成指针"><span class="toc-text">数组转化成指针</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#指针的转换"><span class="toc-text">指针的转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转化成布尔类型"><span class="toc-text">转化成布尔类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#转换成常量"><span class="toc-text">转换成常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#类类型定义的转换"><span class="toc-text">类类型定义的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#显示转换"><span class="toc-text">显示转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#命名的强制类型转化"><span class="toc-text">命名的强制类型转化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#static-cast"><span class="toc-text">static_cast</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#const-cast（去掉const性质）"><span class="toc-text">const_cast（去掉const性质）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reinterpreter-cast"><span class="toc-text">reinterpreter_cast</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 总得留下些什么吧 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        C++Primer第四章笔记
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-06-30 22:41:59</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#C++" title="C++">C++</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="第四章表达式"><a href="#第四章表达式" class="headerlink" title="第四章表达式"></a>第四章表达式</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>一元运算符：作用于一个运算对象，如取地址符（&amp;）和解引用符（*）</li>
<li>二元运算符：作用于两个运算对象，如相等（==）和乘法（*）</li>
<li>三元运算符</li>
</ul>
<h4 id="重载运算符（override）"><a href="#重载运算符（override）" class="headerlink" title="重载运算符（override）"></a>重载运算符（override）</h4><p>定义了运算符作用于内置类型和复合类型的运算时所执行的操作。<strong>自定义运算符的过程事实上是为已存在的运算符赋予了另外一层含义</strong>。IO库的&gt;&gt;和&lt;&lt;运算符以及string对象，vector对象和迭代器使用的运算符都是重载运算符。</p>
<h4 id="左值和右值"><a href="#左值和右值" class="headerlink" title="左值和右值"></a>左值和右值</h4><p>当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</p>
<h3 id="优先级与结合律"><a href="#优先级与结合律" class="headerlink" title="优先级与结合律"></a>优先级与结合律</h3><p>复合表达式是指含有两个或多个运算符的表达式。<br>一个式子，如果没有括号，那么计算顺序和正常计算顺序一致，乘除优先于加减。加上括号就括号优先。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> last = *&#123;ia + <span class="number">4</span>&#125;; <span class="comment">//ia是指向数组的首元素的指针，ia+4是指向指向第4个元素的指针，再解引用得到ia[4]得到8</span></span><br><span class="line">last = *ia + <span class="number">4</span>;	<span class="comment">//先解引用得到首元素的值为0，再加4得到的值为4</span></span><br></pre></td></tr></table></figure>
<h3 id="求值顺序"><a href="#求值顺序" class="headerlink" title="求值顺序"></a>求值顺序</h3><p>对于那些没有指定执行顺序的运算来说，如果表达式指向并修改了同一个对象，将会引发错误并产生为定义的行为。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt; i&lt;&lt; <span class="string">" "</span>&lt;&lt;++i&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>编译器可能先求++i的值再求i的值，此时输出结果为1 1；也可控先求i的值再求++i的值，输出结果是0 1。<br>有4种运算符明确规定了运算对象的求职顺序。</p>
<ul>
<li>&amp;&amp; 逻辑与运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。</li>
<li>|| 逻辑或运算符</li>
<li>（？：）条件运算符</li>
<li>， 逗号运算符</li>
</ul>
<h4 id="求值顺序、优先级、结合律"><a href="#求值顺序、优先级、结合律" class="headerlink" title="求值顺序、优先级、结合律"></a>求值顺序、优先级、结合律</h4><ul>
<li>拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求</li>
<li>如果改变了某个运算对象的值，在表达式的其他地方不要在使用这个运算对象。（*++iter除外）</li>
</ul>
<hr>
<h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>一元正号运算符（+ expr）、加法运算符和减法运算符都能作用与指针。<br>一元正号运算符作用与一个指针或者算数值时，返回运算对象值的一个（提升后的）副本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> k = -i; <span class="comment">//k是-1024</span></span><br><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = -b; <span class="comment">//b2是true</span></span><br></pre></td></tr></table></figure>
<p>布尔变量b的值为真，参与运算时将被提升整数值1，对它求负后的结果是-1.将-1再转换回布尔值并将其作为b2的初始值，显然这个初始值不等于0，转换成布尔值后为1。所以b2的值是真！</p>
<p>整数相处的接果还是整数，也就是说，如果商含有小数部分，直接弃除</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ivall = <span class="number">21</span>/<span class="number">6</span> <span class="comment">//ivall是3，结果进行删节，余数被抛弃掉了</span></span><br><span class="line"><span class="keyword">int</span> ivall = <span class="number">21</span>/<span class="number">7</span> <span class="comment">//ival是3，没有余数，结果是整数值</span></span><br></pre></td></tr></table></figure>

<ul>
<li>-m/n和m/（-n）都等于-（m/n）</li>
<li>m%(-n)等于m%n      (-m)%n等于-(m%n)</li>
</ul>
<p>-21 % -8  结果是 -5<br>21 % -5 结果是 1</p>
<hr>
<h2 id="逻辑和关系运算符"><a href="#逻辑和关系运算符" class="headerlink" title="逻辑和关系运算符"></a>逻辑和关系运算符</h2><p>关系运算符作用于算数类型或者指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示为真。</p>
<p>短路求值：</p>
<ul>
<li>对于逻辑与（&amp;&amp;）运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index != s.<span class="built_in">size</span>() &amp;&amp; !<span class="built_in">isspace</span>(s[index])</span><br></pre></td></tr></table></figure>
首先会检查index是否达到了string对象的末尾，以此确保只有当index在合理范围内时才会计算右侧运算对象的值。</li>
<li>对于逻辑或（||）运算符来说，当且仅当左侧的运算对象为假时才对右侧运算对象求值。<br>假定有一个储存着若干个string对象的vector对象，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。使用基于范围for循环处理string对象中的每个元素。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">text</span> = &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"Nihao"</span>, <span class="string">"dawdaw."</span>,<span class="string">"Loamo"</span>,<span class="string">"zz"</span>,<span class="string">"\0"</span>,<span class="string">"houge"</span>,<span class="string">"ll"</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;s: <span class="built_in">text</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()||s[s.<span class="built_in">size</span>()<span class="number">-1</span>]==<span class="string">'.'</span>)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
只有当非string对象非空时才需要求第二个运算对象的值，也就是检查string对象是否以句号结尾。s被声明了对常量的引用。因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝。又因为不需要string对象进行写操作，所以s被声明成对常量的引用。</li>
</ul>
<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p><code>if(i&lt;j&lt;k)</code>不正确，因为会先计算i&lt;k的结果，结果是true或者是false，然后再把true和false与k做比较，会产生问题。<code>if (i&lt;j &amp;&amp; j&lt;k)</code>当i小于j并且j小于k时条件为真</p>
<h3 id="相等性测试与字面布尔值"><a href="#相等性测试与字面布尔值" class="headerlink" title="相等性测试与字面布尔值"></a>相等性测试与字面布尔值</h3><p>如果想测试一个算数对象或指针对象的真值，最直接的方法就是将其作为if语句的条件：</p>
<ul>
<li>对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>（val）&#123;&#125;	<span class="comment">//如果val是任意的非0值 1,100,-2只要是非0都可以，条件为真</span></span><br><span class="line"><span class="keyword">if</span>(!val)&#123;&#125;	<span class="comment">//如果val是0，条件为真</span></span><br><span class="line"><span class="keyword">if</span>（val == <span class="literal">true</span>）&#123;&#125; <span class="comment">//只有当val等于1时条件才为真</span></span><br></pre></td></tr></table></figure>
<p>当布尔值转化成其他算数类型时，false转化成0而true转化成1。<br><strong>进行比较运算时除非比较的对象是布尔类型，否则不要用布尔字面值true和false作为运算对象</strong></p>
<ul>
<li>指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">if</span> (cp &amp;&amp; *cp)</span><br></pre></td></tr></table></figure>
首先if判断cp指针是否为空指针或者无效指针。<br>如果cp是空指针或无效指针之间返回false。<br>如果cp不是空指针和无效指针，检查*cp是否为空字符，如果是空字符则返回false，如果不是则返回true。<br>这里cp指向const的“Hello world”string对象，不为空且有效，*cp是cp指针的解引用，cp指向string的第一个字符的首地址，不是空字符所以返回true。</li>
</ul>
<h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><ul>
<li>赋值运算符的左侧运算对象必须是一个可以修改的左值。</li>
<li>如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧的元素运算对象的类型。</li>
<li>无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧的运算对象。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>; <span class="comment">//初始化而非赋值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i; <span class="comment">//初始化而非赋值</span></span><br><span class="line">k = <span class="number">3.1415926</span>； <span class="comment">//结果：类型是int，值是3</span></span><br></pre></td></tr></table></figure>
<h3 id="赋值运算满足右结合律"><a href="#赋值运算满足右结合律" class="headerlink" title="赋值运算满足右结合律"></a>赋值运算满足右结合律</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, jval;</span><br><span class="line">ival = javl = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> s1, s2;</span><br><span class="line">s1 = s2 = <span class="string">"OK"</span>;</span><br><span class="line"><span class="keyword">int</span> ival, *pval;</span><br><span class="line">ival = pval = <span class="number">0</span>; <span class="comment">//错误：pval的类型是指向整型的指针，ival的类型是整型，指针类型无法转换成为整型</span></span><br></pre></td></tr></table></figure>
对于多重赋值语句中的每一个对象，它的类型或者右边对象类型相同、或者可由右边类型转换得到。<h3 id="赋值运算优先级较低"><a href="#赋值运算优先级较低" class="headerlink" title="赋值运算优先级较低"></a>赋值运算优先级较低</h3>因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的意愿。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">while</span>((i = get_value())!=<span class="number">42</span>)&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
不断循环读取数据直到遇到42为止。<br>其处理过程是首先将get_value函数的返回值赋给i，然后比较i和42是否相等。</li>
</ul>
<hr>
<h2 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h2><ul>
<li>前置版：<code>j = ++i</code>运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果 </li>
<li>后置版：<code>j = i++</code>也会将运算对象加1（或减1），但是求值结果是运算对象改变之前的那个值的副本<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = ++i; <span class="comment">// j = 1, i = 1: 前置版本得到递增之前的值</span></span><br><span class="line">---</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, j;</span><br><span class="line">j = i++; <span class="comment">//j = 0， i=1: 后置版本得到递增之前的值</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>除非必须，否则不用递增递减运算符的后置版本</strong><br>因为后置版本会储存赋值之前的值，占用空间，造成不必要的浪费</p>
<h3 id="在一条语句中混用解引用和递增运算符"><a href="#在一条语句中混用解引用和递增运算符" class="headerlink" title="在一条语句中混用解引用和递增运算符"></a>在一条语句中混用解引用和递增运算符</h3><p>如果我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。<br>可以使用后置的递增运算符来控制循环输出的一个vector对象内容直至遇到（但不包括）第一个负值为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(pbeg != v.<span class="built_in">end</span>() &amp;&amp; *beg&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt; *pbeg++&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后置递增运算符的优先级高于解引用运算符</strong>，因此*pbeg++等价于*(pbeg++)。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果（还没有加1的状态），此时解引用运算符的运算对象是pbeg未增加之前的值。最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。</p>
<h2 id="成员访问运算符"><a href="#成员访问运算符" class="headerlink" title="成员访问运算符"></a>成员访问运算符</h2><ul>
<li>点运算符(*ptr).mem</li>
<li>箭头运算符ptr-&gt;mem<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"a string"</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line">n = (*p).<span class="built_in">size</span>(); <span class="comment">//运行p所指对象的size成员</span></span><br><span class="line">n = p-&gt;<span class="built_in">size</span>();	<span class="comment">//等价于(*p).size()</span></span><br></pre></td></tr></table></figure>
箭头运算符作用于一个指针类型的运算对象，结果是一个左值。<br>点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果所属的对象是右值，那么结果是右值。</li>
</ul>
<h2 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h2><p>条件运算符（？：）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：<br>cond？expr1:expr2；<br>先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> finalgrade = (grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span>:<span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="嵌套条件运算符"><a href="#嵌套条件运算符" class="headerlink" title="嵌套条件运算符"></a>嵌套条件运算符</h3><p>允许在条件运算符的内部嵌套另一个条件运算。也就是说，条件表达式可以作为另外一个条件运算符的cond或expr。使用一对嵌套的条件运算符可以将成绩分成三档：优秀（high pass）、合格（pass）和不合格（fail）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>)?<span class="string">"high pass"</span>:(gerade&lt;<span class="number">60</span>)?<span class="string">"fail"</span>:<span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="在输出表达式中使用条件运算符"><a href="#在输出表达式中使用条件运算符" class="headerlink" title="在输出表达式中使用条件运算符"></a>在输出表达式中使用条件运算符</h3><p>条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式，通常需要在它的两端加上括号。例如，有时需要根据条件值输出两个对象中的一个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;((grade&lt;<span class="number">60</span>)?<span class="string">"fail"</span>:<span class="string">"pass"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能，一种名为bitset的标准库类型也可以表示任意大小的二进制位集合，所以位运算同样能用于bitset类型。使用位运算符的好处是运算速度非常快。<br>| 运算符 | 功能   | 用法           | 解释                                   |<br>| —— | —— | ————– | ————————————– |<br>| ~      | 位求反 | ~ expr         | 操作数为1，结果为0；操作数为0，结果为1 |<br>| &lt;&lt;     | 左移   | expr1 &lt;&lt; expr2 | 把左边的数转化成二进制向左移动右边位   |<br>| &gt;&gt;     | 右移   | expr1 &gt;&gt; expr2 | 把左边边的数转化成二进制向右移动右边位 |<br>| &amp;      | 位与   | expr &amp; expr    | 两个操作数同时为1结果为1               |<br>| ^      | 位异或 | expr ^ expr    | 两个操作数相同，结果为0；不相同结果为1 |<br>| |     | 位或   | expr | expr   | 两个操作数之要有一个为1，结果就为1     |</p>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h4 id="位与"><a href="#位与" class="headerlink" title="位与"></a>位与</h4><p>十进制        4        &amp;         5<br>二进制        100    &amp;        101<br>每个位置上与关系：1和1是1，0和0是0，0和1是1，结果100 转化成十进制还是4</p>
<h4 id="位非"><a href="#位非" class="headerlink" title="位非"></a>位非</h4><p>~2<br>二进制： 10<br>取反：      01—–&gt; 十进制： 1； <strong>错误</strong><br>因为假设是char是占8位<br>二进制： 00000010<br>取反：     11111101 （第一位是1—-&gt;负数）<br>负数二进制转十进制：<br>将负数二进制取反，然后+1，结果为负<br>11111101 —-&gt; 00000010 +1 = 00000011 转十进制 3 再加负号 -3</p>
<h4 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h4><p>&lt;&lt; 和 cout&lt;&lt;样子相同 但是含义完全不同，cout&lt;&lt;是重载运算符<br>2 &lt;&lt; 3<br>先转化为二进制 10 —-&gt; 左移三位 10 000 —-&gt; 转化为10进制 2^4 =16 </p>
<p><strong>关于符号位如何处理没有明确规定，所以强烈建议仅将位运算符用于处理无符号类型。</strong></p>
<h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>&gt;&gt;和&lt;&lt;运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生为定义的行为。二进制位或者向左移（&lt;&lt;）或者向右移（&gt;&gt;），移出边界之外就被舍弃掉了。</p>
<h3 id="移位运算符（又叫IO运算符）满足左结合律"><a href="#移位运算符（又叫IO运算符）满足左结合律" class="headerlink" title="移位运算符（又叫IO运算符）满足左结合律"></a>移位运算符（又叫IO运算符）满足左结合律</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"hi"</span>&lt;&lt;<span class="string">"there"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">((<span class="built_in">cout</span>&lt;&lt;<span class="string">"hi"</span>)&lt;&lt;<span class="string">"there"</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//等效于</span></span><br></pre></td></tr></table></figure>
<p>移位运算符的优先级不高不低，介于中间：比算数运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">42</span> + <span class="number">10</span> <span class="comment">//正确：+的优先级更高，因此输出求和结果</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="number">10</span> &lt; <span class="number">42</span>) <span class="comment">//正确：括号使运算按照我们的期望组合在一起，输出1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">10</span> &lt; <span class="number">42</span> <span class="comment">//错误：试图比较cout和42</span></span><br></pre></td></tr></table></figure>


<h2 id="sizeof运算符"><a href="#sizeof运算符" class="headerlink" title="sizeof运算符"></a>sizeof运算符</h2><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数 (1个字节占8比特)。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：</p>
<ul>
<li>sizeof (type)</li>
<li>sizeof expr<br>在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="keyword">sizeof</span>(<span class="keyword">double</span>); <span class="comment">//结果是8 占8个字节</span></span><br><span class="line"><span class="keyword">sizeof</span>(<span class="string">"abcd"</span>); <span class="comment">//结果是5 占5个字节，因为string结尾默认有\0站一个字节</span></span><br><span class="line"><span class="keyword">sizeof</span>(Sales_data); <span class="comment">//存储Sale_data类型的对象所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data; <span class="comment">//data的类型的大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> p; <span class="comment">//指针所占的空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> *p  <span class="comment">//p所指类型的空间大小，即sizeof(Sales_data)</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue; <span class="comment">//Sales_data的revenue成员对应的类型的大小</span></span><br><span class="line"><span class="keyword">sizeof</span> Sale_data::revenue; <span class="comment">//另一种获取revenue大小的方式</span></span><br></pre></td></tr></table></figure>
C++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无需我们提供一个具体的对象，因为想要知道类成员的大小无需真的获取该成员。<br>sizeof运算符的结果部分地依赖于其作用的类型：</li>
<li>对char或者类型位char的表达式执行sizeof运算，结果为1。</li>
<li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li>
<li>对指针执行sizeof运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效</li>
<li>对数组执行sizeof运算得到整个数组所占空间大小，等价于对数组中的所有元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理</li>
<li>对string对象或vector对象（sizeof(string)）执行sizeof运算值返回该类型固定部分的大小，不会返回对像中的元素占用了多少空间。如果想要知道元素占用了多少可以直接(sizeof(“abcd”))</li>
</ul>
<h3 id="通过sizeof确定数组中的元素个数"><a href="#通过sizeof确定数组中的元素个数" class="headerlink" title="通过sizeof确定数组中的元素个数"></a>通过sizeof确定数组中的元素个数</h3><p>因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素的个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia)/<span class="keyword">sizeof</span>(*ia);</span><br><span class="line"><span class="keyword">int</span> arr2[sz];</span><br></pre></td></tr></table></figure>
<p>因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[<span class="number">10</span>]; </span><br><span class="line"> <span class="keyword">int</span> *p = x;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(x)/<span class="keyword">sizeof</span>(*x) &lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 40/4 = 10</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt; <span class="keyword">sizeof</span>(p)/<span class="keyword">sizeof</span>(*p) &lt;&lt;<span class="built_in">endl</span>;	<span class="comment">// 8/4 = 2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sizeof(x), x是一个有10个元素的数组，所以它的sizeof是所有的10个int元素之和。10*4 = 40</li>
<li>sizeof(*x) 返回x所指类型的空间大小，即sizeof(int)</li>
<li>sizeof(p) 返回指针所占的空间大小</li>
<li>size(*p) 返回p所指对象类型所占空间大小，即sizeof(int)</li>
</ul>
<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了对象求值的顺序。<br>对于逗号运算符来说，首先对左侧的表达式求值，然后将求值的结果丢弃掉，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。<br>逗号运算符经常被用在for循环当中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type cnt = ivec.<span class="built_in">size</span>(); <span class="comment">// 将把从size到1的值赋给ivec的元素</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type ix = <span class="number">0</span>; iX != ivec.<span class="built_in">size</span>(); ++ix, --cnt)&#123;</span><br><span class="line">	ivec[ix] = cnt;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这个循环在for语句的表达式中递增ix、递减cnt，每次迭代循环ix和cnt相应改变。只要ix满足条件，我们就把当前元素设成cnt的当前值。在for循环中前置和后置效果一样，因为for循环中的是；这是因为递增递减运算符与真正使用这两个变量的语句位于不同的表达式中，所以不会有什么影响。</p>
<h3 id="解释语句的含义"><a href="#解释语句的含义" class="headerlink" title="解释语句的含义"></a>解释语句的含义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">someValue? ++x, ++y:--x,--y</span><br></pre></td></tr></table></figure>
<p>因为条件运算符的优先级大于逗号运算符，所以someValue? ++x, ++y:–x,–y 实际上是<br>(someValue ? ++x, ++y : –x ), –y;</p>
<ul>
<li>如果someValue为true：先执行++x，++y最后再执行–y</li>
<li>如果someValue为false：先执行–x，最后执行–y</li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>如果两种类型可以相互转换，那么它们就是关联的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">3.541</span> + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>加法的两个运算对象类型不同：3.541是double，3的类型是int。c++语言不会将两个不同类型的值相加，而是先根据类型转化规则设法将运算对象的类型统一后再求值。上述的类型转换是自动执行的，无需程序员的介入，因此它们被称为<strong>隐式转换</strong>。</p>
<h3 id="算数转化"><a href="#算数转化" class="headerlink" title="算数转化"></a>算数转化</h3><h4 id="算数转换"><a href="#算数转换" class="headerlink" title="算数转换"></a>算数转换</h4><p>算数转换的规则定义了一套类型转化的层次，其中运算符的元素安对象将转换成最宽的类型。例如，如果一个运算对象的类型是long double（最宽的类型，范围最大的类型），那么不论另外一个运算对象的类型是什么都会转化成long double。还有一种更普遍的情况，当表达式中既有浮点类型也有整数类型时，整数值降转化成相应的浮点类型。</p>
<h5 id="整型提升"><a href="#整型提升" class="headerlink" title="整型提升"></a>整型提升</h5><p>整型提升负责把小整数类型转化成较大的整数类型。对于bool、char、signed char、unsigned char、short和 unsigned short等类型来说，只要它们所有可能的值都存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。</p>
<h5 id="无符号类型的运算对象"><a href="#无符号类型的运算对象" class="headerlink" title="无符号类型的运算对象"></a>无符号类型的运算对象</h5><p>如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中的各个整数类型的相对大小了。</p>
<ul>
<li>和往常一样，首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。</li>
<li>如两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。</li>
<li>如果一个运算对象是无符号类型，另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么将带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转化成unsigned int类型。需要注意的是，如果int类型的值恰好为负，则会有副作用。（<strong>带符号—-&gt;无符号</strong>）</li>
<li>带符号类型大于无符号类型，此时运算结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号的运算对象转换成带符号类型。如果不能，那么带符号类型转换成无符号类型。<h5 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">short sval;</span><br><span class="line"><span class="keyword">int</span> ival;</span><br><span class="line"><span class="keyword">long</span> lval;</span><br><span class="line"><span class="keyword">float</span> fval;</span><br><span class="line"><span class="keyword">char</span> cval;</span><br><span class="line"><span class="keyword">unsigned</span> short usval;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> uival;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> ulval;</span><br><span class="line"><span class="keyword">double</span> dval;</span><br><span class="line"></span><br><span class="line"><span class="number">3.1415926L</span> + <span class="string">'a'</span>; <span class="comment">//'a'提升成int，然后该int值转化成long double</span></span><br><span class="line">dval + ival; <span class="comment">//ival转化成double</span></span><br><span class="line">dval + fval; <span class="comment">//fval转化成double</span></span><br><span class="line">ival = dval; <span class="comment">//dval转化成（切除小数部分后）int</span></span><br><span class="line">flag = dval; <span class="comment">//如果dval是0，则flag是false，否则flag是true</span></span><br><span class="line">cval + fval; <span class="comment">//cval(char)提升成int，然后该int值转化成float</span></span><br><span class="line">sval + cval; <span class="comment">//sval（short）和cval（char）都转化float</span></span><br><span class="line">cval + lval； <span class="comment">//cval转化成long</span></span><br><span class="line">ival + ulval; <span class="comment">//ival转化成unsigned long</span></span><br><span class="line">usval + ival; <span class="comment">//根据unsigned short和int所占空间大小进行提升</span></span><br><span class="line">uival + lval; <span class="comment">//根据unsigned int和long所占空间的大小进行转换</span></span><br></pre></td></tr></table></figure>
<h4 id="其他隐式类型转化"><a href="#其他隐式类型转化" class="headerlink" title="其他隐式类型转化"></a>其他隐式类型转化</h4><h5 id="数组转化成指针"><a href="#数组转化成指针" class="headerlink" title="数组转化成指针"></a>数组转化成指针</h5>在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>]; <span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span>* ip = ia; <span class="comment">//ia转化成指向数组首元素的指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>当数组被用作decltype关键字的参数，或者作为取地址（&amp;）、sizeof以及typeid等运算对象时，上述转换也不会发生。</strong></p>
<h5 id="指针的转换"><a href="#指针的转换" class="headerlink" title="指针的转换"></a>指针的转换</h5><ul>
<li>常量数值0或者字面值nullptr能转换成任意指针类型</li>
<li>指向任意非常量的指针能转化成void*</li>
<li>指向任意对象的指针能转化成const void*<h5 id="转化成布尔类型"><a href="#转化成布尔类型" class="headerlink" title="转化成布尔类型"></a>转化成布尔类型</h5>存在一种从<strong>算数类型</strong>或<strong>指针类型</strong>向布尔类型自动转化的机制。如果指针或算数类型的值为0，转换结果是false，否则转换的结果是true。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *cp = get_string();</span><br><span class="line"><span class="keyword">if</span> (cp) <span class="comment">//如果指针cp不是0，条件为真</span></span><br><span class="line"><span class="keyword">while</span> (*cp) <span class="comment">//如果*cp不是空字符，条件为真</span></span><br></pre></td></tr></table></figure>
<h5 id="转换成常量"><a href="#转换成常量" class="headerlink" title="转换成常量"></a>转换成常量</h5>允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i;  <span class="comment">//非常量转换成const int的引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i; <span class="comment">//非常量的地址转换成const的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = j, *q = p; <span class="comment">//错误： 不允许const转化成非常量： j本来是const引用，需要先转换成非常量才能赋值给非常量int</span></span><br></pre></td></tr></table></figure>
<h5 id="类类型定义的转换"><a href="#类类型定义的转换" class="headerlink" title="类类型定义的转换"></a>类类型定义的转换</h5>类类型能定义由编译器自动执行转换，不过编译器每次只能执行一种类类型的转换。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;s) <span class="comment">//while的条件部分把cin转换成布尔值</span></span><br></pre></td></tr></table></figure>
条件部分本来需要一个布尔类型的值，但是这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值转换的规则，根据这一规则，cin自动转换成布尔值。<h4 id="显示转换"><a href="#显示转换" class="headerlink" title="显示转换"></a>显示转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">double</span> slope = i/j;</span><br></pre></td></tr></table></figure>
如果想在上面的代码中执行浮点数除法，就要使用某种方法将i和/或j显示的转化成double，这种方法称作强制类型转换（cast）。<h5 id="命名的强制类型转化"><a href="#命名的强制类型转化" class="headerlink" title="命名的强制类型转化"></a>命名的强制类型转化</h5>cast-name<type>(expression)<br>其中，type是转换的目标类型而expression是需要转换的值。如果type是引用类型，则结果是左值。cast-name是</li>
<li>static_cast</li>
<li>dynamic_cast</li>
<li>const_cast</li>
<li>reinterpret_cast(重新解释)</li>
</ul>
<h6 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h6><p>任何具有明确定义的类型转换，<strong>只要不包含底层const</strong>，都可以使用static_cast。例如，通过一个运算对象强制转换成double类型就能使表达式执行浮点数除法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> slope = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(j) / i;</span><br></pre></td></tr></table></figure>
<p>static_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d; <span class="comment">//正确：任何非常量对象的地址都能存入void*</span></span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(p); <span class="comment">// 正确：将void*转换回初始的指针类型</span></span><br></pre></td></tr></table></figure>
<p>当我们把指针存放在void<em>中，并且使用了static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，*</em>因此我们必须确保转换后所得的类型就是指针所指的类型**。类型一旦不符，将产生未定义的后果。</p>
<hr>
<p><strong>底层const，常量指针（const pointer）</strong>：针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。</p>
<hr>
<h6 id="const-cast（去掉const性质）"><a href="#const-cast（去掉const性质）" class="headerlink" title="const_cast（去掉const性质）"></a>const_cast（去掉const性质）</h6><p>const_cast只能改变运算对象的底层const：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>&gt;(pc);</span><br></pre></td></tr></table></figure>
<p>对于将常量对象转换成非常量对象的行为，我们一般称其为 “去掉const性质”。<br>只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能使用const_cast改变表达式类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"><span class="keyword">char</span> *q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp) <span class="comment">//错误：static_cast不能去掉const性质</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&gt;(cp); <span class="comment">//正确：字符串字面值转换成string类型</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(cp); <span class="comment">//错误：const_cast只能改变常量属性</span></span><br></pre></td></tr></table></figure>
<h6 id="reinterpreter-cast"><a href="#reinterpreter-cast" class="headerlink" title="reinterpreter_cast"></a>reinterpreter_cast</h6><p>reinterpreter_cast通常为运算对象的位模式提供较低层次上的重新解释。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = reinterpreter_cast&lt;<span class="keyword">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>
<p>pc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，要尽量避免使用reinterpreter_cast。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://pikache.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>

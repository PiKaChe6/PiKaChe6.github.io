<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="郭宇祥的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        C++Primer第三章笔记 - PiKaChe&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> self-discipline </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>皮卡车</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>HOME</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>TAGS</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>ARCHIVES</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>ABOUT</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>SEARCH</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#第三章（字符串，向量和数组）"><span class="toc-text">第三章（字符串，向量和数组）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名空间using的声明"><span class="toc-text">命名空间using的声明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自定义namesapce"><span class="toc-text">自定义namesapce</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准库类型string"><span class="toc-text">标准库类型string</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义和初始化string对象"><span class="toc-text">定义和初始化string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string对象上的操作"><span class="toc-text">string对象上的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用getline读取一整行"><span class="toc-text">使用getline读取一整行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#空格和空字符串区别"><span class="toc-text">空格和空字符串区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#empty和size操作"><span class="toc-text">empty和size操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string-size-type类型"><span class="toc-text">string::size_type类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较string对象"><span class="toc-text">比较string对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字面值和string对象相加"><span class="toc-text">字面值和string对象相加</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#string和char-的区别"><span class="toc-text">string和char*的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#处理string对象中的字符"><span class="toc-text">处理string对象中的字符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#处理字符串某个字符的函数"><span class="toc-text">处理字符串某个字符的函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#范围for语句"><span class="toc-text">范围for语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用范围for语句改变字符串中的字符"><span class="toc-text">使用范围for语句改变字符串中的字符</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下标运算符（只处理一部分字符）"><span class="toc-text">下标运算符（只处理一部分字符）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标准库类型vector"><span class="toc-text">标准库类型vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义和初始化vector对象"><span class="toc-text">定义和初始化vector对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#向vector对象中添加元素"><span class="toc-text">向vector对象中添加元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#支持的操作"><span class="toc-text">支持的操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#使用迭代器"><span class="toc-text">使用迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器运算符"><span class="toc-text">迭代器运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器的类型"><span class="toc-text">迭代器的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#begin和end运算符"><span class="toc-text">begin和end运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代器的运算"><span class="toc-text">迭代器的运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么mid-beg-end-beg-2而非-mid-beg-end-2"><span class="toc-text">为什么mid &#x3D;beg + (end - beg)&#x2F;2而非 mid &#x3D; (beg + end)&#x2F;2</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义和初始化内置数组"><span class="toc-text">定义和初始化内置数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#显式初始化数组元素"><span class="toc-text">显式初始化数组元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符数组"><span class="toc-text">字符数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#理解复杂数组声明"><span class="toc-text">理解复杂数组声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#主函数内外的初始值区别"><span class="toc-text">主函数内外的初始值区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vector和数组的区别"><span class="toc-text">vector和数组的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问数组的元素"><span class="toc-text">访问数组的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针和数组"><span class="toc-text">指针和数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针也是迭代器-指针遍历数组"><span class="toc-text">指针也是迭代器(指针遍历数组)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针运算"><span class="toc-text">指针运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#解引用和指针运算的交互"><span class="toc-text">解引用和指针运算的交互</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下标和指针"><span class="toc-text">下标和指针</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#标准库类型string，vector"><span class="toc-text">标准库类型string，vector</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#string-size-type类型-1"><span class="toc-text">string::size_type类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#vector-size"><span class="toc-text">vector.size()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标准库类型string，vector下标"><span class="toc-text">标准库类型string，vector下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组下标"><span class="toc-text">数组下标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组维度"><span class="toc-text">数组维度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C风格字符串"><span class="toc-text">C风格字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#比较字符串"><span class="toc-text">比较字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多维数组"><span class="toc-text">多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#多维数组的初始化"><span class="toc-text">多维数组的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多维数组的下标引用"><span class="toc-text">多维数组的下标引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用for语句处理多维数组"><span class="toc-text">用for语句处理多维数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用两层嵌套for语句"><span class="toc-text">使用两层嵌套for语句</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用范围for循环"><span class="toc-text">使用范围for循环</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#指针和多维数组"><span class="toc-text">指针和多维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类型别名简化多维数组指针"><span class="toc-text">类型别名简化多维数组指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多维数组用for遍历输出区别比较"><span class="toc-text">多维数组用for遍历输出区别比较</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#使用范围for循环输出"><span class="toc-text">使用范围for循环输出</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用普通for循环-下标运算符"><span class="toc-text">使用普通for循环 + 下标运算符</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#使用普通for循环-指针"><span class="toc-text">使用普通for循环 + 指针</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">search</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> self-discipline </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        C++Primer第三章笔记
    </div>

    <div class="post-meta">
        <span class="attr">Post：<span>2020-06-18 12:25:17</span></span>
        
        <span class="attr">Tags：/
        
        <a class="tag" href="/tags/#C++" title="C++">C++</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">Visit：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h4 id="第三章（字符串，向量和数组）"><a href="#第三章（字符串，向量和数组）" class="headerlink" title="第三章（字符串，向量和数组）"></a>第三章（字符串，向量和数组）</h4><h3 id="命名空间using的声明"><a href="#命名空间using的声明" class="headerlink" title="命名空间using的声明"></a>命名空间using的声明</h3><p>作用域操作符（::）的含义是：编译器应从操作符左侧所示的作用域中寻找右侧那个名字。比如std::cin就是要使用std中的名字cin。<br><strong>每个名字都要有独立的using声明。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//之后使用cin，cout和endl就可以直接用了</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>头文件不应该包含using声明</strong><br>因为头文件会被引用到主文件中，对于某些程序来说由于不经意间包含了一次名字，反而可能产生始料未及的名字冲突。</p>
<p>其实也可以使用<code>using namespace std；</code>可以一次性包含整个std命名空间。但是不太推荐，因为可能我们自己也不清楚整个命名空间都有哪些关键字，冒然<code>using</code>进来，增加了命名冲突的可能性。</p>
<h4 id="自定义namesapce"><a href="#自定义namesapce" class="headerlink" title="自定义namesapce"></a>自定义namesapce</h4><p>namespace的主要功能是避免命名冲突，因为很多大型软件开发都是很多个程序员合作完成的，不同程序员可能会用相同的名字定义相同的函数，但是当最终把这些函数合并在一起之后编译运行的过程就会产生冲突，因为不知道该运行哪个函数。<br>比如两个函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yuxiang Guo"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">func1(); <span class="comment">//会产生冲突</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> programm1&#123;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello World"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> programm2&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func1</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"Yuxiang Guo"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">programm1::func1(); <span class="comment">//使用就不会产生冲突了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h3><p>string表示可变长的字符序列，使用string类型必须首先包含string头文件。<br>string is an array of character<br>#include<string><br>using std::string;</p>
<h4 id="定义和初始化string对象"><a href="#定义和初始化string对象" class="headerlink" title="定义和初始化string对象"></a>定义和初始化string对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1; <span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1；<span class="comment">//s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"hiya"</span>; <span class="comment">//s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>; <span class="comment">//s4的内容是cccccccccc</span></span><br></pre></td></tr></table></figure>
<h4 id="string对象上的操作"><a href="#string对象上的操作" class="headerlink" title="string对象上的操作"></a>string对象上的操作</h4><table>
<thead>
<tr>
<th>操作</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>os&lt;&lt;s</td>
<td>将s写到输出流os中，返回os</td>
</tr>
<tr>
<td>is&gt;&gt;s</td>
<td>从is中读取字符串赋给s，字符串以空白分隔，返回is</td>
</tr>
<tr>
<td>getline(is, s)</td>
<td>从is读取一行赋给s，返回is</td>
</tr>
<tr>
<td>s.empty()</td>
<td>s为空返回true，否则返回false</td>
</tr>
<tr>
<td>s.size()</td>
<td>返回s中字符的个数</td>
</tr>
<tr>
<td>s[n]</td>
<td>返回s中的第n个字符的引用，位置n从0计起</td>
</tr>
<tr>
<td>s1+s2</td>
<td>返回s1和s2连接后的结果</td>
</tr>
<tr>
<td>s1=s2</td>
<td>用s2的副本代替s1中原来的字符</td>
</tr>
<tr>
<td>s1==s2</td>
<td>如果s1和s2中所含的字符完全一样，则他们相等</td>
</tr>
<tr>
<td>s1!=s2</td>
<td>string对象的相等性判断对字母大小写敏感</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td>利用字符在字典中的顺序进行比较，且对大小写敏感</td>
</tr>
<tr>
<td>#### 读写string</td>
<td></td>
</tr>
<tr>
<td>string对象会自动忽略开头空白并从第一个真正字符开始读起，直到遇到下一处空白位置。</td>
<td></td>
</tr>
<tr>
<td>比如输入是<code>&quot;   Hello    World   &quot;</code>读入的就是<code>Hello</code>。</td>
<td></td>
</tr>
</tbody></table>
<h4 id="使用getline读取一整行"><a href="#使用getline读取一整行" class="headerlink" title="使用getline读取一整行"></a>使用getline读取一整行</h4><p>如果想要保留空格（空白符）读取，就要用getline()，getline只要一遇到换行符就结束读取操作并返回结果。<br><code>getline(cin, s)</code>读取输入的一整行直到换行符位置并把它赋值给s。触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象并不包含换行符。</p>
<h4 id="空格和空字符串区别"><a href="#空格和空字符串区别" class="headerlink" title="空格和空字符串区别"></a>空格和空字符串区别</h4><p>从字符串的长度:——&gt;空字符的长度为0,空格符的长度为1</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[] = <span class="string">"\0"</span>; <span class="comment">//空字符串</span></span><br><span class="line"><span class="keyword">char</span> b[] = <span class="string">" "</span>; <span class="comment">//空格</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(a) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//0</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(b) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<h4 id="empty和size操作"><a href="#empty和size操作" class="headerlink" title="empty和size操作"></a>empty和size操作</h4><p><strong>连续回车两下代表输入一个空字符！！！</strong><br>每次读入一整行，输出其中超过80个字符的行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">string</span> <span class="built_in">line</span>;</span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, <span class="built_in">line</span>))&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">line</span>.<span class="built_in">size</span>() &gt; <span class="number">80</span>)&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="built_in">line</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。</p>
<h4 id="string-size-type类型"><a href="#string-size-type类型" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h4><p>对于size函数来说，返回的是一个string::size_type的类型的值，这是一种新的类型。string::size_type函数返回的是一个无符号的整型数。<strong>如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigend可能带来的问题。</strong></p>
<h4 id="比较string对象"><a href="#比较string对象" class="headerlink" title="比较string对象"></a>比较string对象</h4><ul>
<li>如果两个string对象长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短string对象小于较长string对象</li>
<li>如果两个string对象在某些对应的位置上不一样，则string对象的比较结果其实是string对象中第一对想异字符比较结果<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> phrase = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">string</span> slang = <span class="string">"Hiya"</span>;</span><br></pre></td></tr></table></figure>
str &lt; pharse<br>slang &gt; str<br>slang &gt; pharse<h4 id="字面值和string对象相加"><a href="#字面值和string对象相加" class="headerlink" title="字面值和string对象相加"></a>字面值和string对象相加</h4>算术类型、引用和指针都属于字面值类型。某些类也是字面值类型，它们可能含有constexpr函数成员。自定义类Sales_item、IO库、string类型不属于字面值类型。<br>当把string对象和<strong>字符字面值</strong>及<strong>字符串字面值</strong>混在一条语句中使用时，必须确保每个加法运算符（+）的两侧至少有一个是string</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"Hello"</span> + <span class="string">", "</span> <span class="comment">//错误，“hello”类型是const char[5], ", "类型是const char[3]，加号左右两边至少要有一个string</span></span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"Hello"</span></span><br><span class="line"><span class="built_in">string</span> s1 = s2 + <span class="string">", "</span>	<span class="comment">//正确</span></span><br><span class="line"><span class="built_in">string</span> s3 = s2 + <span class="string">", "</span> + <span class="string">"world"</span> <span class="comment">//正确 等价于（s2 + ", "）+ "world"</span></span><br><span class="line"><span class="built_in">string</span> s4  = <span class="string">"Hello"</span> + <span class="string">", "</span> + s2 <span class="comment">//错误 等价于（"Hello" + ", "） + s2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>string对象可以和字面值相加</li>
<li>两个字面值不能相加</li>
<li>多个相加时注意加法的左结合律<h4 id="string和char-的区别"><a href="#string和char-的区别" class="headerlink" title="string和char*的区别"></a>string和char*的区别</h4>在C++中，char仍然是一个primitive type（原始类型），而string已经经过封装，成为了一个class（类）用到它时，我们需要 #include <string>，它是C++ Standard Library （C++标准库）的一部分。<br>C++中使用char*定义字符串，同样不能改变字符串内的字符的内容，但却可以把另外一个字符串付给它，相当于指针指向了另一个字符。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* pstr = <span class="string">"hello world"</span>;</span><br><span class="line">	pstr = <span class="string">"aa"</span>;</span><br><span class="line">	pstr[<span class="number">1</span>] = <span class="string">"a"</span>;	<span class="comment">//报错</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;pstr&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++中string的定义字符串，同样不能改变字符串内的字符，但却可以把另外一个字符串付给它</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> str1;</span><br><span class="line">	str1= <span class="string">"hello world"</span>;</span><br><span class="line">	str1=<span class="string">"aa"</span>;</span><br><span class="line">	str1[<span class="number">1</span>]=<span class="string">"a"</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;str1&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="处理string对象中的字符"><a href="#处理string对象中的字符" class="headerlink" title="处理string对象中的字符"></a>处理string对象中的字符</h4><h5 id="处理字符串某个字符的函数"><a href="#处理字符串某个字符的函数" class="headerlink" title="处理字符串某个字符的函数"></a>处理字符串某个字符的函数</h5><table>
<thead>
<tr>
<th>函数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>isalnum(c)</td>
<td>当c是字母或数字为真</td>
</tr>
<tr>
<td>isalpha(c)</td>
<td>当c是字母时为真</td>
</tr>
<tr>
<td>iscntrl(c)</td>
<td>当c是控制字符时为真</td>
</tr>
<tr>
<td>isdigit(c)</td>
<td>当c是数字时为真</td>
</tr>
<tr>
<td>isgraph(c)</td>
<td>当c不是空格但可打印时为真</td>
</tr>
<tr>
<td>islower(c)</td>
<td>当c是小写字母时为真</td>
</tr>
<tr>
<td>isprint(c)</td>
<td>当c是可打印字符时为真</td>
</tr>
<tr>
<td>ispunct(c)</td>
<td>当c是标点符号为真</td>
</tr>
<tr>
<td>isspace(c)</td>
<td>当c是空白（空格）时为真</td>
</tr>
<tr>
<td>isupper(c)</td>
<td>当c是大写字母时为真</td>
</tr>
<tr>
<td>isxdigit(c)</td>
<td>当c是十六进制数时为真</td>
</tr>
<tr>
<td>tolower(c)</td>
<td>如果c是大写字母，输出对应的小写字母：否则原样输出c</td>
</tr>
<tr>
<td>toupper(c)</td>
<td>如果c是小写字母，输出对应的大写字母：否则原因输出c</td>
</tr>
</tbody></table>
<p>前面提到string是可变长的字符序列<br>有三种方式可以访问其中的字符</p>
<ul>
<li>范围for语句</li>
<li>下标运算符</li>
<li>迭代器<h5 id="范围for语句"><a href="#范围for语句" class="headerlink" title="范围for语句"></a>范围for语句</h5>用范围for语句比用普通for循环语句更加代码更加简洁。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"some string"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c: str)&#123;	<span class="comment">//输出str中的每个字符，通过使用auto让编译器来决定变量c的类型，这里的c是char/</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用范围for语句改变字符串中的字符"><a href="#使用范围for语句改变字符串中的字符" class="headerlink" title="使用范围for语句改变字符串中的字符"></a>使用范围for语句改变字符串中的字符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello world"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span>&amp; i : str)&#123;	注意，这里i必须是引用，这样才能改变str中的值。</span><br><span class="line">	i = <span class="built_in">toupper</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;	<span class="comment">//输出的是“HELLO WORLD”</span></span><br></pre></td></tr></table></figure>
<h4 id="下标运算符（只处理一部分字符）"><a href="#下标运算符（只处理一部分字符）" class="headerlink" title="下标运算符（只处理一部分字符）"></a>下标运算符（只处理一部分字符）</h4>s[0]是第一个字符，s[s.size()-1]是最后一个字符</li>
</ul>
<hr>
<h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h3><p>标准库类型vector表示对象集合，其中所有<strong>对象的类型都相同。</strong>集合中的每个对象都有一个与之对应的索引，索引用于访问对象。vector是一个<strong>类模版</strong>（类模版不是类），由vector生成的类型必须包含vector中元素的类型，例如vector<int>。模版就是一个类，但是比如类中的某个attribute的类型可以作为变量让用户来自己选择。<br>要想使用vector必须包含适当的头文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
<p>vector的元素不能是引用，vector的元素也可以是一个vector：<br><code>vector&lt;vector&lt;int&gt;&gt;</code><br>学习vector的时候可以和string对比学习</p>
<ol>
<li>定义和初始化</li>
<li>支持的操作</li>
<li>处理vector对象中的字符</li>
</ol>
<ul>
<li>范围for语句</li>
<li>下标运算符</li>
<li>迭代器</li>
</ul>
<h4 id="定义和初始化vector对象"><a href="#定义和初始化vector对象" class="headerlink" title="定义和初始化vector对象"></a>定义和初始化vector对象</h4><table>
<thead>
<tr>
<th>代码</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>vector<T> v1</td>
<td>v1是一个空的vector，它的潜在类型是T类型，执行默认初始化</td>
</tr>
<tr>
<td>vector<T> v2(v1)</td>
<td>v2中包含了v1所有元素的副本</td>
</tr>
<tr>
<td>vector<T> v2 = v1</td>
<td>等价于v2(v1), v2中包含了v1所有元素的副本</td>
</tr>
<tr>
<td>vector<T> v3(n, val)</td>
<td>v3包含了n个重复的元素，每个元素的值都是val</td>
</tr>
<tr>
<td>vector<T> v4(n)</td>
<td>v4包含了n个重复地执行了初始化的对象</td>
</tr>
<tr>
<td>vector<T> v5{a, b, c}</td>
<td>v5包含了初值个元素，每个元素被赋予了相对应的初始值</td>
</tr>
<tr>
<td>vector<T> v5 = {a, b, c}</td>
<td>等价于v5{a, b, c}</td>
</tr>
<tr>
<td><code>vector&lt;string&gt; svector;</code>最常见的就是先定义一个空的vector，然后当运行时获取的元素再逐一添加，执行元素拷贝时，两个vector对象的类型必须相同。</td>
<td></td>
</tr>
<tr>
<td>##### 列表初始化和创建指定数量的元素的比较</td>
<td></td>
</tr>
<tr>
<td>+ 列表初始化，用花括号<code>vector&lt;string&gt; v1{&quot;a&quot;, &quot;an&quot;, &quot;the&quot;};</code></td>
<td></td>
</tr>
<tr>
<td>+ 创建指定的元素比较，用圆括号<code>vector&lt;int&gt; v2(10, -1);</code>10个int类型的元素，每个都被初始化为-1。<code>vector&lt;string&gt; v3(10, &quot;Hi&quot;);</code>10个string类型的元素，每个都被初始化为Hi。</td>
<td></td>
</tr>
</tbody></table>
<p>如果vector不给赋处置，则默认：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;	<span class="comment">//10个元素，每个都初始化为空string对象</span></span><br></pre></td></tr></table></figure>
<p>区分()和{}</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// v1有10个元素，每个都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;	<span class="comment">//v2有一个元素，该元素的值时10</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;	<span class="comment">//v3有10个元素，每个值都是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>, <span class="number">1</span>&#125;;	<span class="comment">//v4有2个元素，分别是10和1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125;;	<span class="comment">//v5有一个元素是“hi”</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v6</span><span class="params">(<span class="string">"hi"</span>)</span></span>;	<span class="comment">//错误，不能使用字符串字面值构建vector对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;	<span class="comment">//注意，类型是string，所以v7有10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;	<span class="comment">//v8有10个元素值为“hi”的元素</span></span><br></pre></td></tr></table></figure>

<h4 id="向vector对象中添加元素"><a href="#向vector对象中添加元素" class="headerlink" title="向vector对象中添加元素"></a>向vector对象中添加元素</h4><p>先定义一个空的vector对象，再在运行时向其中添加具体值。使用<code>push_back</code>。如果循环体内包含了有向vector对象添加元素的语句，则不能使用范围for循环。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; i &lt;<span class="number">100</span>; ++i)&#123;</span><br><span class="line">	v2.push_back(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="支持的操作"><a href="#支持的操作" class="headerlink" title="支持的操作"></a>支持的操作</h4><table>
<thead>
<tr>
<th>代码</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td>v.empty()</td>
<td align="left">如果v不含有任何元素，返回真；否则返回假</td>
</tr>
<tr>
<td>v.size()</td>
<td align="left">返回v中元素的个数</td>
</tr>
<tr>
<td>v.push_back(t)</td>
<td align="left">向尾端添加一个值为t的元素</td>
</tr>
<tr>
<td>v[n]</td>
<td align="left">返回v中的第n个位置上的元素的<strong>引用</strong></td>
</tr>
<tr>
<td>v1 = v2</td>
<td align="left">将v2中的元素拷贝替换v1中的元素</td>
</tr>
<tr>
<td>v1 = {a, b, c…}</td>
<td align="left">将列表中的元素拷贝替换v1中的元素</td>
</tr>
<tr>
<td>v1 == v2</td>
<td align="left">v1和v2相等当且仅当他们的元素数量相同且对应位置上的元素值都相同</td>
</tr>
<tr>
<td>v1 != v2</td>
<td align="left">…</td>
</tr>
<tr>
<td>&lt;, &lt;=, &gt;, &gt;=</td>
<td align="left">以字典顺序进行比较</td>
</tr>
<tr>
<td><strong>访问vector对象的元素</strong></td>
<td align="left"></td>
</tr>
<tr>
<td>赋值需要用引用</td>
<td align="left"></td>
</tr>
<tr>
<td><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i: v )&#123;	</span><br><span class="line">	i *= i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td align="left"></td>
</tr>
<tr>
<td>只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。</td>
<td align="left"></td>
</tr>
<tr>
<td><strong>vector.size()的问题</strong></td>
<td align="left"></td>
</tr>
<tr>
<td>vector 的size函数返回vector大小，返回值类型为size_type，Member type size_type is an unsigned integral type，即无符号整数；</td>
<td align="left"></td>
</tr>
<tr>
<td>vector a;// 没有初始化时没有元素</td>
<td align="left"></td>
</tr>
<tr>
<td>a.size()返回一个无符号整型，当a的大小是0时，a.size() - 1返回一个正数18446744073709551615，导致访问越界。</td>
<td align="left"></td>
</tr>
<tr>
<td>所以使用for循环的时候可以使用decltype()</td>
<td align="left"></td>
</tr>
<tr>
<td><code>for(decltype(v1.size()) i=0; i&lt;v1.size(); ++i)</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<hr>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>使用迭代器可以访问容器的某个元素，迭代器也能从一个元素移动到另外一个元素。类似于指针类型，迭代器提供了对对象的间接访问。感觉迭代器就是指针加（索引index）的类型之和，比如说vector的迭代器，每个元素都有一个自己对应的迭代器，迭代器按照元素顺序排列，可以前后移动，如果要通过迭代器修改/访问元素，就用解引用符号。注意⚠️迭代器不是索引，它不是从0开始。v.begin()不是0，而且迭代器没有加法运算，只有减法运算。但是可以把迭代器和 两个迭代器之间的距离（iter1 - iter2相加），之后在iterator + difference_type来移动迭代器。<br>在用mid = begin + (end - begin)/2的时候注意， end不是最后一位，而是尾元素之后的一位！</p>
<h4 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h4><ul>
<li>begin成员负责返回指向的第一个元素（或第一个字符）的迭代器。</li>
<li>end成员则负责返回指向容器尾元素的下一个位置的迭代器，也就是说，该迭代器指示的是容器的一个根本不存在的“尾后”元素。<br>如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>() <span class="comment">//b表示v的第一个元素</span></span><br><span class="line"><span class="keyword">auto</span> e = v.<span class="built_in">end</span>() <span class="comment">//e表示v尾元素的下一个位置</span></span><br><span class="line"><span class="comment">// b和e的类型相同</span></span><br></pre></td></tr></table></figure>
<h4 id="迭代器运算符"><a href="#迭代器运算符" class="headerlink" title="迭代器运算符"></a>迭代器运算符</h4>用==和!=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等，否则两个迭代器不相等。</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*iter</td>
<td>返回迭代器iter所指元素的引用（解引用）</td>
</tr>
<tr>
<td>iter-&gt;mem</td>
<td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
<td>++iter</td>
<td>令iter指示容器的下一个元素</td>
</tr>
<tr>
<td>–iter</td>
<td>令iter指示容器的上一个元素</td>
</tr>
<tr>
<td>iter1 == iter2</td>
<td>判断两个迭代器是否相等</td>
</tr>
<tr>
<td>#### 将迭代器从一个元素移到另一个元素</td>
<td></td>
</tr>
<tr>
<td>迭代器使用递增（++）运算符来从一个元素移动到下一个元素。因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用操作。</td>
<td></td>
</tr>
<tr>
<td>例子把string对象中的第一个单词改为大写形式</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"some string"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>() &amp;&amp; !<span class="built_in">isspace</span>(*iter); ++iter)&#123;</span><br><span class="line">	*iter = <span class="built_in">toupper</span>(*iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td><strong>for中使用!=而非&lt;进行判断：因为这种风格在标准库提供的所有容器上都有效。只有string和vector等一些标准库类型有下标运算（s[0]），而并非全都如此。所以标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没定义&lt;运算符。因此要养成使用迭代器和!=的习惯，就不用太在意用的到底是哪种容器类型了。</strong></td>
<td></td>
</tr>
</tbody></table>
<h4 id="迭代器的类型"><a href="#迭代器的类型" class="headerlink" title="迭代器的类型"></a>迭代器的类型</h4><p>那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1;  <span class="comment">//	it1能读写vector&lt;int&gt;中的元素</span></span><br><span class="line"><span class="built_in">string</span>:: iterator it2; <span class="comment">// it2能读写string对象中的字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;	<span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line"><span class="built_in">string</span>::<span class="keyword">const</span> it4	<span class="comment">//it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>
<p>const_iterator和常量指针差不多，能读取但是不能修改所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。</p>
<h4 id="begin和end运算符"><a href="#begin和end运算符" class="headerlink" title="begin和end运算符"></a>begin和end运算符</h4><p>begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> iter1 = v.<span class="built_in">begin</span>(); <span class="comment">//iter1的类型是vector&lt;iter&gt;::iterator;</span></span><br><span class="line"><span class="keyword">auto</span> iter2 = cv.<span class="built_in">begin</span>(); <span class="comment">//iter2的类型是vector&lt;iter&gt;:: const_iterator;</span></span><br><span class="line"><span class="keyword">auto</span> iter3 = v.cbegin(); <span class="comment">//iter3的类型是vector&lt;iter&gt;:: const_iterator;</span></span><br></pre></td></tr></table></figure>
<p><strong>结合解引用和成员访问操作</strong><br>对一个由字符串组成的vector对象来说，想要检查其元素是否为空，令iter是该对象的迭代器，只需要检查iter所指字符串是否为空就可以了：<code>(*it).empty()</code><br>为了简化上述表达，c++语言定义了<strong>箭头运算符</strong>（-&gt;）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，iter-&gt;mem和(*it).mem表达的意思相同。</p>
<p><strong>但凡使用了迭代器循环体，都不要向迭代器所属的容器添加元素（push_back）。</strong></p>
<h4 id="迭代器的运算"><a href="#迭代器的运算" class="headerlink" title="迭代器的运算"></a>迭代器的运算</h4><p>string和vector的迭代器提供了更多的额外的运算符<br>| 代码          | 含义                                                         |<br>| ————- | ———————————————————— |<br>| iter + n      | 迭代器加上一个整数值仍然得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的下一位置 |<br>| iter - n      | 迭代器减去一个整数值仍然得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的头位置 |<br>| iter1+ = n    | 迭代器的复合赋值语句，将iter1加n的结果赋值给iter1            |<br>| iter1 -= n    | 迭代器的复合赋值语句，将iter1减n的结果赋值给iter1            |<br>| iter1 - iter2 | 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器（iter2）向前移动的差值个元素后将得到左侧的迭代器（iter1）。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置 |<br>| &gt;, &gt;=, &lt;, &lt;=  | 迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者为元素的下一位置 |</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> mid = vi.<span class="built_in">begin</span>() + vi.<span class="built_in">size</span>()/<span class="number">2</span>; <span class="comment">//计算得到最接近vi中间元素的一个**迭代器**</span></span><br></pre></td></tr></table></figure>
<p>两个迭代器之间的距离（iter1 - iter2），它的类型是名为difference_type的带符号的整型数，string和vector都定义了difference_type，因为这个距离可正可负。</p>
<h4 id="为什么mid-beg-end-beg-2而非-mid-beg-end-2"><a href="#为什么mid-beg-end-beg-2而非-mid-beg-end-2" class="headerlink" title="为什么mid =beg + (end - beg)/2而非 mid = (beg + end)/2"></a>为什么mid =beg + (end - beg)/2而非 mid = (beg + end)/2</h4><p>C++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。与之相反的，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一容器中的元素或尾后元素。另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。</p>
<p>在本题中，因为迭代器的加法不存在，所以 mid = (beg + end) / 2; 不合法。mid = beg + (end - beg) / 2; 的含义是，先计算 end - beg 的值得到容器中的元素个数，然后控制迭代器从开始出向右移动二分之一容器的长度，从而定位到容器正中间的元素。</p>
<hr>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组与vector类似，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。<br><strong>如果不清楚元素的个数，请使用vector。</strong></p>
<p>数组长度不像vector和string可以用v1.size()<br>只能用sizeof(a)/sizeof(a[0])来表示<br>sizeof()函数可以返回数组所占的内存，而sizeof(a[0])返回的是数组第一个元素所占的内存。每个元素所占内存一致</p>
<h4 id="定义和初始化内置数组"><a href="#定义和初始化内置数组" class="headerlink" title="定义和初始化内置数组"></a>定义和初始化内置数组</h4><ul>
<li>默认情况下，数组的元素被默认初始化（int是0，string是空…）</li>
<li>数组的维度必须是常量表达式</li>
<li>定义数组的时候必须指定数组类型</li>
<li>不允许用auto关键字由初始值的列表推断类型</li>
<li>数组的元素应为对象，不存在存放引用的数组</li>
<li>不允许将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>; <span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>; <span class="comment">//常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];	<span class="comment">//含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *parr[sz];	<span class="comment">//含有42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];	<span class="comment">//错误，cnt不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];	<span class="comment">//当get_size是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure>
<h4 id="显式初始化数组元素"><a href="#显式初始化数组元素" class="headerlink" title="显式初始化数组元素"></a>显式初始化数组元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ial[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//含有3个元素的数组，元素值分别是0, 1, 2</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//等价于a3[] = &#123;0, 1, 2, 0, 0&#125;</span></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;; <span class="comment">//等价于a4[] = &#123;"hi", "bye", ''&#125;</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">//错误：初始值过多超出范围</span></span><br></pre></td></tr></table></figure>
<h4 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h4>字符数组有一种额外的初始化形式，可以用字符串字面值（string）对此类数组初始化。当使用这种方式时，一定要注意<strong>字符串字面值的结尾处还有一个空字符</strong>，但是如果不用string赋值，可以不加空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[]  = &#123;<span class="string">'c'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;; <span class="comment">// 列表初始化，没有空字符，用这种方式不需要强制加空字符</span></span><br><span class="line"><span class="keyword">char</span> a2[] = &#123;<span class="string">'c'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;; <span class="comment">// 列表初始化，含有显示的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"c++"</span>; <span class="comment">// 自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">6</span>] = <span class="string">"Danial"</span>; <span class="comment">// 错误，没有空间可存放空字符，用string初始化会自动添加空字符</span></span><br></pre></td></tr></table></figure>
<h4 id="理解复杂数组声明"><a href="#理解复杂数组声明" class="headerlink" title="理解复杂数组声明"></a>理解复杂数组声明</h4></li>
<li>存放指针的数组</li>
<li>不存在存放引用的数组</li>
<li>数组的指针</li>
<li>数组的引用<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>]; <span class="comment">// ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>]; = <span class="comment">/*?*/</span> <span class="comment">// 错误：不存在存放引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr; <span class="comment">// Parray 指向一个含有10个整型的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr; <span class="comment">// arrRef 引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<code>int *ptrs[10]</code>定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针<br><code>int (*Parray)[10] = &amp;arr</code> *Parray意味着Parray是个指针，Parray指向大小为10的int数组<h4 id="主函数内外的初始值区别"><a href="#主函数内外的初始值区别" class="headerlink" title="主函数内外的初始值区别"></a>主函数内外的初始值区别</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> sa[<span class="number">10</span>];  </span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">string</span> sa2[<span class="number">10</span>];</span><br><span class="line">	<span class="keyword">int</span> ia2[<span class="number">10</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
对于 string 类型的数组来说，因为 string 类本身接受无参数的初始化方式，所以不论数组定义在函数内还是函数外都被默认初始化为空串。<br>对于内置类型 int 来说，数组 ia 定义在所有函数体之外，根据C++的规定，ia 的所有元素默认初始化为0；而数组 ia2 定义在 main 函数的内部，将不被初始化，如果程序试图拷贝或输出未初始化的变量，将遇到未定义的奇异值。<strong>int类型在main函数内不会被默认初始化</strong></li>
</ul>
<h4 id="vector和数组的区别"><a href="#vector和数组的区别" class="headerlink" title="vector和数组的区别"></a>vector和数组的区别</h4><p>数组与 vector 的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问。</p>
<p>数组与 vector 的最大不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能较好，但是与 vector 相比损失了灵活性。vector可以拷贝，数组不能拷贝。</p>
<p>具体来说，数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后原数组的所有元素复制到新数组中去。我们也无法像 vector 那样使用 size 函数直接获取数组的维度。如果是字符数组，可以调用 strlen 函数得到字符串的长度；如果是其他数组，只能使用 sizeof(array).sizeof(array[0]) 的方式计算数组的维度。</p>
<h4 id="访问数组的元素"><a href="#访问数组的元素" class="headerlink" title="访问数组的元素"></a>访问数组的元素</h4><ul>
<li>范围for语句</li>
<li>下标运算符</li>
</ul>
<p>在使用数组下标时，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。</p>
<h4 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h4><p>使用数组的时候编译器一般会把它转化成指针。<br>比如说<code>int a[5] = {1, 2, 3, 4, 5};</code><br>此时数组名称<code>a</code>就是一个指针，指向数组第一个元素。<br>对<code>a</code>解引用<code>*a</code>得到的是数组第一个元素的值1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>]; <span class="comment">// p指向nums的第一个元素</span></span><br><span class="line"><span class="built_in">string</span> *p = nums; <span class="comment">//等价于p2 = &amp;nums[0]</span></span><br></pre></td></tr></table></figure>
<p>在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针</p>
<p>在使用数组作为一个<code>auto</code>变量的初始值时，推断得到的类型是<strong>指针</strong>而非数组<br>但是用<code>decltype()</code>时上述转化不会发生, decltype(ia)返回的类型是由10个整数构成的<strong>数组</strong>, 但是数组的内容可能是奇怪的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>; <span class="comment">//ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;; <span class="comment">//ia3是一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="指针也是迭代器-指针遍历数组"><a href="#指针也是迭代器-指针遍历数组" class="headerlink" title="指针也是迭代器(指针遍历数组)"></a>指针也是迭代器(指针遍历数组)</h4><p>vector和string的迭代器支持的运算，数组的指针也全都支持<br>通过指针遍历数组有两种方法：</p>
<ul>
<li>获取首元素和尾元素下一个位置的指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr; <span class="comment">//定义p为首元素的指针</span></span><br><span class="line">++p;	<span class="comment">//p指向arr[1]</span></span><br><span class="line"><span class="keyword">int</span> *e =&amp;arr[<span class="number">10</span>];	<span class="comment">//arr的尾元素是a[9], 这里指向了arr尾元素的下一位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> *b = arr; b!= e; ++b)&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
注意⚠️一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector的end函数返回的与迭代器类似的功能。要特别注意，尾后指针不能执行解引用和递增操作。</li>
<li>使用标准库函数<strong>begin</strong>和<strong>end</strong>，必须要用iterator头文件<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">begin</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">end</span>;</span><br><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);	<span class="comment">//指向ia元素的指针，注意给变量命名的时候不要用begin，end等关键字！</span></span><br><span class="line"><span class="keyword">int</span> *last = <span class="built_in">end</span>(ia); <span class="comment">//指向arr尾元素的下一位置的指针,类型是int*而不是auto</span></span><br></pre></td></tr></table></figure>
注意区别和<strong>vector的begin和end</strong><br>begin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> iter1 = v.<span class="built_in">begin</span>(); <span class="comment">//iter1的类型是vector&lt;iter&gt;::iterator;</span></span><br><span class="line"><span class="keyword">auto</span> iter2 = cv.<span class="built_in">begin</span>(); <span class="comment">//iter2的类型是vector&lt;iter&gt;:: const_iterator;</span></span><br><span class="line"><span class="keyword">auto</span> iter3 = v.cbegin(); <span class="comment">//iter3的类型是vector&lt;iter&gt;:: const_iterator;</span></span><br></pre></td></tr></table></figure>
<h4 id="指针运算"><a href="#指针运算" class="headerlink" title="指针运算"></a>指针运算</h4><p>给一个指针加上或减去某个整数值，结果仍然是指针。新指针指向的元素与原来的指针相比前进（后退了）该整数值个位置。但是移动不能超过尾元素的下一个位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;; </span><br><span class="line"><span class="keyword">int</span> *ip = arr <span class="comment">//指向arr数组第一个元素</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = ip + <span class="number">4</span>; <span class="comment">//指向arr的尾元素arr[4]</span></span><br></pre></td></tr></table></figure>

<p>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一数组中的元素，而且指针运算没有加法，只有减法，但是也可以把指针和指针之间相减后的距离做加法运算。两个指针相减的结果的类型是<code>ptrdiff_t</code>的标准库类型，它和size_t一样，<code>ptrdiff_t</code>也是一种定义在cstddef头文件中的机器的相关类型。因为差值可能为负数，所以ptrdiff_t是一种带符号的类型。之前vector的迭代器之差的类型是<code>difference_type</code>。<br>如果两个指针指向同一数组的元素，就能利用关系运算&lt;, &gt;, =进行比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> n = <span class="built_in">end</span>(arr) - <span class="built_in">begin</span>(arr)</span><br></pre></td></tr></table></figure>
<h4 id="解引用和指针运算的交互"><a href="#解引用和指针运算的交互" class="headerlink" title="解引用和指针运算的交互"></a>解引用和指针运算的交互</h4><p>指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> last = *(ia + <span class="number">4</span>); <span class="comment">// 把last初始化成8，也就是ia[4]的值。注意，要加上括号</span></span><br></pre></td></tr></table></figure>
<h4 id="下标和指针"><a href="#下标和指针" class="headerlink" title="下标和指针"></a>下标和指针</h4><p>p[-2], []就等于*()</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];<span class="comment">// p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>]; <span class="comment">//p[1]等价于*(p+1),就是ia[3]表示的元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>]; <span class="comment">//p[-2]等价于*(p-2), 就是ia[0]表示的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="标准库类型string，vector"><a href="#标准库类型string，vector" class="headerlink" title="标准库类型string，vector"></a>标准库类型string，vector</h4><h5 id="string-size-type类型-1"><a href="#string-size-type类型-1" class="headerlink" title="string::size_type类型"></a>string::size_type类型</h5><p>对于size函数来说，返回的是一个string::size_type的类型的值，这是一种新的类型。string::size_type函数返回的是一个无符号的整型数。<strong>如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigend可能带来的问题。</strong></p>
<h5 id="vector-size"><a href="#vector-size" class="headerlink" title="vector.size()"></a>vector.size()</h5><p>vector 的size函数返回vector大小，返回值类型为size_type，Member type size_type is an unsigned integral type，即无符号整数；<br>vector a;// 没有初始化时没有元素<br>a.size()返回一个无符号整型，当a的大小是0时，a.size() - 1返回一个正数18446744073709551615，导致访问越界。<br>所以使用for循环的时候可以使用decltype()<br><code>for(decltype(v1.size()) i=0; i&lt;v1.size(); ++i)</code></p>
<h4 id="标准库类型string，vector下标"><a href="#标准库类型string，vector下标" class="headerlink" title="标准库类型string，vector下标"></a>标准库类型string，vector下标</h4><p>标准库类型的下标必须是无符号类型 unsigend</p>
<h4 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标"></a>数组下标</h4><p>在使用数组下标时，没有强制要求通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。</p>
<h4 id="数组维度"><a href="#数组维度" class="headerlink" title="数组维度"></a>数组维度</h4><p>定义数组的维度必须是常量表达式。</p>
<p>关于数组的拷贝，不可以将整个数组赋值给另一个数组，只能逐个元素的拷贝。<br>如果利用vector，可以直接将整个vector拷贝给另一个vector。</p>
<h4 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h4><p><strong>c标准库string函数</strong><br>c风格字符串不是一种类型，而是为了表达和使用字符串而形成的约定熟成的写法。按照此习惯书写的字符串放在字符数组中并以空字符结束，在字符串后面跟着（’\0’），一般用指针来操作这些字符串。<br>cstring头文件定义的函数<br>| 代码           | 含义                                                         |<br>| ————– | ———————————————————— |<br>| strlen(p)      | 返回p                                                        |<br>| strcmp(p1, p2) | 比较p1和p2的相等性。如果p1 ==p2，返回0；如果p1&gt;p2，返回一个正值；如果p1&lt;p2,返回一个负值 |<br>| strcat(p1, p2) | 将p2附加到p1之后，返回p1                                     |<br>| strcpy(p1, p2) | 将p2拷贝给p1                                                 |</p>
<p>传入此类函数的指针必须指向以空字符作为结束的数组，但是空字符不会被计数在内。<br>char ca[] = {‘C’, ‘+’, ‘+’};    //不以空字符结尾<br>cout&lt;&lt;strlen(ca)&lt;&lt;endl;        //错误：ca中没有以空字符结束, 长度会被打印，但是打印长度会出现错误。</p>
<h4 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h4><ul>
<li>string对象的比较<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"A string example"</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">"A different string"</span>;</span><br><span class="line"><span class="keyword">if</span> (s1&lt;s2) <span class="comment">//false: s2小于s1</span></span><br><span class="line">-----------------------------------------------</span><br><span class="line"><span class="comment">//string的加法操作</span></span><br><span class="line"><span class="built_in">string</span> largeStr = s1 + <span class="string">" "</span> + s2;</span><br></pre></td></tr></table></figure></li>
<li>c风格字符串<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</span><br><span class="line"><span class="keyword">if</span> (ca1&lt;ca2) <span class="comment">//	未定义，ca1和ca2是指向数组首地址的指针，两个指针指向的并非同一对象，所以将得到为定义的结果</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(ca1, ca2)&lt;<span class="number">0</span>) <span class="comment">//和两个string对象比较s1&lt;s2效果一样</span></span><br><span class="line">------------------------------------------------</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca3 = ca1 + ca2; <span class="comment">//错误，两个指向不同对象的指针相加，无意义</span></span><br><span class="line"><span class="built_in">strcpy</span>(largeStr, ca1); <span class="comment">//把ca1拷贝给largeStr</span></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, <span class="string">" "</span>);	<span class="comment">//在largeStr的末尾加上一个空格</span></span><br><span class="line"><span class="built_in">strcat</span>(largeStr, ca2);	<span class="comment">//把ca2连接到largeStr后面</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>对于大多数应用来说，使用标准库string要比使用c风格字符串更安全，更高效</strong><br><code>while(空字符)</code>就会停止循环</p>
<hr>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><p>当一个数组的元素仍然是数组时，通常用两个维度来定义它：一个维度表示数组本身的大小，另外一个维度表示其元素（也是数组）大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>]; = &#123;<span class="number">0</span>&#125;; <span class="comment">//将所有元素初始化为0</span></span><br></pre></td></tr></table></figure>
<p>对于二维数组来说，常把第一个维度称作行，第二个维度称作列。</p>
<h4 id="多维数组的初始化"><a href="#多维数组的初始化" class="headerlink" title="多维数组的初始化"></a>多维数组的初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;	<span class="comment">//三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,	<span class="comment">//第一行的初始值</span></span><br><span class="line">&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,	<span class="comment">//第二行的初始值</span></span><br><span class="line">&#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;	<span class="comment">//第三行的初始值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有标识每行的花括号，与之前的初始化语句是等价的</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line"><span class="comment">// 显示地初始化每行的首元素</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;,&#123;<span class="number">4</span>&#125;,&#123;<span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">//显示地初始化第一行的四个元素，其他元素执行默认初始化为0</span></span><br><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="多维数组的下标引用"><a href="#多维数组的下标引用" class="headerlink" title="多维数组的下标引用"></a>多维数组的下标引用</h4><p>如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素。<br>如果表达式的下标运算符数量比数组维度小，则表达式的结果将是给定索引处的一个内层数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>]; <span class="comment">//用arr的首元素为ia最后一行的最后一个元素赋值</span></span><br><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>]; <span class="comment">//把row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure>
<p>把row定义成一个含有4个元素整数的数组的引用（是数组的引用，而不是存放引用的数组（数组的元素必须是对象，不能是引用）），然后将其绑定到ia的第2行。</p>
<h4 id="用for语句处理多维数组"><a href="#用for语句处理多维数组" class="headerlink" title="用for语句处理多维数组"></a>用for语句处理多维数组</h4><h5 id="使用两层嵌套for语句"><a href="#使用两层嵌套for语句" class="headerlink" title="使用两层嵌套for语句"></a>使用两层嵌套for语句</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt]; <span class="comment">//12个为初始化的元素</span></span><br><span class="line"><span class="comment">// 对于每一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i !=rowCnt; ++i)&#123;</span><br><span class="line"><span class="comment">//对于每一列</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j!=colCnt; ++j)&#123;</span><br><span class="line">	<span class="comment">//将元素的位置索引作为它的值</span></span><br><span class="line">	ia[i][j] = i*colCnt + j;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用范围for循环"><a href="#使用范围for循环" class="headerlink" title="使用范围for循环"></a>使用范围for循环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;col : row)&#123;</span><br><span class="line">		col = cnt;</span><br><span class="line">		++cnt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为要改变元素的值，所以得把<strong>控制变量row和col声明成引用类型。</strong><br><strong>使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</strong><br>原因：因为为了避免数组被自动转化成指针。假设不用引用类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> row : ia)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> col : row )&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序将无法通过编译。因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转化成指向该数组首元素的指针。这样得到的row的类型就是int*，显然内层循环就不合法了，编译器将试图在一个int*内遍历，这肯定不行了。</p>
<h4 id="指针和多维数组"><a href="#指针和多维数组" class="headerlink" title="指针和多维数组"></a>指针和多维数组</h4><p>当程序使用多维数组的名字时，也会自动将其转化成指向数组首元素的指针。<br>因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是<strong>指向第一个内层数组的指针</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">// 大小为3的数组，每个元素是含有4个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia; <span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>]; <span class="comment">// p指向ia的尾元素</span></span><br></pre></td></tr></table></figure>
<p>区别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip[<span class="number">4</span>];	<span class="comment">//整型指针的数组，存放了4个指针的数组 </span></span><br><span class="line"><span class="keyword">int</span>(*ip)[<span class="number">4</span>];	<span class="comment">//指向含有4个整数的数组 是一种类型</span></span><br></pre></td></tr></table></figure>
<p>使用指针遍历多维数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia+<span class="number">3</span>; ++p )&#123; <span class="comment">// auto p  = ia指向ia的第一行，p+1指向ia的第二行，p+2指向ia的第三行</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q!=*p+<span class="number">4</span>; ++q )&#123; <span class="comment">//*p是一个含有4个整数的数组, 所以auto q = *p，q 指向数组的首地址</span></span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以通过begin和end实现同样功能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p != <span class="built_in">end</span>(ia); ++p)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q!=<span class="built_in">end</span>(*p); ++q)&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="类型别名简化多维数组指针"><a href="#类型别名简化多维数组指针" class="headerlink" title="类型别名简化多维数组指针"></a>类型别名简化多维数组指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>]; </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<h4 id="多维数组用for遍历输出区别比较"><a href="#多维数组用for遍历输出区别比较" class="headerlink" title="多维数组用for遍历输出区别比较"></a>多维数组用for遍历输出区别比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,</span><br><span class="line">          			&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,  </span><br><span class="line">          			&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用范围for循环输出"><a href="#使用范围for循环输出" class="headerlink" title="使用范围for循环输出"></a>使用范围for循环输出</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] : ia)&#123; <span class="comment">//注意：外层一定要有引用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> col: row)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;col&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以使用auto 来替代复杂的数据类型类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;row : ia)&#123; <span class="comment">//注意：外层一定要有引用</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> col: row)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;col&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用普通for循环-下标运算符"><a href="#使用普通for循环-下标运算符" class="headerlink" title="使用普通for循环 + 下标运算符"></a>使用普通for循环 + 下标运算符</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i!=<span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j!=<span class="number">4</span> ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;ia[i][j]&lt;&lt;<span class="string">' '</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="使用普通for循环-指针"><a href="#使用普通for循环-指针" class="headerlink" title="使用普通for循环 + 指针"></a>使用普通for循环 + 指针</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>(* p)[<span class="number">4</span>] = ia; p != ia+<span class="number">3</span>; ++p)<span class="comment">// 注意 int(*p)[4]是一种类型：指向一个有4个整型元素的数组的指针,ia是指向第一个内层数组的指针</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> *q = *p; q!= *p+<span class="number">4</span>; ++q)<span class="comment">//p是指向一个有4个整型元素的数组的指针，*p是一个有4个整型元素的数组，q是指向数组的首地址的指针</span></span><br><span class="line">       &#123;<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="string">" "</span>;&#125;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>可以使用auto 来替代复杂的数据类型类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia; p != ia+<span class="number">3</span>; ++p)<span class="comment">// 注意 int(*p)[4]是一种类型：指向一个有4个整型元素的数组的指针,ia是指向第一个内层数组的指针</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q!= *p+<span class="number">4</span>; ++q)</span><br><span class="line">        &#123;<span class="built_in">cout</span>&lt;&lt;*q&lt;&lt;<span class="string">" "</span>;&#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://pikache.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>

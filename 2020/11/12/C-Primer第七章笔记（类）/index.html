<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="郭宇祥的博客">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        C++Primer第七章笔记（类） - PiKaChe&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/aircloud.css">

    
<link rel="stylesheet" href="/css/gitment.css">

    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 总得留下些什么吧 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/img/avatar.jpg" />
        </div>
        <div class="name">
            <i>皮卡车</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archives">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类"><span class="toc-text">类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#定义抽象数据类型"><span class="toc-text">定义抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计Sales-data类"><span class="toc-text">设计Sales_data类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义改进的Sales-data"><span class="toc-text">定义改进的Sales_data</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#引入const成员函数"><span class="toc-text">引入const成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在类的外部定义成员函数"><span class="toc-text">在类的外部定义成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义一个返回this对象的函数"><span class="toc-text">定义一个返回this对象的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#定义类相关的非成员函数-不能通过-类-函数-total-isbn-来运用的函数"><span class="toc-text">定义类相关的非成员函数(不能通过 类.函数(total.isbn()) 来运用的函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#默认构造函数"><span class="toc-text">默认构造函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拷贝、赋值和析构"><span class="toc-text">拷贝、赋值和析构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问控制与封装"><span class="toc-text">访问控制与封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用class或struct关键字"><span class="toc-text">使用class或struct关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#友元"><span class="toc-text">友元</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的其他特性"><span class="toc-text">类的其他特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可变数据成员"><span class="toc-text">可变数据成员</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#返回-this的成员函数"><span class="toc-text">返回*this的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类类型"><span class="toc-text">类类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#友元再探"><span class="toc-text">友元再探</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的作用域"><span class="toc-text">类的作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#名字查找与作用域"><span class="toc-text">名字查找与作用域</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数再探"><span class="toc-text">构造函数再探</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数初始值列表"><span class="toc-text">构造函数初始值列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#委托构造函数"><span class="toc-text">委托构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4）隐式的类类型转换"><span class="toc-text">4）隐式的类类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚合类"><span class="toc-text">聚合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字面值常量类"><span class="toc-text">字面值常量类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类的静态成员"><span class="toc-text">类的静态成员</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 总得留下些什么吧 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        C++Primer第七章笔记（类）
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2020-11-12 22:32:03</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#C++" title="C++">C++</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul>
<li>定义抽象数据类型</li>
<li>访问控制与封装</li>
<li>类的其他特性</li>
<li>类的作用域</li>
<li>构造函数再探</li>
<li>类的静态成员</li>
</ul>
<h2 id="定义抽象数据类型"><a href="#定义抽象数据类型" class="headerlink" title="定义抽象数据类型"></a>定义抽象数据类型</h2><h3 id="设计Sales-data类"><a href="#设计Sales-data类" class="headerlink" title="设计Sales_data类"></a>设计Sales_data类</h3><p><code>Sales_item</code> 类有一个名为 <code>isbn</code> 的 <strong>成员函数（member function）</strong>， 并且支持 <code>+ 、= 、+= 、&lt;&lt; 和 &gt;&gt;</code> 运算符。</p>
<p><code>Sales_data</code> 的接口应该包含以下操作：</p>
<ul>
<li>一个 <code>isbn</code> 成员函数，用于返回对象的 <code>ISBN</code> 编号</li>
<li>一个 <code>combine</code> 成员函数，用于将一个 <code>Sales_data</code> 对象加到另一个对象上</li>
<li>一个 <code>add</code> 的函数，执行两个 <code>Sales_data</code> 对象的加法</li>
<li>一个 <code>read</code> 函数，将数据从 <code>istream</code> 读入到 <code>Sales_data</code> 对象中</li>
<li>一个 <code>print</code> 函数， 将 <code>Sales_data</code> 对象的值输出到 <code>ostream</code></li>
</ul>
<h3 id="定义改进的Sales-data"><a href="#定义改进的Sales-data" class="headerlink" title="定义改进的Sales_data"></a>定义改进的Sales_data</h3><p><strong>成员函数（member function）</strong> 的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数(和类无关的函数)，它们的定义和声明都在类的外部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">avg_price</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Sales_data的非成员接口函数</span></span><br><span class="line"><span class="comment">//为什么在参数部分要使用类的引用作为形参类型：</span></span><br><span class="line"><span class="comment">//因为在函数内要改变这个类的具体内容，而不只是拷贝这个类，所以要用引用</span></span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream &amp;<span class="title">print</span><span class="params">(<span class="built_in">std</span>::ostream&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line"><span class="function">srd::istream &amp;<span class="title">read</span><span class="params">(<span class="built_in">std</span>::istream&amp;, Sales_data&amp;)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>定义在类内部的函数是隐式的inline函数</strong></p>
<h4 id="引入const成员函数"><a href="#引入const成员函数" class="headerlink" title="引入const成员函数"></a>引入const成员函数</h4><p><code>string isbn() const{return bookNo;}</code>此处const的含义。</p>
<p>可以等价理解为</p>
<p><code>string isbn(const Sales_data*const this){return bookNo;}</code></p>
<p><code>this通过一个对象调用一个函数，那个对象的地址就是this（this就是一个指针</code>),在c++中所有的成员函数都有this作为隐藏参数。</p>
<p>默认情况下，this的类型是指向类 类型非常量 版本的常量指针（自己的地址无法改变），意味着不能把this绑定到一个<strong>常量对象</strong>，所以不能在一个常量对象上调用普通的成员函数。 </p>
<p>C++允许在成员函数的参数列表后面添加关键字 <code>const</code>，表示 <code>this</code> 是一个指向常量的指针。使用关键字 <code>const</code> 的成员函数被称作 <strong>常量成员函数（const member function）</strong>。</p>
<p>因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。<br>在函数体内都只是读取数据成员的值，而不会做任何改变。</p>
<p><code>常量对象，以及常量对象的引用或指针都只能调用常量成员函数（在函数的参数列表后面添加关键字const的函数）</code></p>
<p>成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的顺序。</p>
<h3 id="在类的外部定义成员函数"><a href="#在类的外部定义成员函数" class="headerlink" title="在类的外部定义成员函数"></a>在类的外部定义成员函数</h3><p>类外部定义的成员的名字必须包含他所属的类名：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Sales_data::avg_price</span><span class="params">()</span><span class="keyword">const</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (units_sold)</span><br><span class="line">    <span class="keyword">return</span> revenue/units_sold;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当使用revenue和units_sold时，实际上它隐式地使用了Sales_data的成员。</p>
<h3 id="定义一个返回this对象的函数"><a href="#定义一个返回this对象的函数" class="headerlink" title="定义一个返回this对象的函数"></a>定义一个返回this对象的函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">  units_sold += rhs.units_sold; <span class="comment">//把rhs的成员加到this对象的成员上</span></span><br><span class="line">  revenue += rhs.revenues;</span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义类相关的非成员函数-不能通过-类-函数-total-isbn-来运用的函数"><a href="#定义类相关的非成员函数-不能通过-类-函数-total-isbn-来运用的函数" class="headerlink" title="定义类相关的非成员函数(不能通过 类.函数(total.isbn()) 来运用的函数)"></a>定义类相关的非成员函数(不能通过 类.函数(total.isbn()) 来运用的函数)</h3><p>辅助函数：比如add、read和print等。尽管这些函数定义的操作从概念上来说属于类的接口组成部分，但它们实际上并不属于类本身。</p>
<p>通常把函数的声明和定义分开来。如果函数在概念上属于类但是不定义在类中，则函数的声明应该与类在同一个头文件中。</p>
<ol>
<li>read函数：将数据从istream读入到Sales_data对象中去<br><code>if(read(cin,total))</code> ==&gt;等于<code>if(cin&gt;&gt;total.bookNo&gt;&gt;total.units_sold&gt;&gt;cin&gt;&gt;total.revenue)</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接受IO类型的应用作为参数，因为IO类型不能被拷贝，因此我们只能通过引用来传递他们，而且因为读写都会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。</span></span><br><span class="line"><span class="function">istream &amp;<span class="title">read</span><span class="params">(istream &amp;is, Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">	<span class="keyword">double</span> prince = <span class="number">0</span>;</span><br><span class="line">	is &gt;&gt; item.bookNo &gt;&gt; item.units_sold &lt;&lt; price;</span><br><span class="line">	item.revenue = price * item.units_sold;</span><br><span class="line">	<span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>print函数:负责将给定对象的内容打印到给定的流中 </li>
</ol>
<p><code>print(cout, total)&lt;&lt;endl;</code>==&gt;等价于<br>`cout&lt;&lt;total.isbn()&lt;&lt;” “&lt;&lt;item.units_sold&lt;&lt;” “&lt;&lt;item.revenue&lt;&lt;” “&lt;&lt;item.avg_prince();</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Sales_data &amp;item)</span></span>&#123;</span><br><span class="line">	os&lt;&lt;item.isbn()&lt;&lt;<span class="string">" "</span>&lt;&lt;item.units_sold&lt;&lt;<span class="string">" "</span>   		&lt;&lt;item.revenue&lt;&lt;<span class="string">" "</span>&lt;&lt;item.avg_price();</span><br><span class="line">	<span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>add函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">	Sales_data sum = lhs;</span><br><span class="line">	sum.combine(rhs);</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。</p>
<p>构造函数的名字和类名相同。构造函数没有返回类型。</p>
<p>构造函数不能被声明成const。当我们创建类的const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量属性”。因此，构造函数在const对象的构造过程中可以向其写值。</p>
<h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><p>如果类没有显示地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。默认构造函数无需任何实参。</p>
<ul>
<li><p>如果存在类内的初始值，用它来初始化成员</p>
</li>
<li><p>否则，默认初始化该成员</p>
</li>
<li><p>如果类内包含有内置类型或者复合类型（指针）的成员，则只有当这些成员全部都人为被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</p>
</li>
</ul>
<ol>
<li>默认构造函数<code>Sales_data() = default</code></li>
<li><code>Sales_data(const std::string &amp;s):bookNo(s){}</code><br><code>Sales_data(const std::string &amp;s, unsigened n, double p):bookNo(s), units_sold(n), revenue(p*n){}</code></li>
</ol>
<p>在冒号和冒号和花括号之间的部分（:bookNo(s), units_sold(n), revenue(p<em>n)）是构造函数初始值列表，他负责为新创建的对象的一个或几个数据成员赋初始值。把s赋给bookNo, n赋给units_sold, p\</em>n赋给revennue。</p>
<p>上面的函数体是空的，因为构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数题也就为空了。</p>
<ol start="3">
<li>以istream为参数的构造函数需要执行一些实际的操作。（在类的外部定义构造函数）因为read（）函数在类的外部</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::Sales_data(<span class="built_in">std</span>::istream &amp;is)&#123;</span><br><span class="line">	<span class="built_in">read</span>(is, *<span class="keyword">this</span>); <span class="comment">//read函数的作用是从is中读取一条交易信息然后存入this对象中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function">Sales_data <span class="title">total</span><span class="params">(<span class="built_in">cin</span>)</span></span>;<span class="comment">//把输入的内容（cin）给到total的构造函数，构造函数会用read函数把cin读入的内容初始化给total的bookNo，units_sold和revenue</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cin</span>)&#123;</span><br><span class="line">	<span class="function">Sales_data <span class="title">trans</span><span class="params">(<span class="built_in">cin</span>)</span></span>;<span class="comment">//把输入的内容（cin）给到trans的构造函数</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">read</span>(<span class="built_in">cin</span>, trans))</span><br><span class="line">	<span class="keyword">if</span> (total.isbn() == trans.isbn())&#123;</span><br><span class="line">	total = add(total, trans);</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<p>用this来吧对象当成一个整体访问，而非直接访问某个成员。在这里我们使用*this将“this”对象作为实参传递给read函数。</p>
<h3 id="拷贝、赋值和析构"><a href="#拷贝、赋值和析构" class="headerlink" title="拷贝、赋值和析构"></a>拷贝、赋值和析构</h3><p>如果不主动对类的对象进行拷贝、赋值和销毁，那编译器将替我们完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">total = trans;</span><br><span class="line"><span class="comment">//它的行为与下面的代码相同</span></span><br><span class="line">total.bookNo = trans.bookNo;</span><br><span class="line">total.units_sold = trans.units_sold;</span><br><span class="line">total.revenue = trans.revenue;</span><br></pre></td></tr></table></figure>

<p>如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版能够正常工作。</p>
<h2 id="访问控制与封装"><a href="#访问控制与封装" class="headerlink" title="访问控制与封装"></a>访问控制与封装</h2><ul>
<li><p>定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。</p>
</li>
<li><p>定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。(在类的外部无法使用total.bookNo; 如果bookNo是private性质的话)</p>
</li>
</ul>
<p>一般来说，作为接口的一部分，</p>
<p>构造函数和一部分成员函数应该定义在 public 说明符之后，<br>而数据成员和作为实现部分的函数则应该跟在 private 说明符之后</p>
<h3 id="使用class或struct关键字"><a href="#使用class或struct关键字" class="headerlink" title="使用class或struct关键字"></a>使用class或struct关键字</h3><ul>
<li>如果我们使用struct关键字，则定义在第一个访问说明符之前（默认的）的成员是public的</li>
<li>如果我们使用class关键字，则定义在第一个访问说明符之前（默认的）的成员是private的</li>
</ul>
<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><p>如果Sales_data的数据成员是private的，那么read、print、add函数无法正常编译了，因为尽管这几个函数是类的接口的一部分，但他们不是类的成员。</p>
<p>类可以允许其他类或者函数访问它的非公有元素(private部分)，方法是令其它类或者函数称为它的友元。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> istream&amp; <span class="title">read</span><span class="params">(istream&amp; is, Sales_data&amp; item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> Sales_data&amp; item)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">friend</span> Sales_data <span class="title">add</span><span class="params">(Sales_data&amp; item1, Sales_data&amp; item2)</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data(istream&amp; is);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;<span class="keyword">return</span> bookNo;&#125;</span><br><span class="line">    <span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">        units_sold += rhs.units_sold;</span><br><span class="line">        revenue += rhs.revenue;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">istream&amp; <span class="title">read</span><span class="params">(istream&amp; is, Sales_data&amp; item)</span></span>;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> Sales_data&amp; item)</span></span>;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(Sales_data&amp; item1, Sales_data&amp; item2)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="类的其他特性"><a href="#类的其他特性" class="headerlink" title="类的其他特性"></a>类的其他特性</h2><p>由类定义的<strong>类型名字（typedef string::size_type pos）</strong>和其他成员一样存在访问限制，可以是 <code>public</code> 或 <code>private</code> 中的一种。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">	pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span> contents;</span><br><span class="line"></span><br><span class="line"><span class="comment">// *******************</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用类型别名等价地声明一个类型名字</span></span><br><span class="line">    <span class="keyword">using</span> pos = <span class="built_in">std</span>::<span class="built_in">string</span>::size_type;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>定义在类内部的成员函数是自动内联的。</p>
<p>如果需要显式声明内联成员函数，建议只在类外部定义的位置说明 <code>inline</code>。</p>
<blockquote>
<p>和我们在头文件中定义 <code>inline</code> 函数的原因一样，<code>inline</code> 成员函数也该与类定义在同一个头文件中。</p>
</blockquote>
<p>成员函数也可以被重载</p>
<h4 id="可变数据成员"><a href="#可变数据成员" class="headerlink" title="可变数据成员"></a>可变数据成员</h4><p>使用关键字 <code>mutable</code> 可以声明 <strong>可变数据成员（mutable data member）</strong>。可变数据成员永远不会是 <code>const</code> 的，即使它在 <code>const</code> 对象内。因此 <code>const</code> 成员函数可以修改可变成员的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">some_member</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">size_t</span> access_ctr;  <span class="comment">// 即使在一个const对象内也能被修改</span></span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::some_member</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ++access_ctr;   <span class="comment">// 保存一个计数值，用于记录成员函数被调用的次数</span></span><br><span class="line">    <span class="comment">// 尽管some_member是一个const成员函数（常量成员函数不能改变调用它的对象的内容），但是access_ctr是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提供类内初始值时，必须使用 <code>=</code> 或花括号形式。</p>
<h3 id="返回-this的成员函数"><a href="#返回-this的成员函数" class="headerlink" title="返回*this的成员函数"></a>返回*this的成员函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Screen &amp;<span class="title">set</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">  contents[<span class="built_in">cursor</span>] = c; <span class="comment">//设置当前光标所在位置的新值</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;		<span class="comment">//将this对象作为左值返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>)</span><br><span class="line"><span class="comment">//为什么这个函数的返回类型是Screen（类）的引用&amp; 而不是Screen类型？</span></span><br><span class="line"><span class="comment">//因为如果定义返回类型不是引用，那么set返回值将是*this的副本，而不是*this本身，那么我们想要设置该光标位置所在的值就不是对于myScreen这个对象来设置，而是对它的副本来设置了</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>const 成员函数如果以引用形式返回 *this，则返回类型是常量引用。</p>
</blockquote>
<ul>
<li>非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。</li>
<li>虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的选择。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 根据对象是否是const重载了display函数</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span></span></span><br><span class="line"><span class="function">    </span>&#123; do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Screen &amp;<span class="title">display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; do_display(os); <span class="keyword">return</span> *<span class="keyword">this</span>; &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 该函数负责显示Screen的内容</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">do_display</span><span class="params">(<span class="built_in">std</span>::ostream &amp;os)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; os &lt;&lt; contents; &#125;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Screen <span class="title">myScreen</span><span class="params">(<span class="number">5</span>,<span class="number">3</span>)</span></span>;				<span class="comment">//myscreen是非常量对象</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> Screen <span class="title">blank</span><span class="params">(<span class="number">5</span>, <span class="number">3</span>)</span></span>;		<span class="comment">//blank是常量对象</span></span><br><span class="line">myScreen.<span class="built_in">set</span>(<span class="string">'#'</span>).<span class="built_in">display</span>(<span class="built_in">cout</span>);    <span class="comment">//调用非常量版本</span></span><br><span class="line">blank.<span class="built_in">display</span>(<span class="built_in">cout</span>);    			<span class="comment">//调用常量版本</span></span><br></pre></td></tr></table></figure>

<h3 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h3><p>每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。</p>
<p>我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，也可以把类名跟在关键字 <code>class</code> 或 <code>struct</code> 后面：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data iteml;			<span class="comment">// 默认初始化Sales_data类型的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> <span class="title">iteml</span>;</span>		<span class="comment">// 一条等价的声明</span></span><br></pre></td></tr></table></figure>

<p>可以仅仅声明一个类而暂时不定义它。这种声明被称作 <strong>前向声明（forward declaration）</strong>，用于引入类的名字。在类声明之后定义之前都是一个 <strong>不完全类型（incomplete type）</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span>   <span class="comment">// Screen类的声明</span></span><br></pre></td></tr></table></figure>

<p>不完全类型只能在非常有限的情景下使用：</p>
<ul>
<li>可以定义指向不完全类型的指针或引用，</li>
<li>也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。</li>
</ul>
<p>必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。</p>
<p>但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link_screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="友元再探"><a href="#友元再探" class="headerlink" title="友元再探"></a>友元再探</h3><p>除了普通函数，类还可以把 【其他类】 或【其他类的成员】 函数声明为友元。此外， 友元函数能定义在类的内部， 这样的函数是隐式内联的。</p>
<p>友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr的成员可以访问Screen类的私有部分</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>;</span></span><br><span class="line">    <span class="comment">// Screen类的剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个类负责控制自己的友元类或友元函数</p>
</blockquote>
<p>把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。</p>
<p>如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 友元函数可以定义在类的内部 */</span> &#125;</span><br><span class="line">    X() &#123; f(); &#125;   <span class="comment">// 错误：f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125;     <span class="comment">// 错误：f还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;   					<span class="comment">// 声明那个定义在x中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125;     <span class="comment">// 正确：现在f的声明在作用域中了</span></span><br></pre></td></tr></table></figure>

<h2 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h2><p>一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须提供类名和函数名。在类的外部，成员的名字被隐藏起来了。</p>
<p>当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。</p>
<p>函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window_mgr</span>&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ScreenIndex <span class="title">addScreen</span><span class="params">(<span class="keyword">const</span> Screen&amp;)</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//首先处理返回类型，之后我们才进入Window_mgr的作用域</span></span><br><span class="line">Window_mgr::ScreenIndex <span class="comment">//注意这之后没有分号</span></span><br><span class="line">Window_mgr::addScreen(<span class="keyword">const</span> Screen &amp;s)&#123;</span><br><span class="line">  screen.push_back(s);</span><br><span class="line">  <span class="keyword">return</span> screens.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="名字查找与作用域"><a href="#名字查找与作用域" class="headerlink" title="名字查找与作用域"></a>名字查找与作用域</h4><blockquote>
<p>编译器处理完类中的全部声明后才会处理成员函数的定义。</p>
</blockquote>
<p>成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。</p>
<p>声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。</p>
<ul>
<li>如果某个成员的声明使用了类中尚未出现的名字，编译器将会在定义该类的作用域中继续查找。</li>
<li>如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125; <span class="comment">// 使用外层作用域的Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money; 			<span class="comment">// 错误：不能重新定义Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>成员函数中名字的解析顺序：</p>
<ul>
<li>在成员函数内查找该名字的声明，只有在【函数使用之前】出现的声明才会被考虑。</li>
<li>如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。</li>
<li>如果类内也没有找到，会在成员函数定义之前的作用域查找。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这段代码仅为了说明而用，不是一段很好的代码</span></span><br><span class="line"><span class="comment">// 通常情况下不建议为参数和成员使用同样的名字</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">height</span>;   <span class="comment">// 定义了一个名字，稍后将在Screen中使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cursor</span> = <span class="built_in">width</span> * <span class="built_in">height</span>;  <span class="comment">// 哪个height? 是那个参数</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pos <span class="built_in">cursor</span> = <span class="number">0</span>;</span><br><span class="line">    pos <span class="built_in">height</span> = <span class="number">0</span>, <span class="built_in">width</span> = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式地使用 <code>this</code> 指针来强制访问成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不建议的写法：成员函数中的名字不应该隐藏同名的成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos <span class="built_in">height</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span> = <span class="built_in">width</span> * <span class="keyword">this</span>-&gt;<span class="built_in">height</span>;  	<span class="comment">// 成员height</span></span><br><span class="line">    <span class="comment">// 另外一种表示该成员的方式</span></span><br><span class="line">    <span class="built_in">cursor</span> = <span class="built_in">width</span> * Screen::<span class="built_in">height</span>;  	<span class="comment">// 成员height</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建议的写法：不要把成员名字作为参数或其他局部变量使用variable(不要使用相同的名字命名多个参数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Screen::dummy_fcn</span><span class="params">(pos ht)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cursor</span> = <span class="built_in">width</span> * <span class="built_in">height</span>;  			<span class="comment">// 成员height</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Type <span class="title">Exercise::setVal</span><span class="params">(Type parm)</span> </span>&#123; </span><br><span class="line">    val = parm + initVal();  <span class="comment">//此处使用的是类内的initVal函数</span></span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结：看到 Exercise(类)::setVal(Type parm) 给它说明了这个函数是来自于类Exercise的，那么表示函数内所有的东西（形参，函数内的变量都是用的是这个类定义的参数）。但是最初的的Type没有指定是哪个作用域的，所以是全局的参数。</p>
<h2 id="构造函数再探"><a href="#构造函数再探" class="headerlink" title="构造函数再探"></a>构造函数再探</h2><h3 id="构造函数初始值列表"><a href="#构造函数初始值列表" class="headerlink" title="构造函数初始值列表"></a>构造函数初始值列表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConstRef</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ConstRef(<span class="keyword">int</span> ii);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> ci;</span><br><span class="line">    <span class="keyword">int</span> &amp;ri;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数的两种写法 </span></span><br><span class="line"><span class="comment">//1. 先默认初始化，再重新赋值给这些变量</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii)&#123;</span><br><span class="line">  i = ii;   	<span class="comment">//正确</span></span><br><span class="line">  ci = ii;	  <span class="comment">//错误，ci已经被默认初始化为0，不能给const int再赋值，再改变一个const参数的值</span></span><br><span class="line">  ri = i;			<span class="comment">//错误，ri是一个引用，默认初始化的时候没有给它绑定对象，没有被初始化，产生错误。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 直接初始化变量</span></span><br><span class="line"><span class="comment">//正确：显式地初始化引用和const成员</span></span><br><span class="line">ConstRef::ConstRef(<span class="keyword">int</span> ii): i(ii), ci(ii), ri(i) &#123; &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>尽量使用 2.直接初始化变量的形式建立构造函数，避免产生错误。</p>
</blockquote>
<blockquote>
<p>最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。</p>
</blockquote>
<blockquote>
<p>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</p>
</blockquote>
<p>初始化顺序只与数据成员在类中出现的次序有关，而与初始值列表的顺序无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">	X (<span class="keyword">int</span> i, <span class="keyword">int</span> j): base(i), rem(base % j) &#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> rem, base;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类 <code>X</code> 中，两个数据成员出现的顺序是 <code>rem</code> 在前，<code>base</code> 在后，所以当执行 <code>X</code> 对象的初始化操作时先初始化 <code>rem</code>。如上述代码所示，初始化 <code>rem</code> 要用到 <code>base</code> 的值，而此时 <code>base</code> 尚未被初始化，因此会出现错误。该过程与构造函数初始值列表中谁出现在前面谁出现在后面没有任何关系。</p>
<p>修改的方法很简单，只需要把变量 <code>rem</code> 和 <code>base</code> 的次序调换即可，形式是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span> &#123;</span></span><br><span class="line">	X (<span class="keyword">int</span> i, <span class="keyword">int</span> j): base(i), rem(base % j) &#123;&#125;</span><br><span class="line">	<span class="keyword">int</span> base, rem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h3><p>C++11扩展了构造函数初始值功能，可以定义 委托构造函数（delegating constructor）。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 非委托构造函数使用对应的实参初始化成员</span></span><br><span class="line">    Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price):</span><br><span class="line">    	bookNo(s), units_sold(cnt), revenue(cnt*price) &#123;  &#125;</span><br><span class="line">    <span class="comment">// 其余构造函数全都委托给另一个构造函数</span></span><br><span class="line">   Sales_data():<span class="function">Sales <span class="title">data</span><span class="params">(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>)</span> </span>&#123;  &#125;</span><br><span class="line">	 Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s):Sales_data(s, <span class="number">0</span>, <span class="number">0</span>) &#123;  &#125;</span><br><span class="line">	 Sales_data(<span class="built_in">std</span>::istream &amp;is):<span class="function">Sales <span class="title">data</span><span class="params">()</span> </span>&#123; <span class="built_in">read</span>(is, *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认构造函数</p>
<p>当对象被默认初始化或值初始化时会自动执行默认构造函数。<br>就是在类内为构造函数准备好了实参。如果某个构造函数包含若干形参，但是同时为这些形参都提供了默认实参，则该构造函数也具备默认构造函数的功能。</p>
<p>默认初始化的发生情况：</p>
<ul>
<li>在块作用域内不使用初始值定义非静态变量或数组。</li>
<li>类本身含有类类型的成员且使用合成默认构造函数。</li>
<li>类类型的成员没有在构造函数初始值列表中显式初始化。</li>
</ul>
<p>值初始化的发生情况：</p>
<ul>
<li>数组初始化时提供的初始值数量少于数组大小。</li>
<li>不使用初始值定义局部静态变量。</li>
<li>通过 <code>T()</code> 形式（<em>T</em> 为类型）的表达式显式地请求值初始化。</li>
</ul>
<p>类必须包含一个默认构造函数。</p>
<blockquote>
<p>在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</p>
</blockquote>
<p>对于类来说编译器是不会默认初始化一个类的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDefalut</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:NoDefalut(<span class="keyword">int</span> a):val(a)&#123;&#125; <span class="comment">//NoDefault类无默认构造函数</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NoDefalut nd;</span><br><span class="line">    C(<span class="keyword">int</span> i = <span class="number">0</span>): nd(i)&#123;&#125; <span class="comment">//在这里C的构造函数赋予实参0，作为C的默认构造函数！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4）隐式的类类型转换"><a href="#4）隐式的类类型转换" class="headerlink" title="4）隐式的类类型转换"></a>4）隐式的类类型转换</h4><p>如果构造函数【只接受一个实参】，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为 <strong>转换构造函数（converting constructor）</strong>。</p>
<blockquote>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//combine 函数的定义</span></span><br><span class="line"><span class="function">Sales_data&amp; <span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; rhs)</span></span>&#123;</span><br><span class="line">        units_sold += rhs.units_sold;</span><br><span class="line">        revenue += rhs.revenue;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>;</span><br><span class="line"><span class="comment">//构造一个临时的Sales_data对象</span></span><br><span class="line"><span class="comment">//该对象的units_sold和revenue等于0，bookNo等于null_book</span></span><br><span class="line">item.combine(null_book);<span class="comment">//编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。</span></span><br></pre></td></tr></table></figure>

<p>编译器只会自动执行一步类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：需要用户定义的两种转换。</span></span><br><span class="line"><span class="comment">// (1) 把"9-999-99999-9"转换成string</span></span><br><span class="line"><span class="comment">// (2) 再把这个(临时的)string转换成Sales_data</span></span><br><span class="line">item.combine(<span class="string">"9-999-99999-9"</span>);</span><br><span class="line"><span class="comment">// 正确：显式地转换成string，隐式地转换成Sales_data</span></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"9-999-99999-9"</span>));</span><br><span class="line"><span class="comment">// 正确: 隐式地转换成string，显式地转换成Sales_data</span></span><br><span class="line">item.combine(Sales_data(<span class="string">"9-999-99999-9"</span>));</span><br></pre></td></tr></table></figure>

<p>在要求隐式转换的程序上下文中，可以通过将【构造函数】声明为 <code>explicit</code> (清楚的)的加以阻止。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">        bookNo(s), units_sold(n), revenue(p*n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>: <span class="title">bookNo</span><span class="params">(s)</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">item.combine(null_book);<span class="comment">//错误：string构造函数是explicit的</span></span><br><span class="line">item.combine(<span class="built_in">cin</span>);<span class="comment">//错误: istream的构造函数是explicit的</span></span><br></pre></td></tr></table></figure>

<p><code>explicit</code> 关键字只对接受一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 <code>explicit</code> 的。只能在类内声明构造函数时使用 <code>explicit</code>关键字，在类外定义时不能重复。</p>
<p>执行拷贝初始化时（使用 <code>=</code>）会发生隐式转换，所以 <code>explicit</code> 构造函数只能用于直接初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span> <span class="params">(null_book)</span></span>;   <span class="comment">// 正确: 直接初始化</span></span><br><span class="line"></span><br><span class="line">Sales_data item2 = null_book;	<span class="comment">// 错误：不能将explicit构造函数用于拷贝形式的初始化过程</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当我们用 <code>explicit</code> 关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。</p>
</blockquote>
<p>尽管编译器不会将 <code>explicit</code> 的构造函数用于隐式转换过程，可以使用 <code>explicit</code> 构造函数显式地强制转换类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确: 实参是一个显式构造的Sales_data对象</span></span><br><span class="line">item.combine(Sales_data(null_book));</span><br><span class="line"><span class="comment">// 正确：static_cast可以使用explicit的构造函数</span></span><br><span class="line">item.combine(<span class="keyword">static_cast</span>&lt;Sales_data&gt;(<span class="built_in">cin</span>));</span><br></pre></td></tr></table></figure>

<h3 id="聚合类"><a href="#聚合类" class="headerlink" title="聚合类"></a>聚合类</h3><p>聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下【所有条件】时，我们说它是聚合的：</p>
<ul>
<li><p>所有成员都是public</p>
</li>
<li><p>没有定义任何构造函数</p>
</li>
<li><p>没有类内初始值</p>
</li>
<li><p>没有基类，也没有virtual函数</p>
</li>
</ul>
<p>下面的类是一个聚合类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。【初始值顺序必须与声明顺序一致】。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// val1.ival = 0; val1.s = string("Anna")</span></span><br><span class="line">Data val1 = &#123; <span class="number">0</span>, <span class="string">"Anna"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：不能使用"Anna"初始化ival，也不能使用1024初始化s</span></span><br><span class="line">Data va12 = &#123; <span class="string">"Anna"</span>, <span class="number">1024</span> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="字面值常量类"><a href="#字面值常量类" class="headerlink" title="字面值常量类"></a>字面值常量类</h3><p>数据成员都是字面值类型的【聚合类】是字面值常量类（字面值类型：算术类型、指针、引用，不是字面值类型的有：IO库、String类型 ）。或者一个类不是聚合类，但符合下列全部条件，则也是字面值常量类：</p>
<ul>
<li>数据成员都是字面值类型。</li>
<li>类至少含有一个 <code>constexpr</code> 【构造函数】。</li>
<li>如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的 <code>constexpr</code> 构造函数。</li>
<li>类必须使用析构函数的默认定义。</li>
</ul>
<p><code>constexpr</code> 构造函数用于生成 <code>constexpr</code> 对象以及 <code>constexpr</code> 函数的参数或返回类型。</p>
<p><code>constexpr</code> 构造函数必须初始化所有数据成员，初始值使用 <code>constexpr</code> 构造函数或常量表达式。</p>
<h2 id="类的静态成员"><a href="#类的静态成员" class="headerlink" title="类的静态成员"></a>类的静态成员</h2><p>使用关键字 <code>static</code> 可以声明类的静态成员，可以是 <code>public</code> 的或 <code>private</code> 的，静态数据成员的类型可以是常量、引用、指针、类类型等等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> owner;</span><br><span class="line">    <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">initRate</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。</p>
<p>类似的， 静态成员函数也不与任何对象绑定在一起。<br>由于静态成员不与任何对象绑定，因此静态成员函数不能声明为 <code>const</code> 的，也不能在静态成员函数内使用 <code>this</code> 指针。</p>
<p>用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r;</span><br><span class="line">r = Account::rate(); <span class="comment">// 使用作用域运算符访问静态成员</span></span><br><span class="line"></span><br><span class="line">Account ac1;</span><br><span class="line">Account *ac2 = &amp;ac1;</span><br><span class="line"><span class="comment">// 调用静态成员函数rate的等价形式</span></span><br><span class="line">r = ac1.rate(); 	<span class="comment">// 通过Account的对象或引用</span></span><br><span class="line">r = ac2-&gt;rate(); 	<span class="comment">// 通过指向Account对象的指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数不用通过作用域运算符就能直接使用静态成员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>&#123; amount += amount * interestRate; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> interestRate;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在类外部定义静态成员时，不能重复 <code>static</code> 关键字，其只能用于类内部的声明语句。</p>
<blockquote>
<p>和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。<code>static</code>关键字则只出现在类内部的声明语句中。</p>
</blockquote>
<p>由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。【而必须在类外部定义并初始化每个静态成员】。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义并初始化一个静态成员</span></span><br><span class="line"><span class="keyword">double</span> Account::interestRate = initRate();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。</p>
</blockquote>
<p>尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供 <code>const</code> 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 <code>constexpr</code>。</p>
<p>初始值必须是常量表达式，因为这些成员本身就是常量表达式， 所以它们能用在所有适合于常量表达式的地方。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">rate</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> interestRate; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rate</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> period = <span class="number">30</span>;  <span class="comment">// period是常量表达式</span></span><br><span class="line">    <span class="keyword">double</span> daily_tbl[period];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</blockquote>
<p>静态成员独立于任何对象。</p>
<p>特别的， 静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Bar mem1;   	<span class="comment">// 正确：静态成员可以是不完全类型</span></span><br><span class="line">    Bar *mem2;    		<span class="comment">// 正确：指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;   		<span class="comment">// 错误：数据成员必须是完全类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bkground表示一个在类中稍后定义的静态成员</span></span><br><span class="line">    <span class="function">Screen&amp; <span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分， 这么做的结果是无法真正提供一个对象以便从中获取成员的值， 最终将引发错误。</p>

        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span id="busuanzi_container_site_pv">
            <span id="busuanzi_value_site_pv"></span>PV
        </span>
        <span id="busuanzi_container_site_uv">
            <span id="busuanzi_value_site_uv"></span>UV
        </span>
        Created By <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>  Theme <a href="https://github.com/aircloud/hexo-theme-aircloud" target="_blank" rel="noopener">AirCloud</a></p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>

<script src="/js/index.js"></script>

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


    <script>
        /**
         *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
         *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables
        */
        if( '' || '')
        var disqus_config = function () {
            this.page.url = '';  // Replace PAGE_URL with your page's canonical URL variable
            this.page.identifier = ''; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };

        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document, s = d.createElement('script');
            s.src = 'https://pikache.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();
    </script>



</html>

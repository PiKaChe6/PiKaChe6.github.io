[{"title":"引用和指针","url":"/2020/05/29/引用和指针/","content":"## 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n```c++\nint a = 10;\nint & ref = a;\nref = 20; //此时a的值也是20。\n```\n### 引用传参\n用一个例子解释引用的作用。\n```c++\n#include <iostream>\n#include \"Sales_item.h\"\nusing namespace std;\nvoid func1(int a){\n    a = a*3;\n}\n\nvoid func2(int & a){\n    a = a*3;\n}\n\nint main() {\n    int b = 10;\n    func1(b);\n    cout<<b<<endl; // 此时b = 10。\n    func2(b);\n    cout<<b<<endl;// 此时b = 30。\n}\n```\n#### 使用函数1的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc1(b）等价于func1(**int a = b**）把b的10赋值给a{\n    a = a*3;a等于30。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b等于原来的10。\n}\n#### 使用函数2的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc2(b）等价于func1(**int & a = b**）把b和引用a绑定，此时a是b的别名，a和b的地址相同，修改a的值等同于修改b的值{\n    a = a*3; a等于30，此时b也等于30，因为a和b此时已经绑定在一起了。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b已经通过函数2被改变了值为30。\n}\n\n---\n\n### const的引用\n可以把引用绑定到const对象上，就像绑定到其他对象上一样。但是对常量的引用不能被用作修改它所绑定的对象：\n```c++\nconst int ci = 1024;\nconst int &r1 = ci;\nr1 = 42;\t//错误：r1是对常量的引用，无法改变\nint &r2 = ci;\t//错误：试图让一个非常量引用指向一个常量对象\n```\n#### 初始化和对const的引用\n！！注意！！\nint &r = 0;\t//错误，引用只能绑定对象\nconst int &r = 0; //正确，允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式\n引用类型必须和引用对象的类型一致，但是有两个**例外**\n在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式：\n\n```c++\nint i = 42;\nconst int &r1 = i;\nconst int &r2 = 42;\n\ndouble dval = 3.14;\nint &r2 = dval\t// 错误，因为引用和对象类型不同\nconst int &r3 = dval;\t//正确：输出3\n```\n#### 对const的引用可能引用一个并非const的对象\n常量引用仅对引用可参与的操作做出来限定，对于引用对象本身是不是常量未作出限定。因为对象也可能是个非常量，所以允许其他途径改变它的值。\n+ 对象：非常量\n+ 引用： 常量\n导致绑定后的引用无法改变值，永远等于绑定前对象的初始值，如果之后对象的值改变，那么对象值将不等于绑定的引用值。\n```c++\nint i = 42;\nint &r1 = i;\t// 引用r1绑定对象i\nconst int &r2 = i;\t//引用r2页绑定对象i，但是不允许通过r2修改i的值\nr1 = 10；\t//r1并非常量，i的值修改为0\nr2 = 0；\t//错误：r2是一个常量引用\ni = 10；\t//此时r2还是等于42，可以修改i的值，i此时为10，但是无法修改与它绑定的引用的值\n```\n\n---\n\n## 指针\n指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点：\n+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。\n+ 指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n### 指针的定义\n数据类型 * 指针变量\nint * ipl, * ipl2;\ndouble dp, * dp2;\n\n### 获取对象的地址\n指针存放某个对象的地址，要想获取改地址，需要使用**取地址符&**。\nint ival = 42;\nint * p = & ival;\t// p存放变量ival的地址，或者说p是指向变量ival的指针。\n### 利用指针访问对象\n如果指针指向了一个对象，则允许使用 解引用符* 来访问该对象。 \n​```c++\nint ival = 42;\nint * p = &ival; //\tp存放着ival的地址。 \ncout<< *p; // 由符号*得到指针所指的对象，输出42\n```\n对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也是给指针所指的对象赋值：\n\n​```c++\n*p = 0;\t// 由符号*得到指针p所指的对象，即可经由p为变量ival赋值\ncout<<*p; // 输出0\n```\n### 概念区分\n+ & 和数据类型一起出现：声明一个引用\n+ \\* 和数据类型一起出现：声明一个指针\n+ & 单独出现：取地址符，和对象（变量）一起使用，代表对象的地址\n+ \\* 单独出现：解引用符，和指针一起使用，代表指针包含地址的值\n```c++\nint i = 42;\nint & r =i; // &紧随类型出现，因此是声明的一部分，r是一个引用，并且和对象i绑定在一起\nint *p; // *紧随类型出现，因此是声明的一部分，p是一个指针\np = & i;\t// &出现在表达式中，是一个取地址符\n*p = i；\t// *出现在表达式中，是解引用符\nint & r2 = *p // &是声明的一部分，*是一个解引用符\n```\n在声明语句中，& 和* 用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同的场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当成不同的符号来看。\n### 空指针\n空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。空指针生成方法：\n+ int \\*p = nullptr; \n+ int \\*p2 = 0;\n+ int \\*p3 = NULL;\n```c++\nif (pi)\n...// pi的值是0， 因此条件值是false\nif(pi2)\n...// pi指向ival，因此它的值不是0，条件是true\n```\n任何非0指针对应的条件值都是true。\n\n### void\\* 指针\nvoid\\*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\\*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址到底存放着什么类型的对象不了解。\n```c++\ndouble obj = 3.14, *pd = &obj;\nvoid *pv = &obj;\t// obj可以是任意类型的对象\npv = pd;\t//pv可以存放任意类型的指针\n```\n### 指向指针的指针\n指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。\n通过\\*的个数可以区分指针的级别。\\*\\*表示指向指针的指针，\\*\\*\\*表示指向指针的指针的指针。\n```c++\nint ival = 1024;\nint *pi = &ival;\t// pi指向int型的数\nint **ppi = &pi;\t// ppi指向一个int型的指针\n```\n同样对于指针的指针也需要解引用时也要解两次\\*\\*ppi\n### 指向指针的引用\n引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用\n```c++\nint i = 42;\nint *p;\t//p是一个int类型的指针\nint *&r = p;\t//r是一个对指针p的引用,所以是指针的别名，类型也属于指针（引用）\nr = &i;\t//r引用了一个指针，因此给r赋值&i就是另p指向i，因为r和p已经捆绑在一起了\n*r = 0;\t//解引用r得到i，也就是p指向的对象，将i的值改为0\n```\n要了解int \\*&r = p中的r的类型到底是什么，最简单的方法是从左向右阅读r的定义。离变量名最近的符号（&）对变量有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，这里的符号\\*说明r的引用是一个指针。\n### 指针和const\n指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：\n```c++\nconst double pi = 3.14;\t//pi是个常量，它的值不能改变\ndouble *ptr = &pi;\t//错误：ptr是个普通指针\nconst double *cptr = &pi\t//正确：cptr可以指向双精度常量\n*cptr = 42;\t//错误：不能给*cptr赋值\n```\n指针的类型必须与其所指对象的类型一致，但是有两个**例外**。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：\n+ 指针：常量\n+ 指针指向的对象：可以是非常量\n```c++\ndouble dval = 3.14;\t//对象：非常量\ncptr = &dval;\t//指针：常量\n```\n和常量引用一样，指向常量的指针没有规定其所指对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值能不能通过其他途径改变。\n#### const指针\n+ 指向常量的指针（pointer to const）：const int\\*ptr = &pi: 指针变量保存的内存地址是可以修改的，指针变量所指向的内存也是允许读取数据的，但是我们不能修改指针变量里面所指向的内存里面的数据。\n\n+ 常量指针（const pointer）：int \\*const ptr= &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。常量指针必须初始化，初始化一旦完成，则它的值（存放在指针中的地址）就不能再改变了。\n\n+ 指向常量的常量指针：const int \\*const ptr = &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存是允许读取数据的，我们不可以修改指针变量里面所指向的内存里面的数据。\n```c++\nint main() {\n    int number1 = 233;\n    int number2 = 666;\n    //指向常量的指针（pointer to const）\n    const int *pointer =  &number1;\n\t\tpointer = &number2;\t//可以修改指针变量保存的地址\n    *pointer = 666;\t//错误，不能修改指针变量里面所指向的内存里面的数据\n    //常量指针（const pointer）\n    int *const pointer2 = &number1;\n    pointer2 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //可以修改指针变量里面所指向的内存里面的数据\n    //指向常量的常量指针\n    const int *const pointer3 = &number1;\n    pointer3 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //错误，不可以修改指针变量里面所指向的内存里面的数据\n    \n}\n```\n"},{"title":"傅立叶变换在图像处理的应用","url":"/2020/05/09/傅立叶变换在图像处理的应用/","content":"**傅立叶**：任何连续的周期信号，可以由一组适当的正弦曲线组合而成。（Any univariate function can be rewritten as a weighted sum of sines and cosines of different frequencies.）\n\n---\n一个恰当的比喻是将傅立叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅立叶变换可以看作数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑时，讨论他的光谱或频率谱。同样，傅立叶变换使我们能通过频率成分来分析一个函数。\n\n---\n\n<iframe height=300 width=300 src=\"https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif\"></iframe>\n\n---\n\n## 用一个例子解释一维傅立叶变换\n\n我们一般描述一个函数都是基于时间域，如图所示表示了这个函数随时间变化的变化（x轴是时间的变化，y轴是（信号）强度的变化）。\t\n![timedomain](timedomain.JPG)\n但是其实还有一种方法也可以描述这个函数，就是频率域。就比如上图中的函数可以写成\nf(x) = 3sin(0.8x) + 7sin(0.3x) + 2sin(0.2x)\n的形式。就是相当于给了频率为0.8, 0.3和0.2的sin函数不同的权重并把它们加起来。所以也可以由下图来表示。\n![frequencedomain](frequencedomain1.JPG)\n![frequencedomain](frequencedomain2.JPG)\n虽然两张图看起来截然不同，但是他们表述的是同种东西，而傅立叶变换就是描述这种从时域到频率域的变换。\n当然也要考虑相位的变化。\n![phase](phase.JPG)\n\n---\n\n## 傅立叶变换在二维图像处理中的应用\n\n![DFT](dft.png)\n傅立叶变换在二维图像处理中想法与之前一维类似，图像处理中的傅立叶变换是基于二维矩阵，如图所示，x轴和y轴共同表示图像中的位置，z轴表示每个位置（像素点）的灰度值。\n![imagedomain](imagedomain.JPG)\n\n和之前的一维函数相比较可以得出对应关系：\n\n|一维函数|二维图像|\n|---|---|\n|时间|距离|\n|信号强度|灰度值|\n\n---\n\n\n### 傅立叶变换的特点\n\n图像DFT(离散傅立叶变换)的基本属性是其周期性和复共轭对称性。频谱以周期N在两个方向上无止境地重复，即F（u，v）= F（u + kN，v + lN）其中k，l∈[-∞，...，-1，0，1， 2，...，∞]。从具有2D DFT的N×N图像计算出的傅立叶系数F（u，v）的N×N块是此无限序列的单个周期\n![equation](equation.png)\n注意看这里对于频率域的每个点（u，v）都需要时间域所有点的相关信息。\n\n### 二维图像中傅立叶变换的原理\n二维的sin波动可以用如下公式表述：\n*z = a sin(ux+vy)*\nz是波的高度（强度）。\na是幅值，表示波的最高高度。\nu是波浪在x方向上重复的次数（x方向上的频率）。\nv是波浪在y方向上重复的次数（y方向上的频率）。\n如图所示，当v=0的时候，sin的波只在x轴方向波动，当u=0的时候，sin的波只在y轴方向波动，如果u和v都不为0，那么就会在xy叠加方向以角度u/v波动（比如对角线方向）。\n![waves](waves.png)\n如下图，把每个像素点上述的波叠加起来，然后这些波会相互抵消，相互叠加。\n![waves_overlay](waves2.png)\nu是波浪在x方向上重复的次数（x方向上的频率），它可以是1，2，3... \t1表示单位距离内在x方向上重复1次，2表示单位距离内在x方向上重复2次...\n比如，f（2，2）这个像素，它的灰度值在x方向上以sin波波动了3次，在y方向上以sin波波动了4次，那么它在频率域对于点F（3，4）就有一点贡献。F（u，v）的值就是这张图内所有像素点贡献值之和，就是在那个x方向u频率和y方向的v频率的sin波动的强度大小的矢量和。F(3，4)那点的亮度就是表示了整张图的所有像素点在x方向上以频率3灰度的波动和在y方向上以频率4灰度的波动之和的强度（能量大小）。在频率域上的中心点（0，0）表示在x和y方向上都没有波动，它的值是所有灰度值和的平均值。所以在频率域中，中间是低频率，外部是高频率。\n\n### 二维图像傅立叶变换在opencv中的实现\n```\nimport cv2 as cv\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimg = cv.imread('messi5.jpg',0) # 读入图片\nf = np.fft.fft2(img) # 用np自带功能把图片进行傅立叶变换\nfshift = np.fft.fftshift(f) # 调换象限，中心化处理\nmagnitude_spectrum = 20*np.log(np.abs(fshift)) #因为进行变换之后是复数，所以要取绝对值，用log函数是为了能把变换后的图像显示的更加清楚。\nplt.subplot(121),plt.imshow(img, cmap = 'gray') #subplot第一个数字是行数，第二个列数，第三个是index\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()\n```"},{"title":"二分法","url":"/2020/05/06/二分法/","content":"\n首先二分法只适用于已经排序过的数组。\n二分法的思想就是通过每次排除一半的数列，在剩余一半的数组中查找目标值并返回其所在的位置。相比于直接查找二分法的效率更高，其时间复杂度是O(log2n)。\n\n---\n\n### python代码实现：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return \"Target is not in the list.\"\n```\n\n### 用例子解释为什么循环执行的条件是left<=right：\n[3，8，15，21，35，54，63，79，82，92，97] #目标数列\n0     1      2     3      4      5       6     7      8       9     10 #目标数列的序号\n\n**第一轮**：\nleft_index = 0,  right_index = 10,  mid_index = (0+10)/2 = 5, taget = 87\n\n**第二轮**：\nleft_index = 0 < right_index = 10\nmid = 54<87\n所以left_index = mid_index+1 = 5+1 = 6\nmid_index = (6+10)/2 = 8所以mid对应的值是82\n\n**第三轮**\nleft_index = 6 < right_index = 10\nmid = 82<87\n所以left_index = mid_index+1= 8+1 = 9\nmid_index = (9+10)/2 = 9所以mid对应的值是92\n\n**第四轮**\nleft_index = 9 < right_index = 10\nmid = 92>87(Target value)\n所以right_index = mid_index-1 = 9-1 = 8\n\n**第五轮**\nleft_index = 9 **>** right_index = 8\n不满足while循环跳出\n\n---\n\n## 题目\n### leetcode 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n---\n\n这道题目可以用二分法查找元素，但是多出了如果被查找元素不在给定数列内，要把它插在合适的位置的要求。\npython解法的代码：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return left\n```\n只需要把最后的return \"Not in the list\"改成return left就行。\n**为什么最后改成return left就行**：\n从之前举的例子可以看出，在执行到第五轮的时候，将会跳出循环，此时，left和right的值都是要比查找值target大，所以才会跳出循环导致无法查找，所以这意味着此时只要返回left的index就可以了，就相当于把此时的left向后移动一位插入这个需要被查找的元素。\n\n### leetcode 69. x 的平方根\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n\n---\npython解法的代码\n```\ndef mySqrt(x):                              \n    left = 0                                \n    right = x                               \n    while left <= right:                    \n        mid = (left + right) // 2           \n        if mid ** 2 <= x < (mid + 1) ** 2:  \n            return mid                      \n        if mid ** 2 > x:                    \n            right = mid - 1                 \n        if (mid + 1) ** 2 <= x:             \n            left = mid + 1                         \n```\n思路和之前很相似，确定什么时候可以返回刚好是根号数，就是在这个数的平方小于或等于x的时候以及这个数加一的平方大于x的时候，有了这个限制条件就可以写代码了。因为另外两种情况下就正好在mid的左半边和mid的右半边进行寻找。"},{"title":"相机标定(Camera Calibration)","url":"/2020/05/03/相机标定-Camera-Calibration/","content":"## 相机模型\n首先我们知道物体本身是不发光的，我们所看到的有颜色的物体都是都是物体反射太阳或其他光源基于大脑的色觉系统所产生的。而相机就是基于人类的色觉系统所制造成的。比如下图的我们眼中的绿巨人浩克，多条不同方向的光线在他身上反射后会被右侧相机的光学传感器所接收。\n![Hulk](Hulk.png)\n\n如果不对这些光线做处理，绿巨人身上的每一点都会作用于光学传感器上的每一个像素，产生如下图的效果。\n![green](green.png)\n\n很显然，这并不是我们想要的结果，所以人们就想到如果能把多余的反射光线遮住，使得实物上的每一点和相机上的每一个像素相对应，由此就得出来最简单的单孔相机（pinhole）模型，如下图所示。\n\n![pinhole](pinhole.png)\n\n得到了简单的单孔模型之后，我们又引出了焦距（focus length）的概念，根据相似的定义可以知道焦距越小所得到图像也越小，而且是和实物上下颠倒。\n\n![focus length](focuslength.png)\n\n因为单孔模型会遮掉很多多余的反射光线，使得光线的利用率不高，所以为了提高光线的利用率我们想到可以把带小孔的遮光板换成透镜，这样既可以提高光线的利用率，又可以满足我们之前的要求。\n\n![lens](lens.png)\n\n---\n\n## 相机矩阵\n"}]
[{"title":"傅立叶变换在图像处理的应用","url":"/2020/05/09/傅立叶变换在图像处理的应用/","content":"**傅立叶**：任何连续的周期信号，可以由一组适当的正弦曲线组合而成。（Any univariate function can be rewritten as a weighted sum of sines and cosines of different frequencies.）\n\n<iframe height=300 width=300 src=\"https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif\">"},{"title":"数据结构心得","url":"/2020/05/07/数据结构心得/","content":"之前和朋友聊天的时候发现一个问题，很多通信公司宣传的百兆光纤，最高能达到100Mb/s的下载速度。可是当我自己办了那个网之后发现下载资料文件根本达不到100Mb/s，最多能达到10兆每秒就很难得了。\n![vodafone](vodafone.png)\n最后在同学的提醒下发现，商家们宣传的100Mb/s中的单位是Mb/s其中的b是小写的b，是比特(bit)的缩写。而大家平时电脑里存放的文件的最小单位是字节(Byte)，文件大小可能是KB，MB或者是GB，这里的B是大写的B！单位换算如下：\n1Byte = 8 bit\n1KB = 2<sup>10</sup> Byte = 1024 Byte\n1MB = 2<sup>10</sup> KB = 1024 KB\n1GB = 2<sup>10</sup> MB = 1024 MB\n所以我们在计算下载速度的时候应该将100/8 = 12.5MB/s比较符合常理。\n\n\n\n\n"},{"title":"二分法","url":"/2020/05/06/二分法/","content":"\n首先二分法只适用于已经排序过的数组。\n二分法的思想就是通过每次排除一半的数列，在剩余一半的数组中查找目标值并返回其所在的位置。相比于直接查找二分法的效率更高，其时间复杂度是O(log2n)。\n\n---\n\n### python代码实现：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return \"Target is not in the list.\"\n```\n\n### 用例子解释为什么循环执行的条件是left<=right：\n[3，8，15，21，35，54，63，79，82，92，97] #目标数列\n0     1      2     3      4      5       6     7      8       9     10 #目标数列的序号\n\n**第一轮**：\nleft_index = 0,  right_index = 10,  mid_index = (0+10)/2 = 5, taget = 87\n\n**第二轮**：\nleft_index = 0 < right_index = 10\nmid = 54<87\n所以left_index = mid_index+1 = 5+1 = 6\nmid_index = (6+10)/2 = 8所以mid对应的值是82\n\n**第三轮**\nleft_index = 6 < right_index = 10\nmid = 82<87\n所以left_index = mid_index+1= 8+1 = 9\nmid_index = (9+10)/2 = 9所以mid对应的值是92\n\n**第四轮**\nleft_index = 9 < right_index = 10\nmid = 92>87(Target value)\n所以right_index = mid_index-1 = 9-1 = 8\n\n**第五轮**\nleft_index = 9 **>** right_index = 8\n不满足while循环跳出\n\n---\n\n## 题目\n### leetcode 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n---\n\n这道题目可以用二分法查找元素，但是多出了如果被查找元素不在给定数列内，要把它插在合适的位置的要求。\npython解法的代码：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return left\n```\n只需要把最后的return \"Not in the list\"改成return left就行。\n**为什么最后改成return left就行**：\n从之前举的例子可以看出，在执行到第五轮的时候，将会跳出循环，此时，left和right的值都是要比查找值target大，所以才会跳出循环导致无法查找，所以这意味着此时只要返回left的index就可以了，就相当于把此时的left向后移动一位插入这个需要被查找的元素。\n\n### leetcode 69. x 的平方根\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n\n---\npython解法的代码\n```\ndef mySqrt(x):                              \n    left = 0                                \n    right = x                               \n    while left <= right:                    \n        mid = (left + right) // 2           \n        if mid ** 2 <= x < (mid + 1) ** 2:  \n            return mid                      \n        if mid ** 2 > x:                    \n            right = mid - 1                 \n        if (mid + 1) ** 2 <= x:             \n            left = mid + 1                         \n```\n思路和之前很相似，确定什么时候可以返回刚好是根号数，就是在这个数的平方小于或等于x的时候以及这个数加一的平方大于x的时候，有了这个限制条件就可以写代码了。因为另外两种情况下就正好在mid的左半边和mid的右半边进行寻找。"},{"title":"相机标定(Camera Calibration)","url":"/2020/05/03/相机标定-Camera-Calibration/","content":"## 相机模型\n首先我们知道物体本身是不发光的，我们所看到的有颜色的物体都是都是物体反射太阳或其他光源基于大脑的色觉系统所产生的。而相机就是基于人类的色觉系统所制造成的。比如下图的我们眼中的绿巨人浩克，多条不同方向的光线在他身上反射后会被右侧相机的光学传感器所接收。\n![Hulk](Hulk.png)\n\n如果不对这些光线做处理，绿巨人身上的每一点都会作用于光学传感器上的每一个像素，产生如下图的效果。\n![green](green.png)\n\n很显然，这并不是我们想要的结果，所以人们就想到如果能把多余的反射光线遮住，使得实物上的每一点和相机上的每一个像素相对应，由此就得出来最简单的单孔相机（pinhole）模型，如下图所示。\n\n![pinhole](pinhole.png)\n\n得到了简单的单孔模型之后，我们又引出了焦距（focus length）的概念，根据相似的定义可以知道焦距越小所得到图像也越小，而且是和实物上下颠倒。\n\n![focus length](focuslength.png)\n\n因为单孔模型会遮掉很多多余的反射光线，使得光线的利用率不高，所以为了提高光线的利用率我们想到可以把带小孔的遮光板换成透镜，这样既可以提高光线的利用率，又可以满足我们之前的要求。\n\n![lens](lens.png)\n\n---\n\n## 相机矩阵\n"}]
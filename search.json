[{"title":"C++Primer第一章和第二章笔记","url":"/2020/06/09/C-Primer第一章和第二章笔记/","content":"\n## 第一章\n\t++val;\n\n表示了val = val+1;\n源代码模式 commad + /\n\n#### 读取数量不定的输入数据\n```\nwhile (std::cin>>value)\n```\nwhile 会一直执行直到遇到文件结束符（或错误输入）。\n在这里clion对ctrl +d的是stop and rerun， 所以结束输入就不能用ctrl+d，但可以输入一个不是int的数据类型来结束它。\n\n## 第二章（变量和基本类型）\n### 基本数据类型\n当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则结果为true。\n当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。\n\n---\n|类型|最小尺寸|\n|---|---|\n|char|8 bit|\n|wchar_t|16 bit|\n|int|16 bit|\n|long|32 bit|\n|long long|64 bit|\n|float| 32 bit|\n|double| 64 bit|\n|long double| 96 or 128 bit|\n\n---\n当一个算数表达式中既有无符号数又有int时，那个int值就会转成无符号数。比如：\nunsigned u = 10;\nint i = -42\nstd::cout<< u + i << std::endl; 如果int占32位，输出4294967264。\n\n---\n以0开头的整形代表8进制，以0x或0X的开头代表十六进制。\n科学计数法，其中指数部分用E或e标识。50 = 5e1, 0.01 = 1e-2\n\n---\n单引号字符char，双引号字符串。\n字符串String字面值的类型实际上是由常量字符构成的数组（array）。\n编译器在每个字符串的结尾处添加一个空字符（'\\0')，因此，字符串字面值的实际长度要比他的内容多1。例如，字面值'A'表示的是单独的字符A，而字符串\"A\"则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符。\n\n---\n'a'就是char，L'a'就是wchar_t\nchar占一个字节，wchar_t占两个字节，也就是16个比特（bit），最大值就是2<sup>16</sup>-1=65535，到这里读者可以看出宽字符和窄字符最大的区别就是占字节大小的不同\n![unicode](unicode.png)\n\n10u: unsigned\n3.14L: Long double\n如'\\012'就是八进制数012所对应的字符，也就是ASCII码10所对应的字符，即换行\n\n**需要注意的是转义序列在程序中是被当作字符而不是字符串来使用的**\n\n```\ncout<<'2'<<'\\t'<<'M'<<'\\n';\n```\n#### 默认初始化\n三条性质：\n\n1.定义在任何函数体外的变量会被初始化为0。 \n\n2.定义在函数体内部的变量不会被初始化。 \n\n3.类的对象未被初始化，则初值由类决定。\n\n#### 声明(declaration)和定义(definition)\n\ndeclaration: say the function exists. 在一个cpp文件中调用另一个cpp文件（一个函数），需要在cpp中声明这个被调用的函数\n\ndefinition: what the function is.\n\n①变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。\n\n②变量声明：用于向程序表明变量的类型和名字。\n\n③定义也是声明：当定义变量时我们声明了它的类型和名字。\n\n④extern关键字：通过使用extern关键字声明变量名而不定义它。\n\n1、定义包含了声明，但是声明不包含定义，\n\n如  int a = 0; //定义并声明了变量 a\n\nextern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。\n2、函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。\n\nvoid fun1();  //函数声明\n\nvoid fun1(){  //函数定义\n    cout<<\"fun1\"<<endl;\n}\n\n---\n\n### 复合类型(具体见另一篇文章)\n#### 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）\n为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化(比如 int &a = b, 之前已经定义b = 10)，使它指向一个已存在的对象(b)\n\n例如：\n\nint i, j;\n\nint &ri = i\t//定义int的引用ri，并初始化为变量i的引用 \n\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n\n#### 指针\n\n可以通过指针来间接访问内存\n##### 定义指针\nint a =10;\n数据类型 * 指针变量\nint * p; \n让指针记录变量a的地址， &这个操作符就是取地址。\np = &a；\n\n##### 使用指针\n可以通过解引用的方式来找到指针的内存，找到指针p（原数据的地址）中的原数据\n* p = 1000；//更改之后a的值也变为1000\n##### 指针所占用的内存空间\n在32位操作系统：占用4个字节\n在64位操作系统：占用8个字节(所有指针，int *，float * ，char *......)\n##### 空指针和野指针\n空指针：指针变量指向内存为0的空间\n用途：初始化指针变量\n注意：空指针指向的内存是不可以访问的, 0~255为系统占用内存\nint * p = NULL;\n\n---\n野指针：指针变量指向非法的内存空间\nint * p = (int * )0x1100; 自己定义的一个16进制数，自己定义的一块内存\n\n#### 常量表达式\n常量表达式（**const expression**）是指**不会改变**并且**在编译过程就能得到计算结果**的表达式。\n常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。需要计算一个编译时已知的常量，比如特定值的sine或cosin？确实你亦可以使用库函数sin或cos，但那样你必须花费运行时的开销。使用constexpr，你可以创建一个编译时的函数，它将为你计算出你需要的数值。用户的电脑将不需要做这些工作。\n一个对象是不是常量表达式由它的数据类型和初始值共同决定：\n\n```c++\nconst int max_files = 20;\t// 是常量表达式\nconst int limit = max_files + 1 //是常量表达式\nint staff_size = 27; // 不是常量表达式\nconst int sz = get_size();\t// sz不是常量表达式\n```\n\n尽管staff_size的初始值（27）是个字面常量值，但是由于它的数据类型只是个普通的int而非const int所以不属于常量表达式\n尽管sz本身是个常量，但是具体值到运行时才能获取到，所以也不是常量表达式\n**常量表达式就是等号左右两边都是常量的表达式。**\n一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型\n\n```c++\nconstexpr int mf = 20;\t//20是常量表达式\nconstexpr int limit = mf + 1; //mf + 1是个常量表达式\nconstexpr sz = size();\t//只有当size是一个constexpr函数时才是一条正确的声明语句\n```\n常量表达式必须是**字面值类型**：算数类型，引用类型和指针类型。\n**非字面值类型**：自定义类Sales_item, IO库，String类不属于字面值类型，也就不能被定义成constexp指针的初始值必须是nullptr或者是0，或者是储存于某个固定地址中的对象。\n函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其固定地址不变，能用来初始化constexpr指针。\nconstexpr声明中如果定义了指针，限定符constexpr仅对指针有效，与指针所指的对象无关：\n\n```c++\nconst int *p = nullptr;\t//p是一个 指向整型常量 的指针\nconstexprint *p = nullptr;\t//q是一个 指向整数 的 常量指针\n```\n\n---\n### 处理类型\n#### 类型别名\n有两种方法可以定义类型别名。\n+ 传统的方法是使用关键字**typedef**：\n```c++\ntypedef double wages;\t//wages是double的同义词,之后出现wages就和出现double一样\nwages x = 10.1；\ntypedef wages base, *p; //base是double的同义词，p是double*的同义词\n```\n+ 使用别名声明来定义类型的别名：\n相对来说更加直观、简单\n```c++\nusing SI = Sales_item; //SI是Sales_item的同义词\nusing x = double; \nx number = 666.66//之后使用x就像使用double一样\n这种方法的关键字using作为别名声明的开始，其后紧跟别名和等号，起作用是把等号左侧的名字规定成等号右侧的类型的别名。\n```\n#### auto类型说明符\nauto类型说明符：auto让编译器通过初试值来推算变量的类型。auto定义的变量必须有初始值。\n```c++\nauto item = val1 + val2;\n```\n此处编译器将根据val1和val2相加的结果来推断item的类型。如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item;如果这两个变量类型是double，则item的类型就是double，以此类推。\n##### 复合类型，常量和auto\n使用引用其实是使用引用的对象，特别是当被用作为初始值时，真正参与初始化的其实是引用对象的值。\n```c++\nint i = 0, &r = i;\nauto a = r; // a是一个整数（r是i的别名，而i是一个整数）\n```\nauto会忽略掉顶层const（常量指针），同时底层const（指向指针的常量）则会保留下来，比如当初始值是一个指向常量的指针时。\n但是\n\n```c++\nconst int ci = i, &cr = ci;\nauto b = ci; //b是一个整数（ci的顶层const特性被忽略了）\nauto c = &i; //c是一个整型指针\nconst auto f = ci； //如果希望推出的auto类型是一个顶层const，则需要明确指出\n```\n注意！！\n```c++\nconst int i = 42;\nauto *p = &i;//此时p的类型是const int*，指向指针的常量，底层const不会被忽略。\n```\n#### decltype\n作用：希望从表达式的类型推断出要定义的变量，但是不想用该表达式的值初始化变量。它的作用是选择并返回操作数的数据类型。\n```c++\ndecltype(f()) sum = x;\t//sum的类型就是函数f的返回类型\n```\n如果decltype使用的表达式是个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n```c++\nconst int ci = 0, &cj = ci;\ndecltype(cj) x = 0;\t//x的类型是const int\ndecltype(cj) y = x; //y的类型是const int&，y绑定到变量x\ndecltype(cj) z; //错误：z是一个引用，必须初始化\n```\ndecltype和引用\n```c++\nint i =42, *p = &i, &r = i;\ndecltype(r) = a; //a是int引用类型和通过引用r和i绑定\ndecltype(r+0) b; //正确，加法的结果是int，因此b是一个（未初始化的）int\ndecltype(*p) c; //错误，c是int&，必须初始化\n\ndecltype((i)) d; //错误，d是int&，必须初始化\ndecltype(i) e; //正确，e是一个未初始化的int\n```\n对于decltype：\n+ 推测引用变量本身的类型得到的仍是引用\n+ 如果表达式的内容是解引用操作（\\*p），decltype将得到引用类型\n+  推测变量的类型时，如果多加了一层括号，结果差别很大。双层括号的结果永远是引用，而decltype（variable）单层括号结果只有当varible本身就是一个引用时才是引用。\n\n---\n**总结一下上面的区别**\n\n+ typedef, using: 把一些double，int等已知的数据类型重命名，命名成自己想要的名称。\n+ auto：通过初始值来推算变量的数据类型\n+ decltype：把某一个变量的数据类赋给另一个变量，让这两个数据变量类型相同。\n\n**auto和decltype的区别**\n如果面对一个变量是引用，那么auto会把那个类型看作是和该引用绑定对象的类型（int），而decltype会把它看作是引用本身的引用类型（int &）\n```c++\nint i = 42, &r = i;\nauto a = r; //a的类型是int（和r绑定的对象的类型）\ndecltype(r) b = i; //b的类型是引用int&，所以必须初始化和对象i绑定\n```\n\n---\n### 自定义数据结构\n数据结构是把一组相关的数据元素组织起来然后使用他们的策略和方法。就比如说int就是把所有整数作为一种数据类型，所以我们也可以自己定义某一类具有共同点的元素作为数据类型。\n比如说Sales_data类型\n```c++\nstruct Sales_data{\n\tstd::string bookNo; //书的编号\n\tunsigned units_sold = 0; // 卖出的数量，无符数\n\tdouble revenue = 0.0; //收入\n}\n```\n自定义数据结构以关键字struct开始，紧跟着类名和实体，最后的分号不能省略\n还有一种自定义结构以class作为关键字，也就是常说的类。以后会经常遇到。\n#### struct和class的区别\n在C++中struct和class的唯一区别就在于**默认的访问权限不同**, 继承的时候不推荐使用struct\n+ struct默认权限为public\n+ class默认权限为private\n```c++\nclass C1{\n\tint a;\n};\nstruct C2{\n\tint a;\n};\nint main(){\n\tC1 c1; //实例化\n\tc1.a = 10; //错误，默认的情况下class的成员为private，只能在类内访问，不能在类外访问\n\tC2 c2；\n\tc2.a = 10； //正确，默认的情况下struct的成员为public，既能在类内访问，又能在类外访问\n}\n```\n类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。\n类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该对象的定义所以分号不可少。\n#### 类数据成员（attribute）\n+ 类的数据成员定义了类的对象的具体内容\n+ 每个对象有自己的一份数据成员拷贝\n+ 修改一个数据成员，不会印象其他对象\n+ 创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化（0，空字符...）。\n\n#### 头文件\n为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样，例如把Sales_data类定义在名为Sales_data.h的头文件中。\n头文件通常包含那些只能被定义一次的实体，如类、const变量和constexpr变量等\n##### 头文件的书写规范\n+ #include\"header.h\" //表明当前文件和\"header.h\"处于同一工程且同一目录，一般是自己的类文件\n+ #include<header.h> //表明header.h和当前文件不属于同一工程，是外部目录，一般是标准库\n##### 头文件保护符（header guard）\n就是为了在主文件中如果多次引用了某个头文件的话，第一次引用会把头文件拷贝进主文件，之后再引用，就不要再把头文件再拷贝过来一次。\n**/#define** 指令把一个名字设置为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef** 当且仅当变量已定义时为真，**#ifndef** 当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到**#endif**指令为止。这些功能就能有效地防止重复包含的发生：\n```c++\n# ifndef SALES_DATA_H // 如果没有定义过SALES_DATA_H\n# define SALES_DATA_H// 那么定义SALES_DATA_H\n# include<string>\nstruct Sales_data{\n\tstd::string bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n}\n# endif\n```\n后面如果再一次包含Sales_data.h,则#ifndef的检查结果将为假，编译器将会忽略#ifndef到#endif之间的部分。\n\n\n\n\n"},{"title":"引用和指针","url":"/2020/05/29/引用和指针/","content":"## 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n```c++\nint a = 10;\nint & ref = a;\nref = 20; //此时a的值也是20。\n```\n### 引用传参\n用一个例子解释引用的作用。\n```c++\n#include <iostream>\n#include \"Sales_item.h\"\nusing namespace std;\nvoid func1(int a){\n    a = a*3;\n}\n\nvoid func2(int & a){\n    a = a*3;\n}\n\nint main() {\n    int b = 10;\n    func1(b);\n    cout<<b<<endl; // 此时b = 10。\n    func2(b);\n    cout<<b<<endl;// 此时b = 30。\n}\n```\n#### 使用函数1的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc1(b）等价于func1(**int a = b**）把b的10赋值给a{\n    a = a*3;a等于30。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b等于原来的10。\n}\n#### 使用函数2的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc2(b）等价于func1(**int & a = b**）把b和引用a绑定，此时a是b的别名，a和b的地址相同，修改a的值等同于修改b的值{\n    a = a*3; a等于30，此时b也等于30，因为a和b此时已经绑定在一起了。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b已经通过函数2被改变了值为30。\n}\n\n---\n\n### const的引用\n可以把引用绑定到const对象上，就像绑定到其他对象上一样。但是对常量的引用不能被用作修改它所绑定的对象：\n```c++\nconst int ci = 1024;\nconst int &r1 = ci;\nr1 = 42;\t//错误：r1是对常量的引用，无法改变\nint &r2 = ci;\t//错误：试图让一个非常量引用指向一个常量对象\n```\n#### 初始化和对const的引用\n！！注意！！\nint &r = 0;\t//错误，引用只能绑定对象\nconst int &r = 0; //正确，允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式\n引用类型必须和引用对象的类型一致，但是有两个**例外**\n在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式：\n\n```c++\nint i = 42;\nconst int &r1 = i;\nconst int &r2 = 42;\n\ndouble dval = 3.14;\nint &r2 = dval\t// 错误，因为引用和对象类型不同\nconst int &r3 = dval;\t//正确：输出3\n```\n#### 对const的引用可能引用一个并非const的对象\n常量引用仅对引用可参与的操作做出来限定，对于引用对象本身是不是常量未作出限定。因为对象也可能是个非常量，所以允许其他途径改变它的值。\n+ 对象：非常量\n+ 引用： 常量\n导致绑定后的引用无法改变值，永远等于绑定前对象的初始值，如果之后对象的值改变，那么对象值将不等于绑定的引用值。\n```c++\nint i = 42;\nint &r1 = i;\t// 引用r1绑定对象i\nconst int &r2 = i;\t//引用r2页绑定对象i，但是不允许通过r2修改i的值\nr1 = 10；\t//r1并非常量，i的值修改为0\nr2 = 0；\t//错误：r2是一个常量引用\ni = 10；\t//此时r2还是等于42，可以修改i的值，i此时为10，但是无法修改与它绑定的引用的值\n```\n\n---\n\n## 指针\n指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点：\n+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。\n+ 指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n### 指针的定义\n数据类型 * 指针变量\nint * ipl, * ipl2;\ndouble dp, * dp2;\n\n### 获取对象的地址\n指针存放某个对象的地址，要想获取改地址，需要使用**取地址符&**。\nint ival = 42;\nint * p = & ival;\t// p存放变量ival的地址，或者说p是指向变量ival的指针。\n### 利用指针访问对象\n如果指针指向了一个对象，则允许使用 解引用符* 来访问该对象。 \n```c++\nint ival = 42;\nint * p = &ival; //\tp存放着ival的地址。 \ncout<< *p; // 由符号*得到指针所指的对象，输出42\n```\n对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也是给指针所指的对象赋值：\n\n\n```c++\n*p = 0;\t// 由符号*得到指针p所指的对象，即可经由p为变量ival赋值\ncout<<*p; // 输出0\n```\n### 概念区分\n+ & 和数据类型一起出现：声明一个引用\n+ \\* 和数据类型一起出现：声明一个指针\n+ & 单独出现：取地址符，和对象（变量）一起使用，代表对象的地址\n+ \\* 单独出现：解引用符，和指针一起使用，代表指针包含地址的值\n```c++\nint i = 42;\nint & r =i; // &紧随类型出现，因此是声明的一部分，r是一个引用，并且和对象i绑定在一起\nint *p; // *紧随类型出现，因此是声明的一部分，p是一个指针\np = & i;\t// &出现在表达式中，是一个取地址符\n*p = i；\t// *出现在表达式中，是解引用符\nint & r2 = *p // &是声明的一部分，*是一个解引用符\n```\n在声明语句中，& 和* 用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同的场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当成不同的符号来看。\n### 空指针\n空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。空指针生成方法：\n+ int \\*p = nullptr; \n+ int \\*p2 = 0;\n+ int \\*p3 = NULL;\n```c++\nif (pi)\n...// pi的值是0， 因此条件值是false\nif(pi2)\n...// pi指向ival，因此它的值不是0，条件是true\n```\n任何非0指针对应的条件值都是true。\n\n### void\\* 指针\nvoid\\*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\\*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址到底存放着什么类型的对象不了解。\n```c++\ndouble obj = 3.14, *pd = &obj;\nvoid *pv = &obj;\t// obj可以是任意类型的对象\npv = pd;\t//pv可以存放任意类型的指针\n```\n### 指向指针的指针\n指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。\n通过\\*的个数可以区分指针的级别。\\*\\*表示指向指针的指针，\\*\\*\\*表示指向指针的指针的指针。\n```c++\nint ival = 1024;\nint *pi = &ival;\t// pi指向int型的数\nint **ppi = &pi;\t// ppi指向一个int型的指针\n```\n同样对于指针的指针也需要解引用时也要解两次\\*\\*ppi\n### 指向指针的引用\n引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用\n```c++\nint i = 42;\nint *p;\t//p是一个int类型的指针\nint *&r = p;\t//r是一个对指针p的引用,所以是指针的别名，类型也属于指针（引用）\nr = &i;\t//r引用了一个指针，因此给r赋值&i就是另p指向i，因为r和p已经捆绑在一起了\n*r = 0;\t//解引用r得到i，也就是p指向的对象，将i的值改为0\n```\n要了解int \\*&r = p中的r的类型到底是什么，最简单的方法是从左向右阅读r的定义。离变量名最近的符号（&）对变量有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，这里的符号\\*说明r的引用是一个指针。\n### 指针和const\n指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：\n```c++\nconst double pi = 3.14;\t//pi是个常量，它的值不能改变\ndouble *ptr = &pi;\t//错误：ptr是个普通指针\nconst double *cptr = &pi\t//正确：cptr可以指向双精度常量\n*cptr = 42;\t//错误：不能给*cptr赋值\n```\n指针的类型必须与其所指对象的类型一致，但是有两个**例外**。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：\n+ 指针：常量\n+ 指针指向的对象：可以是非常量\n```c++\ndouble dval = 3.14;\t//对象：非常量\ncptr = &dval;\t//指针：常量\n```\n和常量引用一样，指向常量的指针没有规定其所指对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值能不能通过其他途径改变。\n#### const指针\n+ 指向常量的指针（pointer to const）：const int\\*ptr = &pi: 指针变量保存的内存地址是可以修改的，指针变量所指向的内存也是允许读取数据的，但是我们不能修改指针变量里面所指向的内存里面的数据。**底层const：**指针所指的对象是个常量。\n\n+ 常量指针（const pointer）：int \\*const ptr= &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。常量指针必须初始化，初始化一旦完成，则它的值（存放在指针中的地址）就不能再改变了。**顶层const：**指针本身就是一个常量。\n\n+ 指向常量的常量指针：const int \\*const ptr = &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存是允许读取数据的，我们不可以修改指针变量里面所指向的内存里面的数据。**既是顶层const又是底层const：**指针本身是个常量，而且他所指的对象也是常量。\n```c++\nint main() {\n    int number1 = 233;\n    int number2 = 666;\n    \n    //指向常量的指针（pointer to const）\n    const int *pointer =  &number1;\n\t\tpointer = &number2;\t//可以修改指针变量保存的地址\n    *pointer = 666;\t//错误，不能修改指针变量里面所指向的内存里面的数据\n    \n    //常量指针（const pointer）\n    int *const pointer2 = &number1;\n    pointer2 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //可以修改指针变量里面所指向的内存里面的数据\n    \n    //指向常量的常量指针\n    const int *const pointer3 = &number1;\n    pointer3 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //错误，不可以修改指针变量里面所指向的内存里面的数据\n    \n}\n```\n执行拷贝时，常量是顶层const还是底层const区别明显。其中顶层const（常量指针）不受什么影响。但是底层const（指向常量的指针）的限制不容忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以赋值给常量，反之不行。"},{"title":"傅立叶变换在图像处理的应用","url":"/2020/05/09/傅立叶变换在图像处理的应用/","content":"**傅立叶**：任何连续的周期信号，可以由一组适当的正弦曲线组合而成。（Any univariate function can be rewritten as a weighted sum of sines and cosines of different frequencies.）\n\n---\n一个恰当的比喻是将傅立叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅立叶变换可以看作数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑时，讨论他的光谱或频率谱。同样，傅立叶变换使我们能通过频率成分来分析一个函数。\n\n---\n\n<iframe height=300 width=300 src=\"https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif\"></iframe>\n\n---\n\n## 用一个例子解释一维傅立叶变换\n\n我们一般描述一个函数都是基于时间域，如图所示表示了这个函数随时间变化的变化（x轴是时间的变化，y轴是（信号）强度的变化）。\t\n![timedomain](timedomain.JPG)\n但是其实还有一种方法也可以描述这个函数，就是频率域。就比如上图中的函数可以写成\nf(x) = 3sin(0.8x) + 7sin(0.3x) + 2sin(0.2x)\n的形式。就是相当于给了频率为0.8, 0.3和0.2的sin函数不同的权重并把它们加起来。所以也可以由下图来表示。\n![frequencedomain](frequencedomain1.JPG)\n![frequencedomain](frequencedomain2.JPG)\n虽然两张图看起来截然不同，但是他们表述的是同种东西，而傅立叶变换就是描述这种从时域到频率域的变换。\n当然也要考虑相位的变化。\n![phase](phase.JPG)\n\n---\n\n## 傅立叶变换在二维图像处理中的应用\n\n![DFT](dft.png)\n傅立叶变换在二维图像处理中想法与之前一维类似，图像处理中的傅立叶变换是基于二维矩阵，如图所示，x轴和y轴共同表示图像中的位置，z轴表示每个位置（像素点）的灰度值。\n![imagedomain](imagedomain.JPG)\n\n和之前的一维函数相比较可以得出对应关系：\n\n|一维函数|二维图像|\n|---|---|\n|时间|距离|\n|信号强度|灰度值|\n\n---\n\n\n### 傅立叶变换的特点\n\n图像DFT(离散傅立叶变换)的基本属性是其周期性和复共轭对称性。频谱以周期N在两个方向上无止境地重复，即F（u，v）= F（u + kN，v + lN）其中k，l∈[-∞，...，-1，0，1， 2，...，∞]。从具有2D DFT的N×N图像计算出的傅立叶系数F（u，v）的N×N块是此无限序列的单个周期\n![equation](equation.png)\n注意看这里对于频率域的每个点（u，v）都需要时间域所有点的相关信息。\n\n### 二维图像中傅立叶变换的原理\n二维的sin波动可以用如下公式表述：\n*z = a sin(ux+vy)*\nz是波的高度（强度）。\na是幅值，表示波的最高高度。\nu是波浪在x方向上重复的次数（x方向上的频率）。\nv是波浪在y方向上重复的次数（y方向上的频率）。\n如图所示，当v=0的时候，sin的波只在x轴方向波动，当u=0的时候，sin的波只在y轴方向波动，如果u和v都不为0，那么就会在xy叠加方向以角度u/v波动（比如对角线方向）。\n![waves](waves.png)\n如下图，把每个像素点上述的波叠加起来，然后这些波会相互抵消，相互叠加。\n![waves_overlay](waves2.png)\nu是波浪在x方向上重复的次数（x方向上的频率），它可以是1，2，3... \t1表示单位距离内在x方向上重复1次，2表示单位距离内在x方向上重复2次...\n比如，f（2，2）这个像素，它的灰度值在x方向上以sin波波动了3次，在y方向上以sin波波动了4次，那么它在频率域对于点F（3，4）就有一点贡献。F（u，v）的值就是这张图内所有像素点贡献值之和，就是在那个x方向u频率和y方向的v频率的sin波动的强度大小的矢量和。F(3，4)那点的亮度就是表示了整张图的所有像素点在x方向上以频率3灰度的波动和在y方向上以频率4灰度的波动之和的强度（能量大小）。在频率域上的中心点（0，0）表示在x和y方向上都没有波动，它的值是所有灰度值和的平均值。所以在频率域中，中间是低频率，外部是高频率。\n\n### 二维图像傅立叶变换在opencv中的实现\n```\nimport cv2 as cv\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimg = cv.imread('messi5.jpg',0) # 读入图片\nf = np.fft.fft2(img) # 用np自带功能把图片进行傅立叶变换\nfshift = np.fft.fftshift(f) # 调换象限，中心化处理\nmagnitude_spectrum = 20*np.log(np.abs(fshift)) #因为进行变换之后是复数，所以要取绝对值，用log函数是为了能把变换后的图像显示的更加清楚。\nplt.subplot(121),plt.imshow(img, cmap = 'gray') #subplot第一个数字是行数，第二个列数，第三个是index\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()\n```"},{"title":"二分法","url":"/2020/05/06/二分法/","content":"\n首先二分法只适用于已经排序过的数组。\n二分法的思想就是通过每次排除一半的数列，在剩余一半的数组中查找目标值并返回其所在的位置。相比于直接查找二分法的效率更高，其时间复杂度是O(log2n)。\n\n---\n\n### python代码实现：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return \"Target is not in the list.\"\n```\n\n### 用例子解释为什么循环执行的条件是left<=right：\n[3，8，15，21，35，54，63，79，82，92，97] #目标数列\n0     1      2     3      4      5       6     7      8       9     10 #目标数列的序号\n\n**第一轮**：\nleft_index = 0,  right_index = 10,  mid_index = (0+10)/2 = 5, taget = 87\n\n**第二轮**：\nleft_index = 0 < right_index = 10\nmid = 54<87\n所以left_index = mid_index+1 = 5+1 = 6\nmid_index = (6+10)/2 = 8所以mid对应的值是82\n\n**第三轮**\nleft_index = 6 < right_index = 10\nmid = 82<87\n所以left_index = mid_index+1= 8+1 = 9\nmid_index = (9+10)/2 = 9所以mid对应的值是92\n\n**第四轮**\nleft_index = 9 < right_index = 10\nmid = 92>87(Target value)\n所以right_index = mid_index-1 = 9-1 = 8\n\n**第五轮**\nleft_index = 9 **>** right_index = 8\n不满足while循环跳出\n\n---\n\n## 题目\n### leetcode 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n---\n\n这道题目可以用二分法查找元素，但是多出了如果被查找元素不在给定数列内，要把它插在合适的位置的要求。\npython解法的代码：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return left\n```\n只需要把最后的return \"Not in the list\"改成return left就行。\n**为什么最后改成return left就行**：\n从之前举的例子可以看出，在执行到第五轮的时候，将会跳出循环，此时，left和right的值都是要比查找值target大，所以才会跳出循环导致无法查找，所以这意味着此时只要返回left的index就可以了，就相当于把此时的left向后移动一位插入这个需要被查找的元素。\n\n### leetcode 69. x 的平方根\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n\n---\npython解法的代码\n```\ndef mySqrt(x):                              \n    left = 0                                \n    right = x                               \n    while left <= right:                    \n        mid = (left + right) // 2           \n        if mid ** 2 <= x < (mid + 1) ** 2:  \n            return mid                      \n        if mid ** 2 > x:                    \n            right = mid - 1                 \n        if (mid + 1) ** 2 <= x:             \n            left = mid + 1                         \n```\n思路和之前很相似，确定什么时候可以返回刚好是根号数，就是在这个数的平方小于或等于x的时候以及这个数加一的平方大于x的时候，有了这个限制条件就可以写代码了。因为另外两种情况下就正好在mid的左半边和mid的右半边进行寻找。"},{"title":"相机标定(Camera Calibration)","url":"/2020/05/03/相机标定-Camera-Calibration/","content":"## 相机模型\n首先我们知道物体本身是不发光的，我们所看到的有颜色的物体都是都是物体反射太阳或其他光源基于大脑的色觉系统所产生的。而相机就是基于人类的色觉系统所制造成的。比如下图的我们眼中的绿巨人浩克，多条不同方向的光线在他身上反射后会被右侧相机的光学传感器所接收。\n![Hulk](Hulk.png)\n\n如果不对这些光线做处理，绿巨人身上的每一点都会作用于光学传感器上的每一个像素，产生如下图的效果。\n![green](green.png)\n\n很显然，这并不是我们想要的结果，所以人们就想到如果能把多余的反射光线遮住，使得实物上的每一点和相机上的每一个像素相对应，由此就得出来最简单的单孔相机（pinhole）模型，如下图所示。\n\n![pinhole](pinhole.png)\n\n得到了简单的单孔模型之后，我们又引出了焦距（focus length）的概念，根据相似的定义可以知道焦距越小所得到图像也越小，而且是和实物上下颠倒。\n\n![focus length](focuslength.png)\n\n因为单孔模型会遮掉很多多余的反射光线，使得光线的利用率不高，所以为了提高光线的利用率我们想到可以把带小孔的遮光板换成透镜，这样既可以提高光线的利用率，又可以满足我们之前的要求。\n\n![lens](lens.png)\n\n---\n\n## 相机矩阵\n"}]
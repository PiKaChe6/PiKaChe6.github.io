[{"title":"傅立叶变换在图像处理的应用","url":"/2020/05/09/傅立叶变换在图像处理的应用/","content":"**傅立叶**：任何连续的周期信号，可以由一组适当的正弦曲线组合而成。（Any univariate function can be rewritten as a weighted sum of sines and cosines of different frequencies.）\n\n---\n一个恰当的比喻是将傅立叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅立叶变换可以看作数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑时，讨论他的光谱或频率谱。同样，傅立叶变换使我们能通过频率成分来分析一个函数。\n\n---\n\n<iframe height=300 width=300 src=\"https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif\"></iframe>\n\n---\n\n## 用一个例子解释一维傅立叶变换\n\n我们一般描述一个函数都是基于时间域，如图所示表示了这个函数随时间变化的变化（x轴是时间的变化，y轴是（信号）强度的变化）。\t\n![timedomain](timedomain.JPG)\n但是其实还有一种方法也可以描述这个函数，就是频率域。就比如上图中的函数可以写成\nf(x) = 3sin(0.8x) + 7sin(0.3x) + 2sin(0.2x)\n的形式。就是相当于给了频率为0.8, 0.3和0.2的sin函数不同的权重并把它们加起来。所以也可以由下图来表示。\n![frequencedomain](frequencedomain1.JPG)\n![frequencedomain](frequencedomain2.JPG)\n虽然两张图看起来截然不同，但是他们表述的是同种东西，而傅立叶变换就是描述这种从时域到频率域的变换。\n当然也要考虑相位的变化。\n![phase](phase.JPG)\n\n---\n\n## 傅立叶变换在二维图像处理中的应用\n\n![DFT](dft.png)\n傅立叶变换在二维图像处理中想法与之前一维类似，图像处理中的傅立叶变换是基于二维矩阵，如图所示，x轴和y轴共同表示图像中的位置，z轴表示每个位置（像素点）的灰度值。\n![imagedomain](imagedomain.JPG)\n\n和之前的一维函数相比较可以得出对应关系：\n\n|一维函数|二维图像|\n|---|---|\n|时间|距离|\n|信号强度|灰度值|\n\n---\n\n\n### 傅立叶变换的特点\n\n图像DFT(离散傅立叶变换)的基本属性是其周期性和复共轭对称性。频谱以周期N在两个方向上无止境地重复，即F（u，v）= F（u + kN，v + lN）其中k，l∈[-∞，...，-1，0，1， 2，...，∞]。从具有2D DFT的N×N图像计算出的傅立叶系数F（u，v）的N×N块是此无限序列的单个周期\n![equation](equation.png)\n注意看这里对于频率域的每个点（u，v）都需要时间域的相关信息。\n### 二维图像中傅立叶变换的原理\n二维的sin波动可以用如下公式表述：\n*z = a sin(ux+vy)*\nz是波的高度（强度）。\na是幅值，表示波的最高高度。\nu是波浪在x方向上重复的次数（x方向上的频率）。\nv是波浪在y方向上重复的次数（y方向上的频率）。\n如图所示，当v=0的时候，sin的波只在x轴方向波动，当u=0的时候，sin的波只在y轴方向波动，如果u和v都不为0，那么就会在xy叠加方向以角度u/v波动（比如对角线方向）。\n![waves](waves.png)\n如下图，把每个像素点上述的波叠加起来，然后这些波会相互抵消，相互叠加。\n![waves_overlay](waves2.png)\nu是波浪在x方向上重复的次数（x方向上的频率），它可以是1，2，3... \t1表示单位距离内在x方向上重复1次，2表示单位距离内在x方向上重复2次...\n比如，f（2，2）这个像素，它的灰度值在x方向上以sin波波动了3次，在y方向上以sin波波动了4次，那么它在频率域对于点F（3，4）就有一点贡献。F（u，v）的值就是这张图内所有像素点贡献值之和，就是在那个x方向u频率和y方向的v频率的sin波动的强度大小的矢量和。F(3，4)那点的亮度就是表示了整张图的所有像素点在x方向上以频率3灰度的波动和在y方向上以频率4灰度的波动之和的强度（能量大小）。在频率域上的中心点（0，0）表示在x和y方向上都没有波动，它的值是所有灰度值和的平均值。"},{"title":"数据结构心得","url":"/2020/05/07/数据结构心得/","content":"之前和朋友聊天的时候发现一个问题，很多通信公司宣传的百兆光纤，最高能达到100Mb/s的下载速度。可是当我自己办了那个网之后发现下载资料文件根本达不到100Mb/s，最多能达到10兆每秒就很难得了。\n![vodafone](vodafone.png)\n最后在同学的提醒下发现，商家们宣传的100Mb/s中的单位是Mb/s其中的b是小写的b，是比特(bit)的缩写。而大家平时电脑里存放的文件的最小单位是字节(Byte)，文件大小可能是KB，MB或者是GB，这里的B是大写的B！单位换算如下：\n1Byte = 8 bit\n1KB = 2<sup>10</sup> Byte = 1024 Byte\n1MB = 2<sup>10</sup> KB = 1024 KB\n1GB = 2<sup>10</sup> MB = 1024 MB\n所以我们在计算下载速度的时候应该将100/8 = 12.5MB/s比较符合常理。\n\n计算机是以比特序列来存储数据的，每个比特非0即1，例如：\n大多计算机是以2的整数次幂个比特作为作为**块**来处理内存，可寻址的最小内存块称为“字节（Byte）”，储存的基本单元称为字（word），它通常由几个字节组成。\n大多数计算机将内存中的每个**字节**与一个数字（地址（address））关联起来\n![address](address.png)\n其中，左侧是字节的地址，右侧是字节中8比特的具体内容。我们能够使用某个地址来表示从这个地址开始的大小不同的比特串。\n以C++为例，float以一个字（32比特）来表示，double以两个字（64比特）来表示"},{"title":"二分法","url":"/2020/05/06/二分法/","content":"\n首先二分法只适用于已经排序过的数组。\n二分法的思想就是通过每次排除一半的数列，在剩余一半的数组中查找目标值并返回其所在的位置。相比于直接查找二分法的效率更高，其时间复杂度是O(log2n)。\n\n---\n\n### python代码实现：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return \"Target is not in the list.\"\n```\n\n### 用例子解释为什么循环执行的条件是left<=right：\n[3，8，15，21，35，54，63，79，82，92，97] #目标数列\n0     1      2     3      4      5       6     7      8       9     10 #目标数列的序号\n\n**第一轮**：\nleft_index = 0,  right_index = 10,  mid_index = (0+10)/2 = 5, taget = 87\n\n**第二轮**：\nleft_index = 0 < right_index = 10\nmid = 54<87\n所以left_index = mid_index+1 = 5+1 = 6\nmid_index = (6+10)/2 = 8所以mid对应的值是82\n\n**第三轮**\nleft_index = 6 < right_index = 10\nmid = 82<87\n所以left_index = mid_index+1= 8+1 = 9\nmid_index = (9+10)/2 = 9所以mid对应的值是92\n\n**第四轮**\nleft_index = 9 < right_index = 10\nmid = 92>87(Target value)\n所以right_index = mid_index-1 = 9-1 = 8\n\n**第五轮**\nleft_index = 9 **>** right_index = 8\n不满足while循环跳出\n\n---\n\n## 题目\n### leetcode 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n---\n\n这道题目可以用二分法查找元素，但是多出了如果被查找元素不在给定数列内，要把它插在合适的位置的要求。\npython解法的代码：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return left\n```\n只需要把最后的return \"Not in the list\"改成return left就行。\n**为什么最后改成return left就行**：\n从之前举的例子可以看出，在执行到第五轮的时候，将会跳出循环，此时，left和right的值都是要比查找值target大，所以才会跳出循环导致无法查找，所以这意味着此时只要返回left的index就可以了，就相当于把此时的left向后移动一位插入这个需要被查找的元素。\n\n### leetcode 69. x 的平方根\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n\n---\npython解法的代码\n```\ndef mySqrt(x):                              \n    left = 0                                \n    right = x                               \n    while left <= right:                    \n        mid = (left + right) // 2           \n        if mid ** 2 <= x < (mid + 1) ** 2:  \n            return mid                      \n        if mid ** 2 > x:                    \n            right = mid - 1                 \n        if (mid + 1) ** 2 <= x:             \n            left = mid + 1                         \n```\n思路和之前很相似，确定什么时候可以返回刚好是根号数，就是在这个数的平方小于或等于x的时候以及这个数加一的平方大于x的时候，有了这个限制条件就可以写代码了。因为另外两种情况下就正好在mid的左半边和mid的右半边进行寻找。"},{"title":"相机标定(Camera Calibration)","url":"/2020/05/03/相机标定-Camera-Calibration/","content":"## 相机模型\n首先我们知道物体本身是不发光的，我们所看到的有颜色的物体都是都是物体反射太阳或其他光源基于大脑的色觉系统所产生的。而相机就是基于人类的色觉系统所制造成的。比如下图的我们眼中的绿巨人浩克，多条不同方向的光线在他身上反射后会被右侧相机的光学传感器所接收。\n![Hulk](Hulk.png)\n\n如果不对这些光线做处理，绿巨人身上的每一点都会作用于光学传感器上的每一个像素，产生如下图的效果。\n![green](green.png)\n\n很显然，这并不是我们想要的结果，所以人们就想到如果能把多余的反射光线遮住，使得实物上的每一点和相机上的每一个像素相对应，由此就得出来最简单的单孔相机（pinhole）模型，如下图所示。\n\n![pinhole](pinhole.png)\n\n得到了简单的单孔模型之后，我们又引出了焦距（focus length）的概念，根据相似的定义可以知道焦距越小所得到图像也越小，而且是和实物上下颠倒。\n\n![focus length](focuslength.png)\n\n因为单孔模型会遮掉很多多余的反射光线，使得光线的利用率不高，所以为了提高光线的利用率我们想到可以把带小孔的遮光板换成透镜，这样既可以提高光线的利用率，又可以满足我们之前的要求。\n\n![lens](lens.png)\n\n---\n\n## 相机矩阵\n"}]
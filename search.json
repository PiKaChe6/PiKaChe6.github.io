[{"title":"C++Primer第四章笔记","url":"/2020/06/30/C-Primer第四章笔记/","content":"\n# 第四章表达式\n\n## 基础\n\n### 基本概念\n\n+ 一元运算符：作用于一个运算对象，如取地址符（&）和解引用符（\\*）\n+ 二元运算符：作用于两个运算对象，如相等（==）和乘法（\\*）\n+ 三元运算符\n\n#### 重载运算符（override）\n\n定义了运算符作用于内置类型和复合类型的运算时所执行的操作。**自定义运算符的过程事实上是为已存在的运算符赋予了另外一层含义**。IO库的>>和<<运算符以及string对象，vector对象和迭代器使用的运算符都是重载运算符。\n#### 左值和右值\n当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）\n### 优先级与结合律\n复合表达式是指含有两个或多个运算符的表达式。\n一个式子，如果没有括号，那么计算顺序和正常计算顺序一致，乘除优先于加减。加上括号就括号优先。\n```c++\nint ia[] = {0,2,4,6,8}; \nint last = *{ia + 4}; //ia是指向数组的首元素的指针，ia+4是指向指向第4个元素的指针，再解引用得到ia[4]得到8\nlast = *ia + 4;\t//先解引用得到首元素的值为0，再加4得到的值为4\n```\n### 求值顺序\n对于那些没有指定执行顺序的运算来说，如果表达式指向并修改了同一个对象，将会引发错误并产生为定义的行为。\n```c++\nint i = 0;\ncout<< i<< \" \"<<++i<<endl;\n```\n编译器可能先求++i的值再求i的值，此时输出结果为1 1；也可控先求i的值再求++i的值，输出结果是0 1。\n有4种运算符明确规定了运算对象的求职顺序。\n+ && 逻辑与运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。\n+ || 逻辑或运算符\n+ （？：）条件运算符\n+ ， 逗号运算符\n\n#### 求值顺序、优先级、结合律\n+ 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求\n+ 如果改变了某个运算对象的值，在表达式的其他地方不要在使用这个运算对象。（\\*++iter除外）\n\n---\n\n## 算数运算符\n一元正号运算符（+ expr）、加法运算符和减法运算符都能作用与指针。\n一元正号运算符作用与一个指针或者算数值时，返回运算对象值的一个（提升后的）副本：\n\n```c++\nint i = 1024;\nint k = -i; //k是-1024\nbool b = true;\nbool b2 = -b; //b2是true\n```\n布尔变量b的值为真，参与运算时将被提升整数值1，对它求负后的结果是-1.将-1再转换回布尔值并将其作为b2的初始值，显然这个初始值不等于0，转换成布尔值后为1。所以b2的值是真！\n\n整数相处的接果还是整数，也就是说，如果商含有小数部分，直接弃除\n```c++\nint ivall = 21/6 //ivall是3，结果进行删节，余数被抛弃掉了\nint ivall = 21/7 //ival是3，没有余数，结果是整数值\n```\n\n+ -m/n和m/（-n）都等于-（m/n）\n+ m%(-n)等于m%n\t  (-m)%n等于-(m%n)\n-21 % -8  结果是 -5\n21 % -5 结果是 1\n\n---\n\n## 逻辑和关系运算符\n关系运算符作用于算数类型或者指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示为真。\n\n短路求值：\n\n+ 对于逻辑与（&&）运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。\n```C++\nindex != s.size() && !isspace(s[index])\n```\n首先会检查index是否达到了string对象的末尾，以此确保只有当index在合理范围内时才会计算右侧运算对象的值。\n+ 对于逻辑或（||）运算符来说，当且仅当左侧的运算对象为假时才对右侧运算对象求值。\n假定有一个储存着若干个string对象的vector对象，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。使用基于范围for循环处理string对象中的每个元素。\n```c++\nint main()\n{   \n    vector<string> text = {\"hello\", \"world\", \"Nihao\", \"dawdaw.\",\"Loamo\",\"zz\",\"\\0\",\"houge\",\"ll\"};\n    for(const auto &s: text){\n        cout<<s;\n        if (s.empty()||s[s.size()-1]=='.'){\n            cout<<endl;\n        }\n    }\n\n}\n```\n只有当非string对象非空时才需要求第二个运算对象的值，也就是检查string对象是否以句号结尾。s被声明了对常量的引用。因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝。又因为不需要string对象进行写操作，所以s被声明成对常量的引用。\n\n### 关系运算符\n`if(i<j<k)`不正确，因为会先计算i<k的结果，结果是true或者是false，然后再把true和false与k做比较，会产生问题。`if (i<j && j<k)`当i小于j并且j小于k时条件为真\n### 相等性测试与字面布尔值\n\n如果想测试一个算数对象或指针对象的真值，最直接的方法就是将其作为if语句的条件：\n\n+ 对象\n\n```c++\nint val = 2;\nif（val）{}\t//如果val是任意的非0值 1,100,-2只要是非0都可以，条件为真\nif(!val){}\t//如果val是0，条件为真\nif（val == true）{} //只有当val等于1时条件才为真\n```\n当布尔值转化成其他算数类型时，false转化成0而true转化成1。\n**进行比较运算时除非比较的对象是布尔类型，否则不要用布尔字面值true和false作为运算对象**\n\n+ 指针\n```c++\nconst char *cp = \"Hello World\";\nif (cp && *cp)\n```\n首先if判断cp指针是否为空指针或者无效指针。\n如果cp是空指针或无效指针之间返回false。\n如果cp不是空指针和无效指针，检查\\*cp是否为空字符，如果是空字符则返回false，如果不是则返回true。\n这里cp指向const的“Hello world”string对象，不为空且有效，\\*cp是cp指针的解引用，cp指向string的第一个字符的首地址，不是空字符所以返回true。\n\n## 赋值运算符\n\n+ 赋值运算符的左侧运算对象必须是一个可以修改的左值。\n+ 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧的元素运算对象的类型。\n+ 无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧的运算对象。\n```c++\nint i = 0, j = 0, k = 0; //初始化而非赋值\nconst int ci = i; //初始化而非赋值\nk = 3.1415926； //结果：类型是int，值是3\n```\n### 赋值运算满足右结合律\n```c++\nint ival, jval;\nival = javl = 0;\nstring s1, s2;\ns1 = s2 = \"OK\";\nint ival, *pval;\nival = pval = 0; //错误：pval的类型是指向整型的指针，ival的类型是整型，指针类型无法转换成为整型\n```\n对于多重赋值语句中的每一个对象，它的类型或者右边对象类型相同、或者可由右边类型转换得到。\n### 赋值运算优先级较低\n因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的意愿。\n```c++\nint i;\nwhile((i = get_value())!=42){\n\t\n}\n```\n不断循环读取数据直到遇到42为止。\n其处理过程是首先将get_value函数的返回值赋给i，然后比较i和42是否相等。\n\n---\n\n## 递增和递减运算符\n+ 前置版：`j = ++i`运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果 \n+ 后置版：`j = i++`也会将运算对象加1（或减1），但是求值结果是运算对象改变之前的那个值的副本\n```c++\nint i = 0, j;\nj = ++i; // j = 1, i = 1: 前置版本得到递增之前的值\n---\nint i = 0, j;\nj = i++; //j = 0， i=1: 后置版本得到递增之前的值\n```\n**除非必须，否则不用递增递减运算符的后置版本**\n因为后置版本会储存赋值之前的值，占用空间，造成不必要的浪费\n\n### 在一条语句中混用解引用和递增运算符\n如果我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。\n可以使用后置的递增运算符来控制循环输出的一个vector对象内容直至遇到（但不包括）第一个负值为止。\n```c++\nauto pbeg = v.begin();\nwhile(pbeg != v.end() && *beg>= 0){\n\tcout<< *pbeg++<<endl;\n}\n```\n**后置递增运算符的优先级高于解引用运算符**，因此\\*pbeg++等价于\\*(pbeg++)。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果（还没有加1的状态），此时解引用运算符的运算对象是pbeg未增加之前的值。最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。\n\n## 成员访问运算符\n\n+ 点运算符(\\*ptr).mem\n+ 箭头运算符ptr->mem\n```c++\nstring s1 = \"a string\", *p = &s1;\nauto n = s1.size();\nn = (*p).size(); //运行p所指对象的size成员\nn = p->size();\t//等价于(*p).size()\n```\n箭头运算符作用于一个指针类型的运算对象，结果是一个左值。\n点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果所属的对象是右值，那么结果是右值。\n\n## 条件运算符\n条件运算符（？：）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：\ncond？expr1:expr2；\n先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。\n```c++\nstring finalgrade = (grade < 60) ? \"fail\":\"pass\";\n```\n### 嵌套条件运算符\n允许在条件运算符的内部嵌套另一个条件运算。也就是说，条件表达式可以作为另外一个条件运算符的cond或expr。使用一对嵌套的条件运算符可以将成绩分成三档：优秀（high pass）、合格（pass）和不合格（fail）：\n```c++\nfinalgrade = (grade > 90)?\"high pass\":(gerade<60)?\"fail\":\"pass\";\n```\n### 在输出表达式中使用条件运算符\n条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式，通常需要在它的两端加上括号。例如，有时需要根据条件值输出两个对象中的一个：\n```c++\ncout<<((grade<60)?\"fail\":\"pass\");\n```\n## 位运算符\n位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能，一种名为bitset的标准库类型也可以表示任意大小的二进制位集合，所以位运算同样能用于bitset类型。使用位运算符的好处是运算速度非常快。\n| 运算符 | 功能   | 用法           | 解释                                   |\n| ------ | ------ | -------------- | -------------------------------------- |\n| ~      | 位求反 | ~ expr         | 操作数为1，结果为0；操作数为0，结果为1 |\n| <<     | 左移   | expr1 << expr2 | 把左边的数转化成二进制向左移动右边位   |\n| >>     | 右移   | expr1 >> expr2 | 把左边边的数转化成二进制向右移动右边位 |\n| &      | 位与   | expr & expr    | 两个操作数同时为1结果为1               |\n| ^      | 位异或 | expr ^ expr    | 两个操作数相同，结果为0；不相同结果为1 |\n| \\|     | 位或   | expr \\| expr   | 两个操作数之要有一个为1，结果就为1     |\n### 举例\n\n#### 位与\n十进制\t\t4\t\t&\t\t 5\n二进制\t\t100\t&\t\t101\n每个位置上与关系：1和1是1，0和0是0，0和1是1，结果100 转化成十进制还是4\n#### 位非\n~2\n二进制： 10\n取反：      01-----> 十进制： 1； **错误**\n因为假设是char是占8位\n二进制： 00000010\n取反： \t11111101 （第一位是1---->负数）\n负数二进制转十进制：\n将负数二进制取反，然后+1，结果为负\n11111101 ----> 00000010 +1 = 00000011 转十进制 3 再加负号 -3\n\n#### 左移\n<< 和 cout<<样子相同 但是含义完全不同，cout<<是重载运算符\n2 << 3\n先转化为二进制 10 ----> 左移三位 10 000 ----> 转化为10进制 2^4 =16 \n\n\n**关于符号位如何处理没有明确规定，所以强烈建议仅将位运算符用于处理无符号类型。**\n\n### 移位运算符\n\\>>和<<运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生为定义的行为。二进制位或者向左移（<<）或者向右移（>>），移出边界之外就被舍弃掉了。\n\n### 移位运算符（又叫IO运算符）满足左结合律\n```c++\ncout<<\"hi\"<<\"there\"<<endl;\n((cout<<\"hi\")<<\"there\")<<endl; //等效于\n```\n移位运算符的优先级不高不低，介于中间：比算数运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高\n```c++\ncout << 42 + 10 //正确：+的优先级更高，因此输出求和结果\ncout << (10 < 42) //正确：括号使运算按照我们的期望组合在一起，输出1\ncout << 10 < 42 //错误：试图比较cout和42\n```\n\n\n## sizeof运算符\nsizeof运算符返回一条表达式或一个类型名字所占的字节数 (1个字节占8比特)。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：\n+ sizeof (type)\n+ sizeof expr\n在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：\n```c++\nSales_data data, *p;\nsizeof(double); //结果是8 占8个字节\nsizeof(\"abcd\"); //结果是5 占5个字节，因为string结尾默认有\\0站一个字节\nsizeof(Sales_data); //存储Sale_data类型的对象所占的空间大小\nsizeof data; //data的类型的大小，即sizeof(Sales_data)\nsizeof p; //指针所占的空间大小\nsizeof *p  //p所指类型的空间大小，即sizeof(Sales_data)\nsizeof data.revenue; //Sales_data的revenue成员对应的类型的大小\nsizeof Sale_data::revenue; //另一种获取revenue大小的方式\n```\nC++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无需我们提供一个具体的对象，因为想要知道类成员的大小无需真的获取该成员。\nsizeof运算符的结果部分地依赖于其作用的类型：\n+ 对char或者类型位char的表达式执行sizeof运算，结果为1。\n+ 对引用类型执行sizeof运算得到被引用对象所占空间的大小。\n+ 对指针执行sizeof运算得到指针本身所占空间的大小。\n+ 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效\n+ 对数组执行sizeof运算得到整个数组所占空间大小，等价于对数组中的所有元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理\n+ 对string对象或vector对象（sizeof(string)）执行sizeof运算值返回该类型固定部分的大小，不会返回对像中的元素占用了多少空间。如果想要知道元素占用了多少可以直接(sizeof(\"abcd\"))\n\n### 通过sizeof确定数组中的元素个数\n因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素的个数\n```c++\nconstexpr size_t sz = sizeof(ia)/sizeof(*ia);\nint arr2[sz]; \n```\n因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。\n### 例子\n```c++\n \t\tint x[10]; \n    int *p = x;\n    cout<< sizeof(x)/sizeof(*x) <<endl; // 40/4 = 10\n    cout<< sizeof(p)/sizeof(*p) <<endl;\t// 8/4 = 2\n```\n+ sizeof(x), x是一个有10个元素的数组，所以它的sizeof是所有的10个int元素之和。10\\*4 = 40\n+ sizeof(\\*x) 返回x所指类型的空间大小，即sizeof(int)\n+ sizeof(p) 返回指针所占的空间大小\n+ size(\\*p) 返回p所指对象类型所占空间大小，即sizeof(int)\n\n## 逗号运算符\n逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了对象求值的顺序。\n对于逗号运算符来说，首先对左侧的表达式求值，然后将求值的结果丢弃掉，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。\n逗号运算符经常被用在for循环当中：\n\n```c++\nvector<int>::size_type cnt = ivec.size(); // 将把从size到1的值赋给ivec的元素\nfor(vector<int>::size_type ix = 0; iX != ivec.size(); ++ix, --cnt){\n\tivec[ix] = cnt;\n\t}\n```\n这个循环在for语句的表达式中递增ix、递减cnt，每次迭代循环ix和cnt相应改变。只要ix满足条件，我们就把当前元素设成cnt的当前值。在for循环中前置和后置效果一样，因为for循环中的是；这是因为递增递减运算符与真正使用这两个变量的语句位于不同的表达式中，所以不会有什么影响。\n\n### 解释语句的含义\n```c++\nsomeValue? ++x, ++y:--x,--y\n```\n因为条件运算符的优先级大于逗号运算符，所以someValue? ++x, ++y:--x,--y 实际上是\n(someValue ? ++x, ++y : --x ), --y;\n+ 如果someValue为true：先执行++x，++y最后再执行--y\n+ 如果someValue为false：先执行--x，最后执行--y\n\n## 类型转换\n如果两种类型可以相互转换，那么它们就是关联的。\n```c++\nint ival = 3.541 + 3;\n```\n加法的两个运算对象类型不同：3.541是double，3的类型是int。c++语言不会将两个不同类型的值相加，而是先根据类型转化规则设法将运算对象的类型统一后再求值。上述的类型转换是自动执行的，无需程序员的介入，因此它们被称为**隐式转换**。\n\n### 算数转化\n#### 算数转换\n算数转换的规则定义了一套类型转化的层次，其中运算符的元素安对象将转换成最宽的类型。例如，如果一个运算对象的类型是long double（最宽的类型，范围最大的类型），那么不论另外一个运算对象的类型是什么都会转化成long double。还有一种更普遍的情况，当表达式中既有浮点类型也有整数类型时，整数值降转化成相应的浮点类型。\n##### 整型提升\n整型提升负责把小整数类型转化成较大的整数类型。对于bool、char、signed char、unsigned char、short和 unsigned short等类型来说，只要它们所有可能的值都存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。\n##### 无符号类型的运算对象\n如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中的各个整数类型的相对大小了。\n+ 和往常一样，首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。\n+ 如两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。\n+ 如果一个运算对象是无符号类型，另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么将带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转化成unsigned int类型。需要注意的是，如果int类型的值恰好为负，则会有副作用。（**带符号---->无符号**）\n+ 带符号类型大于无符号类型，此时运算结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号的运算对象转换成带符号类型。如果不能，那么带符号类型转换成无符号类型。\n##### 例子\n```c++\nbool flag;\nshort sval;\nint ival;\nlong lval;\nfloat fval;\nchar cval;\nunsigned short usval;\nunsigned int uival;\nunsigned long ulval;\ndouble dval;\n\n3.1415926L + 'a'; //'a'提升成int，然后该int值转化成long double\ndval + ival; //ival转化成double\ndval + fval; //fval转化成double\nival = dval; //dval转化成（切除小数部分后）int\nflag = dval; //如果dval是0，则flag是false，否则flag是true\ncval + fval; //cval(char)提升成int，然后该int值转化成float\nsval + cval; //sval（short）和cval（char）都转化float\ncval + lval； //cval转化成long\nival + ulval; //ival转化成unsigned long\nusval + ival; //根据unsigned short和int所占空间大小进行提升\nuival + lval; //根据unsigned int和long所占空间的大小进行转换\n```\n#### 其他隐式类型转化\n##### 数组转化成指针\n在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。\n```c++\nint ia[10]; //含有10个整数的数组\nint* ip = ia; //ia转化成指向数组首元素的指针\n```\n**当数组被用作decltype关键字的参数，或者作为取地址（&）、sizeof以及typeid等运算对象时，上述转换也不会发生。**\n##### 指针的转换\n+ 常量数值0或者字面值nullptr能转换成任意指针类型\n+ 指向任意非常量的指针能转化成void\\*\n+ 指向任意对象的指针能转化成const void\\*\n##### 转化成布尔类型\n存在一种从**算数类型**或**指针类型**向布尔类型自动转化的机制。如果指针或算数类型的值为0，转换结果是false，否则转换的结果是true。\n```c++\nchar *cp = get_string();\nif (cp) //如果指针cp不是0，条件为真\nwhile (*cp) //如果*cp不是空字符，条件为真\n```\n##### 转换成常量\n允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用。\n```c++\nint i;\nconst int &j = i;  //非常量转换成const int的引用\nconst int *p = &i; //非常量的地址转换成const的地址\nint &r = j, *q = p; //错误： 不允许const转化成非常量： j本来是const引用，需要先转换成非常量才能赋值给非常量int\n```\n##### 类类型定义的转换\n类类型能定义由编译器自动执行转换，不过编译器每次只能执行一种类类型的转换。\n```c++\nwhile(cin>>s) //while的条件部分把cin转换成布尔值\n```\n条件部分本来需要一个布尔类型的值，但是这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值转换的规则，根据这一规则，cin自动转换成布尔值。\n#### 显示转换\n```c++\nint i, j;\ndouble slope = i/j;\n```\n如果想在上面的代码中执行浮点数除法，就要使用某种方法将i和/或j显示的转化成double，这种方法称作强制类型转换（cast）。\n##### 命名的强制类型转化\ncast-name<type>(expression)\n其中，type是转换的目标类型而expression是需要转换的值。如果type是引用类型，则结果是左值。cast-name是\n+ static_cast\n+ dynamic_cast\n+ const_cast\n+ reinterpret_cast(重新解释)\n\n###### static_cast\n任何具有明确定义的类型转换，**只要不包含底层const**，都可以使用static_cast。例如，通过一个运算对象强制转换成double类型就能使表达式执行浮点数除法：\n```c++\ndouble slope = static_cast<double>(j) / i;\n```\nstatic_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：\n```c++\nvoid* p = &d; //正确：任何非常量对象的地址都能存入void*\ndouble *dp = static_cast<double>(p); // 正确：将void*转换回初始的指针类型\n```\n当我们把指针存放在void*中，并且使用了static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，**因此我们必须确保转换后所得的类型就是指针所指的类型**。类型一旦不符，将产生未定义的后果。\n\n---\n\n**底层const，常量指针（const pointer）**：针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。\n\n---\n###### const_cast（去掉const性质）\nconst_cast只能改变运算对象的底层const：\n```c++\nconst char *pc;\nchar *p = const_cast<char>(pc);\n```\n对于将常量对象转换成非常量对象的行为，我们一般称其为 “去掉const性质”。\n只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能使用const_cast改变表达式类型：\n```c++\nconst char *cp;\nchar *q = static_cast<char*>(cp) //错误：static_cast不能去掉const性质\nstatic_cast<string>(cp); //正确：字符串字面值转换成string类型\nconst_cast<string>(cp); //错误：const_cast只能改变常量属性\n```\n###### reinterpreter_cast\nreinterpreter_cast通常为运算对象的位模式提供较低层次上的重新解释。\n```c++\nint *ip;\nchar *pc = reinterpreter_cast<char*>(ip);\n```\npc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，要尽量避免使用reinterpreter_cast。","tags":["C++"]},{"title":"C++Primer第三章笔记","url":"/2020/06/18/C-Primer第三章笔记/","content":"\n#### 第三章（字符串，向量和数组）\n### 命名空间using的声明\n\n作用域操作符（::）的含义是：编译器应从操作符左侧所示的作用域中寻找右侧那个名字。比如std::cin就是要使用std中的名字cin。\n**每个名字都要有独立的using声明。**\n```c++\n#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl; //之后使用cin，cout和endl就可以直接用了\n...\n```\n**头文件不应该包含using声明**\n因为头文件会被引用到主文件中，对于某些程序来说由于不经意间包含了一次名字，反而可能产生始料未及的名字冲突。\n\n其实也可以使用`using namespace std；`可以一次性包含整个std命名空间。但是不太推荐，因为可能我们自己也不清楚整个命名空间都有哪些关键字，冒然`using`进来，增加了命名冲突的可能性。\n\n#### 自定义namesapce\nnamespace的主要功能是避免命名冲突，因为很多大型软件开发都是很多个程序员合作完成的，不同程序员可能会用相同的名字定义相同的函数，但是当最终把这些函数合并在一起之后编译运行的过程就会产生冲突，因为不知道该运行哪个函数。\n比如两个函数：\n```c++\nvoid func1(){\n cout<<\"Hello World\"<<endl;\n}\nvoid func1(){\n cout<<\"Yuxiang Guo\"<<endl;\n}\nint main(){\nfunc1(); //会产生冲突\n}\n```\n\n---\n```c++\nnamespace programm1{\n int func1(){\n cout<<\"Hello World\"<<endl;\n }\n}\nnamespace programm2{\nint func1(){\n\tcout<<\"Yuxiang Guo\"<<endl;\n}\n}\nint main(){\nprogramm1::func1(); //使用就不会产生冲突了\n}\n```\n---\n\n### 标准库类型string\nstring表示可变长的字符序列，使用string类型必须首先包含string头文件。\nstring is an array of character\n#include<string>\nusing std::string;\n\n#### 定义和初始化string对象\n```c++\nstring s1; //默认初始化，s1是一个空字符串\nstring s2 = s1；//s2是s1的副本\nstring s3 = \"hiya\"; //s3是该字符串字面值的副本\nstring s4(10, 'c'); //s4的内容是cccccccccc\n```\n#### string对象上的操作\n| 操作| 解释|\n|---|---|\n| os<<s| 将s写到输出流os中，返回os|\n| is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is|\n| getline(is, s)| 从is读取一行赋给s，返回is|\n| s.empty()| s为空返回true，否则返回false|\n| s.size()| 返回s中字符的个数|\n| s[n]| 返回s中的第n个字符的引用，位置n从0计起|\n| s1+s2| 返回s1和s2连接后的结果|\n| s1=s2| 用s2的副本代替s1中原来的字符|\n| s1==s2| 如果s1和s2中所含的字符完全一样，则他们相等|\n| s1!=s2| string对象的相等性判断对字母大小写敏感|\n| <, <=, >, >=| 利用字符在字典中的顺序进行比较，且对大小写敏感|\n\n#### 读写string\n\nstring对象会自动忽略开头空白并从第一个真正字符开始读起，直到遇到下一处空白位置。\n比如输入是`\"   Hello\tWorld   \"`读入的就是`Hello`。\n\n#### 使用getline读取一整行\n如果想要保留空格（空白符）读取，就要用getline()，getline只要一遇到换行符就结束读取操作并返回结果。\n`getline(cin, s)`读取输入的一整行直到换行符位置并把它赋值给s。触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象并不包含换行符。\n\n#### 空格和空字符串区别\n从字符串的长度:——>空字符的长度为0,空格符的长度为1\n```c++\n    char a[] = \"\\0\"; //空字符串\n    char b[] = \" \"; //空格\n    cout << strlen(a) << endl;   //0\n    cout << strlen(b) << endl;   //1\n```\n#### empty和size操作\n**连续回车两下代表输入一个空字符！！！**\n每次读入一整行，输出其中超过80个字符的行\n\n```c++\n#include<string>\nusing std::string;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nstring line;\nwhile(getline(cin, line)){\n\tif (line.size() > 80){\n\tcout<<line<<endl;\n\t}\n}\n```\n如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。\n#### string::size_type类型\n对于size函数来说，返回的是一个string::size_type的类型的值，这是一种新的类型。string::size_type函数返回的是一个无符号的整型数。**如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigend可能带来的问题。**\n#### 比较string对象\n+ 如果两个string对象长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短string对象小于较长string对象\n+ 如果两个string对象在某些对应的位置上不一样，则string对象的比较结果其实是string对象中第一对想异字符比较结果\n```c++\nstring str = \"Hello\";\nstring phrase = \"Hello World\";\nstring slang = \"Hiya\";\n```\nstr < pharse\nslang > str\nslang > pharse\n#### 字面值和string对象相加\n算术类型、引用和指针都属于字面值类型。某些类也是字面值类型，它们可能含有constexpr函数成员。自定义类Sales_item、IO库、string类型不属于字面值类型。\n当把string对象和**字符字面值**及**字符串字面值**混在一条语句中使用时，必须确保每个加法运算符（+）的两侧至少有一个是string\n\n```c++\nstring s1 = \"Hello\" + \", \" //错误，“hello”类型是const char[5], \", \"类型是const char[3]，加号左右两边至少要有一个string\nstring s2 = \"Hello\"\nstring s1 = s2 + \", \"\t//正确\nstring s3 = s2 + \", \" + \"world\" //正确 等价于（s2 + \", \"）+ \"world\"\nstring s4  = \"Hello\" + \", \" + s2 //错误 等价于（\"Hello\" + \", \"） + s2\n```\n+ string对象可以和字面值相加\n+ 两个字面值不能相加\n+ 多个相加时注意加法的左结合律\n#### string和char*的区别\n在C++中，char仍然是一个primitive type（原始类型），而string已经经过封装，成为了一个class（类）用到它时，我们需要 #include <string>，它是C++ Standard Library （C++标准库）的一部分。\nC++中使用char*定义字符串，同样不能改变字符串内的字符的内容，但却可以把另外一个字符串付给它，相当于指针指向了另一个字符。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tchar* pstr = \"hello world\";\n\tpstr = \"aa\";\n\tpstr[1] = \"a\";\t//报错\n\tcout<<pstr<<endl;\n}\n```\nC++中string的定义字符串，同样不能改变字符串内的字符，但却可以把另外一个字符串付给它\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring str1;\n\tstr1= \"hello world\";\n\tstr1=\"aa\";\n\tstr1[1]=\"a\";\n\tcout<<str1<<endl;\n}\n```\n#### 处理string对象中的字符\n##### 处理字符串某个字符的函数\n| 函数        | 解释                                               |\n| ----------- | -------------------------------------------------- |\n| isalnum(c)  | 当c是字母或数字为真                                |\n| isalpha(c)  | 当c是字母时为真                                    |\n| iscntrl(c)  | 当c是控制字符时为真                                |\n| isdigit(c)  | 当c是数字时为真                                    |\n| isgraph(c)  | 当c不是空格但可打印时为真                          |\n| islower(c)  | 当c是小写字母时为真                                |\n| isprint(c)  | 当c是可打印字符时为真                              |\n| ispunct(c)  | 当c是标点符号为真                                  |\n| isspace(c)  | 当c是空白（空格）时为真                            |\n| isupper(c)  | 当c是大写字母时为真                                |\n| isxdigit(c) | 当c是十六进制数时为真                              |\n| tolower(c)  | 如果c是大写字母，输出对应的小写字母：否则原样输出c |\n| toupper(c)  | 如果c是小写字母，输出对应的大写字母：否则原因输出c |\n\n前面提到string是可变长的字符序列\n有三种方式可以访问其中的字符\n+ 范围for语句\n+ 下标运算符\n+ 迭代器\n##### 范围for语句\n用范围for语句比用普通for循环语句更加代码更加简洁。\n```c++\nstring str = \"some string\";\nfor (auto c: str){\t//输出str中的每个字符，通过使用auto让编译器来决定变量c的类型，这里的c是char/\n\tcout<<c<<endl;\n}\n```\n##### 使用范围for语句改变字符串中的字符\n```c++\nstring str = \"Hello world\";\nfor(auto& i : str){\t注意，这里i必须是引用，这样才能改变str中的值。\n\ti = toupper(i);\n}\ncout<<str<<endl;\t//输出的是“HELLO WORLD”\n```\n#### 下标运算符（只处理一部分字符）\ns[0]是第一个字符，s[s.size()-1]是最后一个字符\n\n---\n\n### 标准库类型vector\n标准库类型vector表示对象集合，其中所有**对象的类型都相同。**集合中的每个对象都有一个与之对应的索引，索引用于访问对象。vector是一个**类模版**（类模版不是类），由vector生成的类型必须包含vector中元素的类型，例如vector<int>。模版就是一个类，但是比如类中的某个attribute的类型可以作为变量让用户来自己选择。\n要想使用vector必须包含适当的头文件\n```c++\n# include<vector>\nusing std::vector;\n```\nvector的元素不能是引用，vector的元素也可以是一个vector：\n`vector<vector<int>>`\n学习vector的时候可以和string对比学习\n1. 定义和初始化\n2. 支持的操作\n3. 处理vector对象中的字符\n+ 范围for语句\n+ 下标运算符\n+ 迭代器\n\n#### 定义和初始化vector对象\n\n| 代码| 含义|\n|---|---|\n| vector<T> v1| v1是一个空的vector，它的潜在类型是T类型，执行默认初始化|\n| vector<T> v2(v1)| v2中包含了v1所有元素的副本|\n| vector<T> v2 = v1| 等价于v2(v1), v2中包含了v1所有元素的副本|\n| vector<T> v3(n, val)| v3包含了n个重复的元素，每个元素的值都是val|\n| vector<T> v4(n)| v4包含了n个重复地执行了初始化的对象|\n| vector<T> v5{a, b, c}| v5包含了初值个元素，每个元素被赋予了相对应的初始值|\n| vector<T> v5 = {a, b, c} | 等价于v5{a, b, c}|\n\n`vector<string> svector;`最常见的就是先定义一个空的vector，然后当运行时获取的元素再逐一添加，执行元素拷贝时，两个vector对象的类型必须相同。\n\n##### 列表初始化和创建指定数量的元素的比较\n+ 列表初始化，用花括号`vector<string> v1{\"a\", \"an\", \"the\"};`\n+ 创建指定的元素比较，用圆括号`vector<int> v2(10, -1);`10个int类型的元素，每个都被初始化为-1。`vector<string> v3(10, \"Hi\");`10个string类型的元素，每个都被初始化为Hi。\n\n如果vector不给赋处置，则默认：\n```c++\nvector<int> ivec(10);\t//10个元素，每个都初始化为0\nvector<string> svec(10);\t//10个元素，每个都初始化为空string对象\n```\n区分()和{}\n```c++\nvector<int> v1(10); // v1有10个元素，每个都是0\nvector<int> v2{10};\t//v2有一个元素，该元素的值时10\nvector<int> v3(10, 1);\t//v3有10个元素，每个值都是1\nvector<int> v4{10, 1};\t//v4有2个元素，分别是10和1\nvector<string> v5{\"hi\"};\t//v5有一个元素是“hi”\nvector<string> v6(\"hi\");\t//错误，不能使用字符串字面值构建vector对象\nvector<string> v7{10};\t//注意，类型是string，所以v7有10个默认初始化的元素\nvector<string> v8{10, \"hi\"};\t//v8有10个元素值为“hi”的元素\n```\n\n#### 向vector对象中添加元素\n先定义一个空的vector对象，再在运行时向其中添加具体值。使用`push_back`。如果循环体内包含了有向vector对象添加元素的语句，则不能使用范围for循环。\n```c++\nvector<int> v2;\nfor(int i; i <100; ++i){\n\tv2.push_back(i);\n}\n```\n#### 支持的操作\n|代码|含义|\n|---|---|\n|v.empty()| 如果v不含有任何元素，返回真；否则返回假|\n|v.size()| 返回v中元素的个数|\n|v.push_back(t)| 向尾端添加一个值为t的元素|\n|v[n]| 返回v中的第n个位置上的元素的**引用**|\n|v1 = v2| 将v2中的元素拷贝替换v1中的元素|\n|v1 = {a, b, c...}| 将列表中的元素拷贝替换v1中的元素|\n|v1 == v2| v1和v2相等当且仅当他们的元素数量相同且对应位置上的元素值都相同|\n|v1 != v2| ...|\n|<, <=, >, >=| 以字典顺序进行比较|\n\n---\n\n**访问vector对象的元素**\n赋值需要用引用\n```c++\nvector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9};\nfor (auto &i: v ){\t\n\ti *= i;\n}\n```\n只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。\n**vector.size()的问题**\nvector 的size函数返回vector大小，返回值类型为size_type，Member type size_type is an unsigned integral type，即无符号整数；\nvector a;// 没有初始化时没有元素\na.size()返回一个无符号整型，当a的大小是0时，a.size() - 1返回一个正数18446744073709551615，导致访问越界。\n所以使用for循环的时候可以使用decltype()\n`for(decltype(v1.size()) i=0; i<v1.size(); ++i)`\n\n---\n\n### 迭代器\n使用迭代器可以访问容器的某个元素，迭代器也能从一个元素移动到另外一个元素。类似于指针类型，迭代器提供了对对象的间接访问。感觉迭代器就是指针加（索引index）的类型之和，比如说vector的迭代器，每个元素都有一个自己对应的迭代器，迭代器按照元素顺序排列，可以前后移动，如果要通过迭代器修改/访问元素，就用解引用符号。注意⚠️迭代器不是索引，它不是从0开始。v.begin()不是0，而且迭代器没有加法运算，只有减法运算。但是可以把迭代器和 两个迭代器之间的距离（iter1 - iter2相加），之后在iterator + difference_type来移动迭代器。\n在用mid = begin + (end - begin)/2的时候注意， end不是最后一位，而是尾元素之后的一位！\n\n#### 使用迭代器\n\n+ begin成员负责返回指向的第一个元素（或第一个字符）的迭代器。\n+ end成员则负责返回指向容器尾元素的下一个位置的迭代器，也就是说，该迭代器指示的是容器的一个根本不存在的“尾后”元素。\n如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。\n```c++\nauto b = v.begin() //b表示v的第一个元素\nauto e = v.end() //e表示v尾元素的下一个位置\n// b和e的类型相同\n```\n#### 迭代器运算符\n用==和!=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等，否则两个迭代器不相等。\n\n\n\n| 运算符         | 含义                                                     |\n| --- | --- |\n| *iter          | 返回迭代器iter所指元素的引用（解引用）                   |\n| iter->mem      | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem |\n| ++iter         | 令iter指示容器的下一个元素                               |\n| --iter         | 令iter指示容器的上一个元素                               |\n| iter1 == iter2 | 判断两个迭代器是否相等                                   |\n\n\n#### 将迭代器从一个元素移到另一个元素\n迭代器使用递增（++）运算符来从一个元素移动到下一个元素。因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用操作。\n例子把string对象中的第一个单词改为大写形式\n```c++\nstring s = \"some string\";\nfor(auto iter = s.begin(); iter != s.end() && !isspace(*iter); ++iter){\n\t*iter = toupper(*iter);\n}\n```\n**for中使用!=而非<进行判断：因为这种风格在标准库提供的所有容器上都有效。只有string和vector等一些标准库类型有下标运算（s[0]），而并非全都如此。所以标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没定义<运算符。因此要养成使用迭代器和!=的习惯，就不用太在意用的到底是哪种容器类型了。**\n\n#### 迭代器的类型\n那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：\n```c++\nvector<int>::iterator it1;  //\tit1能读写vector<int>中的元素\nstring:: iterator it2; // it2能读写string对象中的字符\n\nvector<int>::const_iterator it3;\t// it3只能读元素，不能写元素\nstring::const it4\t//it4只能读字符，不能写字符\n```\nconst_iterator和常量指针差不多，能读取但是不能修改所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。\n\n#### begin和end运算符\nbegin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator\n```c++\nvector<int> v;\nconst vector<int> cv;\nauto iter1 = v.begin(); //iter1的类型是vector<iter>::iterator;\nauto iter2 = cv.begin(); //iter2的类型是vector<iter>:: const_iterator;\nauto iter3 = v.cbegin(); //iter3的类型是vector<iter>:: const_iterator;\t\n```\n**结合解引用和成员访问操作**\n对一个由字符串组成的vector对象来说，想要检查其元素是否为空，令iter是该对象的迭代器，只需要检查iter所指字符串是否为空就可以了：`(*it).empty()`\n为了简化上述表达，c++语言定义了**箭头运算符**（->）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，iter->mem和(*it).mem表达的意思相同。\n\n**但凡使用了迭代器循环体，都不要向迭代器所属的容器添加元素（push_back）。**\n\n#### 迭代器的运算\nstring和vector的迭代器提供了更多的额外的运算符\n|代码|含义|\n|---|---|\n|iter + n|迭代器加上一个整数值仍然得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的下一位置|\n|iter - n| 迭代器减去一个整数值仍然得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的头位置|\n|iter1+ = n|迭代器的复合赋值语句，将iter1加n的结果赋值给iter1|\n|iter1 -= n|迭代器的复合赋值语句，将iter1减n的结果赋值给iter1|\n|iter1 - iter2|两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器（iter2）向前移动的差值个元素后将得到左侧的迭代器（iter1）。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置|\n|>, >=, <, <=| 迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者为元素的下一位置|\n\n\n```c++\nauto mid = vi.begin() + vi.size()/2; //计算得到最接近vi中间元素的一个**迭代器**\n```\n两个迭代器之间的距离（iter1 - iter2），它的类型是名为difference_type的带符号的整型数，string和vector都定义了difference_type，因为这个距离可正可负。\n\n#### 为什么mid =beg + (end - beg)/2而非 mid = (beg + end)/2\nC++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。与之相反的，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一容器中的元素或尾后元素。另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。\n\n在本题中，因为迭代器的加法不存在，所以 mid = (beg + end) / 2; 不合法。mid = beg + (end - beg) / 2; 的含义是，先计算 end - beg 的值得到容器中的元素个数，然后控制迭代器从开始出向右移动二分之一容器的长度，从而定位到容器正中间的元素。\n\n---\n\n### 数组\n数组与vector类似，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。\n**如果不清楚元素的个数，请使用vector。**\n\n数组长度不像vector和string可以用v1.size()\n只能用sizeof(a)/sizeof(a[0])来表示\nsizeof()函数可以返回数组所占的内存，而sizeof(a[0])返回的是数组第一个元素所占的内存。每个元素所占内存一致\n\n#### 定义和初始化内置数组\n\n+ 默认情况下，数组的元素被默认初始化（int是0，string是空...）\n+ 数组的维度必须是常量表达式\n+ 定义数组的时候必须指定数组类型\n+ 不允许用auto关键字由初始值的列表推断类型\n+ 数组的元素应为对象，不存在存放引用的数组\n+ 不允许将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值\n```c++\nunsigned cnt = 42; //不是常量表达式\nconstexpr unsigned sz = 42; //常量表达式\nint arr[10];\t//含有10个整数的数组\nint *parr[sz];\t//含有42个整型指针的数组\nstring bad[cnt];\t//错误，cnt不是常量表达式\nstring strs[get_size()];\t//当get_size是constexpr时正确；否则错误\n```\n#### 显式初始化数组元素\n```c++\nconst unsigned sz = 3;\nint ial[sz] = {0, 1, 2}; //含有3个元素的数组，元素值分别是0, 1, 2\nint a2[] = {0, 1, 2}; //维度是3的数组\nint a3[5] = {0, 1, 2}; //等价于a3[] = {0, 1, 2, 0, 0}\nstring a4[3] = {\"hi\", \"bye\"}; //等价于a4[] = {\"hi\", \"bye\", ''}\nint a5[2] = {0, 1, 2}; //错误：初始值过多超出范围\n```\n#### 字符数组\n字符数组有一种额外的初始化形式，可以用字符串字面值（string）对此类数组初始化。当使用这种方式时，一定要注意**字符串字面值的结尾处还有一个空字符**，但是如果不用string赋值，可以不加空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：\n```c++\nchar a1[]  = {'c', '+', '+'}; // 列表初始化，没有空字符，用这种方式不需要强制加空字符\nchar a2[] = {'c', '+', '+', '\\0'}; // 列表初始化，含有显示的空字符\nchar a3[] = \"c++\"; // 自动添加表示字符串结束的空字符\nconst char a4[6] = \"Danial\"; // 错误，没有空间可存放空字符，用string初始化会自动添加空字符\n```\n#### 理解复杂数组声明\n+ 存放指针的数组\n+ 不存在存放引用的数组\n+ 数组的指针\n+ 数组的引用\n```c++\nint *ptrs[10]; // ptrs是含有10个整型指针的数组\nint &refs[10]; = /*?*/ // 错误：不存在存放引用的数组\nint (*Parray)[10] = &arr; // Parray 指向一个含有10个整型的数组\nint (&arrRef)[10] = arr; // arrRef 引用一个含有10个整数的数组\n```\n`int *ptrs[10]`定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针\n`int (*Parray)[10] = &arr` *Parray意味着Parray是个指针，Parray指向大小为10的int数组\n#### 主函数内外的初始值区别\n```c++\nstring sa[10];  \nint ia[10];\nint main(){\n\tstring sa2[10];\n\tint ia2[10];\n}\n```\n对于 string 类型的数组来说，因为 string 类本身接受无参数的初始化方式，所以不论数组定义在函数内还是函数外都被默认初始化为空串。\n对于内置类型 int 来说，数组 ia 定义在所有函数体之外，根据C++的规定，ia 的所有元素默认初始化为0；而数组 ia2 定义在 main 函数的内部，将不被初始化，如果程序试图拷贝或输出未初始化的变量，将遇到未定义的奇异值。**int类型在main函数内不会被默认初始化**\n\n#### vector和数组的区别\n数组与 vector 的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问。\n\n数组与 vector 的最大不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能较好，但是与 vector 相比损失了灵活性。vector可以拷贝，数组不能拷贝。\n\n具体来说，数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后原数组的所有元素复制到新数组中去。我们也无法像 vector 那样使用 size 函数直接获取数组的维度。如果是字符数组，可以调用 strlen 函数得到字符串的长度；如果是其他数组，只能使用 sizeof(array).sizeof(array[0]) 的方式计算数组的维度。\n#### 访问数组的元素\n\n+ 范围for语句\n+ 下标运算符\n\n在使用数组下标时，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。\n\n#### 指针和数组\n使用数组的时候编译器一般会把它转化成指针。\n比如说`int a[5] = {1, 2, 3, 4, 5};`\n此时数组名称`a`就是一个指针，指向数组第一个元素。\n对`a`解引用`*a`得到的是数组第一个元素的值1。\n\n```c++\nstring nums[] = {\"one\", \"two\", \"three\"};\nstring *p = &nums[0]; // p指向nums的第一个元素\nstring *p = nums; //等价于p2 = &nums[0]\n```\n在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针\n\n在使用数组作为一个`auto`变量的初始值时，推断得到的类型是**指针**而非数组\n但是用`decltype()`时上述转化不会发生, decltype(ia)返回的类型是由10个整数构成的**数组**, 但是数组的内容可能是奇怪的值。\n\n```c++\nint ia[] = {0,1,2,3,4,5,6,7,8,9,10};\nauto ia2(ia); //ia2是一个整型指针，指向ia的第一个元素\ndecltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; //ia3是一个含有10个整数的数组\n```\n#### 指针也是迭代器(指针遍历数组)\nvector和string的迭代器支持的运算，数组的指针也全都支持\n通过指针遍历数组有两种方法：\n+ 获取首元素和尾元素下一个位置的指针\n```c++\nint arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nint *p = arr; //定义p为首元素的指针\n++p;\t//p指向arr[1]\nint *e =&arr[10];\t//arr的尾元素是a[9], 这里指向了arr尾元素的下一位置\nfor(int *b = arr; b!= e; ++b){\n\tcout<<*b<<endl;\n}\n```\n注意⚠️一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector的end函数返回的与迭代器类似的功能。要特别注意，尾后指针不能执行解引用和递增操作。\n+ 使用标准库函数**begin**和**end**，必须要用iterator头文件\n```c++\n#include<iterator>\nusing std::begin;\nusing std::end;\nint ia[] = {0,1,2,3,4,5,6,7,8,9};\nint *beg = begin(ia);\t//指向ia元素的指针，注意给变量命名的时候不要用begin，end等关键字！\nint *last = end(ia); //指向arr尾元素的下一位置的指针,类型是int*而不是auto\n```\n注意区别和**vector的begin和end**\nbegin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator\n\n```c++\nvector<int> v;\nconst vector<int> cv;\nauto iter1 = v.begin(); //iter1的类型是vector<iter>::iterator;\nauto iter2 = cv.begin(); //iter2的类型是vector<iter>:: const_iterator;\nauto iter3 = v.cbegin(); //iter3的类型是vector<iter>:: const_iterator;\n```\n#### 指针运算\n给一个指针加上或减去某个整数值，结果仍然是指针。新指针指向的元素与原来的指针相比前进（后退了）该整数值个位置。但是移动不能超过尾元素的下一个位置。\n```c++\n\tconstexpr size_t sz = 5;\n\tint arr[sz] = {1,2,3,4,5}; \n\tint *ip = arr //指向arr数组第一个元素\n\tint *ip2 = ip + 4; //指向arr的尾元素arr[4]\n```\n\n和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一数组中的元素，而且指针运算没有加法，只有减法，但是也可以把指针和指针之间相减后的距离做加法运算。两个指针相减的结果的类型是`ptrdiff_t`的标准库类型，它和size_t一样，`ptrdiff_t`也是一种定义在cstddef头文件中的机器的相关类型。因为差值可能为负数，所以ptrdiff_t是一种带符号的类型。之前vector的迭代器之差的类型是`difference_type`。\n如果两个指针指向同一数组的元素，就能利用关系运算<, >, =进行比较\n\n```c++\nauto n = end(arr) - begin(arr)\n```\n#### 解引用和指针运算的交互\n指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针：\n``` c++\nint ia[] = {0, 2, 4, 6, 8};\nint last = *(ia + 4); // 把last初始化成8，也就是ia[4]的值。注意，要加上括号\n```\n#### 下标和指针\n\np[-2], []就等于*()\n\n```c++\nint *p = &ia[2];// p指向索引为2的元素\nint j = p[1]; //p[1]等价于*(p+1),就是ia[3]表示的元素\nint k = p[-2]; //p[-2]等价于*(p-2), 就是ia[0]表示的元素\n```\n### 总结\n\n#### 标准库类型string，vector\n\n##### string::size_type类型\n\n对于size函数来说，返回的是一个string::size_type的类型的值，这是一种新的类型。string::size_type函数返回的是一个无符号的整型数。**如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigend可能带来的问题。**\n\n##### vector.size()\n\nvector 的size函数返回vector大小，返回值类型为size_type，Member type size_type is an unsigned integral type，即无符号整数；\nvector a;// 没有初始化时没有元素\na.size()返回一个无符号整型，当a的大小是0时，a.size() - 1返回一个正数18446744073709551615，导致访问越界。\n所以使用for循环的时候可以使用decltype()\n`for(decltype(v1.size()) i=0; i<v1.size(); ++i)`\n\n#### 标准库类型string，vector下标\n\n标准库类型的下标必须是无符号类型 unsigend\n\n#### 数组下标\n\n在使用数组下标时，没有强制要求通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。\n\n#### 数组维度\n\n定义数组的维度必须是常量表达式。\n\n关于数组的拷贝，不可以将整个数组赋值给另一个数组，只能逐个元素的拷贝。\n如果利用vector，可以直接将整个vector拷贝给另一个vector。\n\n#### C风格字符串\n**c标准库string函数**\nc风格字符串不是一种类型，而是为了表达和使用字符串而形成的约定熟成的写法。按照此习惯书写的字符串放在字符数组中并以空字符结束，在字符串后面跟着（'\\0'），一般用指针来操作这些字符串。\ncstring头文件定义的函数\n\n| 代码| 含义|\n|---|---|\n| strlen(p)| 返回p|\n| strcmp(p1, p2) | 比较p1和p2的相等性。如果p1 ==p2，返回0；如果p1>p2，返回一个正值；如果p1<p2,返回一个负值 |\n| strcat(p1, p2) | 将p2附加到p1之后，返回p1|\n| strcpy(p1, p2) | 将p2拷贝给p1|\n\n传入此类函数的指针必须指向以空字符作为结束的数组，但是空字符不会被计数在内。\nchar ca[] = {'C', '+', '+'};\t//不以空字符结尾\ncout<<strlen(ca)<<endl;\t\t//错误：ca中没有以空字符结束, 长度会被打印，但是打印长度会出现错误。\n#### 比较字符串\n+ string对象的比较\n```c++\nstring s1 = \"A string example\";\nstring s2 = \"A different string\";\nif (s1<s2) //false: s2小于s1\n-----------------------------------------------\n//string的加法操作\nstring largeStr = s1 + \" \" + s2;\n```\n+ c风格字符串\n```c++\nconst char ca1[] = \"A string example\";\nconst char ca2[] = \"A different string\";\nif (ca1<ca2) //\t未定义，ca1和ca2是指向数组首地址的指针，两个指针指向的并非同一对象，所以将得到为定义的结果\nif(strcmp(ca1, ca2)<0) //和两个string对象比较s1<s2效果一样\n------------------------------------------------\nconst char ca1[] = \"A string example\";\nconst char ca2[] = \"A different string\";\nconst char ca3 = ca1 + ca2; //错误，两个指向不同对象的指针相加，无意义\nstrcpy(largeStr, ca1); //把ca1拷贝给largeStr\nstrcat(largeStr, \" \");\t//在largeStr的末尾加上一个空格\nstrcat(largeStr, ca2);\t//把ca2连接到largeStr后面\n}\n```\n**对于大多数应用来说，使用标准库string要比使用c风格字符串更安全，更高效**\n`while(空字符)`就会停止循环\n\n---\n\n### 多维数组\n当一个数组的元素仍然是数组时，通常用两个维度来定义它：一个维度表示数组本身的大小，另外一个维度表示其元素（也是数组）大小：\n```c++\nint ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组\nint arr[10][20][30]; = {0}; //将所有元素初始化为0\n```\n对于二维数组来说，常把第一个维度称作行，第二个维度称作列。\n#### 多维数组的初始化\n```c++\nint ia[3][4] = {\t//三个元素，每个元素都是大小为4的数组\n{0,1,2,3},\t//第一行的初始值\n{4,5,6,7},\t//第二行的初始值\n{8,9,10,11}\t//第三行的初始值\n}\n//没有标识每行的花括号，与之前的初始化语句是等价的\nint ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};\n// 显示地初始化每行的首元素\nint ia[3][4] = {{0},{4},{8}};\n//显示地初始化第一行的四个元素，其他元素执行默认初始化为0\nint ix[3][4] = {0, 3, 6, 9};\n```\n#### 多维数组的下标引用\n如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素。\n如果表达式的下标运算符数量比数组维度小，则表达式的结果将是给定索引处的一个内层数组。\n```c++\nia[2][3] = arr[0][0][0]; //用arr的首元素为ia最后一行的最后一个元素赋值\nint (&row)[4] = ia[1]; //把row绑定到ia的第二个4元素数组上\n```\n把row定义成一个含有4个元素整数的数组的引用（是数组的引用，而不是存放引用的数组（数组的元素必须是对象，不能是引用）），然后将其绑定到ia的第2行。\n\n#### 用for语句处理多维数组\n##### 使用两层嵌套for语句\n```c++\nconstexpr size_t rowCnt = 3, colCnt = 4;\nint ia[rowCnt][colCnt]; //12个为初始化的元素\n// 对于每一行\nfor (size_t i = 0; i !=rowCnt; ++i){\n//对于每一列\n\tfor(size_t j = 0; j!=colCnt; ++j){\n\t//将元素的位置索引作为它的值\n\tia[i][j] = i*colCnt + j;\n\t}\n}\n```\n##### 使用范围for循环\n```c++\nsize_t cnt = 0;\nfor (auto &row : ia){\n\tfor(auto &col : row){\n\t\tcol = cnt;\n\t\t++cnt;\n\t}\n}\n```\n因为要改变元素的值，所以得把**控制变量row和col声明成引用类型。**\n**使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。**\n原因：因为为了避免数组被自动转化成指针。假设不用引用类型：\n```c++\nfor (auto row : ia){\n\tfor(auto col : row ){\n\t\t\n\t}\n}\n```\n程序将无法通过编译。因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转化成指向该数组首元素的指针。这样得到的row的类型就是int\\*，显然内层循环就不合法了，编译器将试图在一个int\\*内遍历，这肯定不行了。\n\n#### 指针和多维数组\n当程序使用多维数组的名字时，也会自动将其转化成指向数组首元素的指针。\n因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是**指向第一个内层数组的指针**：\n\n```c++\nint ia[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组\nint (*p)[4] = ia; //p指向含有4个整数的数组\np = &ia[2]; // p指向ia的尾元素\n```\n区别\n```c++\nint *ip[4];\t//整型指针的数组，存放了4个指针的数组 \nint(*ip)[4];\t//指向含有4个整数的数组 是一种类型\n```\n使用指针遍历多维数组\n```c++\nfor (auto p = ia; p != ia+3; ++p ){ // auto p  = ia指向ia的第一行，p+1指向ia的第二行，p+2指向ia的第三行\n\tfor(auto q = *p; q!=*p+4; ++q ){ //*p是一个含有4个整数的数组, 所以auto q = *p，q 指向数组的首地址\n\tcout<<*q<<endl;\n\t}\n}\n```\n也可以通过begin和end实现同样功能\n\n```C++\nfor (auto p = begin(ia); p != end(ia); ++p){\n\tfor (auto q = begin(*p); q!=end(*p); ++q){\n\t\tcout<<*q<<endl;\n\t}\n}\n```\n#### 类型别名简化多维数组指针\n```c++\nusing int_array = int[4]; \ntypedef int int_array[4];\n```\n\n#### 多维数组用for遍历输出区别比较\n```c++\nint ia[3][4] = {{1,2,3,4},\n          \t\t\t{5,6,7,8},  \n          \t\t\t{9,10,11,12}};\n```\n##### 使用范围for循环输出\n```c++\nfor(int (&row)[4] : ia){ //注意：外层一定要有引用\n        for(int col: row){\n            cout<<col<<' ';\n        }\n        cout<<endl;\n    }\n```\n可以使用auto 来替代复杂的数据类型类型\n```c++\nfor(auto &row : ia){ //注意：外层一定要有引用\n        for(auto col: row){\n            cout<<col<<' ';\n        }\n        cout<<endl;\n    }\n```\n##### 使用普通for循环 + 下标运算符\n```c++\nfor (size_t i = 0; i!=3; i++)\n    {\n        for (size_t j = 0; j!=4 ; j++)\n        {\n            cout<<ia[i][j]<<' ';\n        }\n        cout<<endl;\n        \n    }\n```\n##### 使用普通for循环 + 指针\n```c++\n for(int(* p)[4] = ia; p != ia+3; ++p)// 注意 int(*p)[4]是一种类型：指向一个有4个整型元素的数组的指针,ia是指向第一个内层数组的指针\n    {\n        for(int *q = *p; q!= *p+4; ++q)//p是指向一个有4个整型元素的数组的指针，*p是一个有4个整型元素的数组，q是指向数组的首地址的指针\n        {cout<<*q<<\" \";}\n        cout<<endl; \n    }\n```\n可以使用auto 来替代复杂的数据类型类型\n```c++\nfor(auto p = ia; p != ia+3; ++p)// 注意 int(*p)[4]是一种类型：指向一个有4个整型元素的数组的指针,ia是指向第一个内层数组的指针\n    {\n        for(auto q = *p; q!= *p+4; ++q)\n        {cout<<*q<<\" \";}\n        cout<<endl; \n    }\n```","tags":["C++"]},{"title":"C++中string和char的比较","url":"/2020/06/13/C-中string和char的比较/","content":"\n在C++中要想表达字符串有三种可能的方法：\n+  用Standard Library （C++标准库）定义的类string：\nstring表示可变长的字符序列，使用string类型必须首先包含string头文件。\n+ 用C风格字符串char\\*：\nchar\\*定义的是一个字符类型的指针，指向字符串数组的首地址。\n+ 用C风格字符串char []：\nchar[]定义了一个类型为字符的数组。\n\n## 初始化\n### string的初始化\n```c++\nstring s1; //默认初始化，s1是一个空字符串\nstring s2 = s1；//s2是s1的副本\nstring s3 = \"hiya\"; //s3是该字符串字面值的副本\nstring s4(10, 'c'); //s4的内容是cccccccccc\n```\n### char\\*的初始化\n```c++\nchar *s1 = \"Hello world\";\nchar *s2 = {'c','+','+'}; // 错误，指针不能这样初始化\n```\n### char[] 的初始化\n```c++\nchar a1[]  = {'c', '+', '+'}; // 列表初始化，没有空字符，用这种方式不需要强制加空字符\nchar a2[] = {'c', '+', '+', '\\0'}; // 列表初始化，含有显示的空字符\nchar a3[] = \"c++\"; // 自动添加表示字符串结束的空字符\nconst char a4[6] = \"Danial\"; // 错误，没有空间可存放空字符，用string初始化会自动添加空字符\n```\n## 赋值\n\n### string的赋值\n对于string类而言，允许把一个对象的值赋给另外一个对象。\n```c++\nstring s1 = \"hello world\";\nstring s2 = s1;\ns1[1] = 'a'; //\t输出hallo world\n```\n\n### char \\*的赋值\nchar \\*是一个char型指针变量，其值（指向）可以改变。可以把其他字符串赋值给char\\*，实际上的操作是把其他字符串的首地址存放到char\\*指针变量里。修改的为指针变量的值，不是修改字符串常量，是变量赋值操作。\n```c++\nchar *s1 = \"hello world\";\ns1 = \"xuexuexue\"; // 修改了s1作为指针的指向，从指向hello world的首地址改为指向想xuexuexue\nchar *s2 = s1; //正确，把s1地址的值赋给了指针s2\ns1[1] = 'a'; //错误，指针无法这样操作 \n```\n### char []的赋值\n\nchar b[]: b是一个char型数组的名字，也是该数组首元素的地址，是**常量**，其值不可以改变 。但是可以修改其元素的值。\n```c++\nchar s1[] = \"hello world\";\ns1 = \"nihao\"; //错误 s1是该数组原属的首地址，是常量，无法修改\nchar s2[] = s1; //错误 不能这样赋值\ns1[1] ='a'; //正确，可以修改数组元素\n```\n## 显示长度\n### string显示长度\n使用`.size()`\n```c++\nstring s = \"hello world\";\ncout<<s.size()<<endl;\n```\n### char\\*和char []显示长度\n\n使用`strlen()`\n```c++\nchar s1[] = \"hello world\";\nchar *s2 = \"Hallo Welt\";\ncout<<strlen(s1)<<strlen(s2)<<endl;\n```\n## 连接合并\n### string连接合并\n\n当把string对象和**字符字面值**及**字符串字面值**混在一条语句中使用时，必须确保每个加法运算符（+）的两侧至少有一个是string\n\n```c++\nstring s1 = \"Hello\" + \", \" //错误，“hello”类型是const char[5], \", \"类型是const char[3]，加号左右两边至少要有一个string\nstring s2 = \"Hello\"\nstring s1 = s2 + \", \"\t//正确\nstring s3 = s2 + \", \" + \"world\" //正确 等价于（s2 + \", \"）+ \"world\"\nstring s4  = \"Hello\" + \", \" + s2 //错误 等价于（\"Hello\" + \", \"） + s2\n```\n+ string对象可以和字面值相加\n+ 两个字面值不能相加\n+ 多个相加时注意加法的左结合律\n\n### char\\* 和char []连接合并\n需要先用`strcpy(p1, p1)`复制给一个新的数组（数组空间足够大），然后用`strcat(p1, p2)`添加合并。char\\* 和char []可以合并。\n```c++\nchar s1[] = \"hello world\";\nchar *s2 = \"toll\";\nchar largeStr[100]; //新的数组空间必须足够大\nstrcpy(largeStr, s1); //把s1赋值给largeStr\nstrcat(largeStr, \" \"); //在largeStr后添加空格\nstrcat(largeStr, s2);\t//在新的带空格的largeStr后添加s2\n```\n## string和char\\*，char []之间的相互转化\n### char\\*，char[]----> string\n\nchar\\*----> string 一般来说都可以直接赋值转换\n```c++\nchar s1[] = \"hello world\";\nchar *s2 = \"heloo woold\";\nstring s3 = s1;\nstring s4 = s2;\n```\n### string----> char\\*,char[]\n\n如果程序的某处需要一个C风格字符串，无法直接用string对象来替代它。不能用string对象直接初始化指向字符的指针。`c_str()`函数返回的是一个指针，该指针对象指向一个以空字符串结束的字符数组，而数组所存的数据恰好与那个string对象一样。结果指针的类型是const char\\*,从而确保我们不会改变字符数组的内容。\n```c++\nstring s = \"hello world\"\nchar *str = s;\t//错误：不能用string对象初始化char*\nconst char *str = s.c_str(); //正确\n```","tags":["C++"]},{"title":"C++Primer第一章和第二章笔记","url":"/2020/06/09/C-Primer第一章和第二章笔记/","content":"\n## 第一章\n### 读取数量不定的输入数据\n```C++\nwhile (std::cin>>value)\n```\nwhile 会一直执行直到遇到文件结束符（或错误输入）。\n在这里clion对ctrl +d的是stop and rerun， 所以结束输入就不能用ctrl+d，但可以输入一个不是int的数据类型来结束它。\n\n## 第二章（变量和基本类型）\n### 基本数据类型\n当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则结果为true。\n当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。\n\n---\n|类型|含义|最小尺寸|\n|---|---|---|\n|bool|布尔类型|未定义|\n|char|字符|8 bit|\n|wchar_t|宽字符|16 bit|\n|char16_t|Unicode字符|16 bit|\n|char32_t|Unicode字符|32 bit|\n|short|短整型|16 bit|\n|int|整型|16 bit|\n|long|长整型|32 bit|\n|long long|长整型|64 bit|\n|float|单精度浮点数|32 bit|\n|double|双精度浮点数|64 bit|\n|long double|扩展精度浮点数|96 or 128 bit|\n\n---\n当一个算数表达式中既有无符号数又有int时，那个int值就会转成无符号数。比如：\nunsigned u = 10;\nint i = -42\nstd::cout<< u + i << std::endl; 如果int占32位，输出4294967264。\n\n---\n以0开头的整形代表8进制，以0x或0X的开头代表十六进制。\n科学计数法，其中指数部分用E或e标识。50 = 5e1, 0.01 = 1e-2\n\n---\n单引号字符char，双引号字符串。\n字符串String字面值的类型实际上是由常量字符构成的数组（array）。\n编译器在每个字符串的结尾处添加一个空字符（'\\0')，因此，字符串字面值的实际长度要比他的内容多1。例如，字面值'A'表示的是单独的字符A，而字符串\"A\"则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符。\n\n---\n'a'就是char，L'a'就是wchar_t\nchar占一个字节，wchar_t占两个字节，也就是16个比特（bit），最大值就是2<sup>16</sup>-1=65535，到这里读者可以看出宽字符和窄字符最大的区别就是占字节大小的不同\n![unicode](unicode.png)\n\n10u: unsigned\n3.14L: Long double\n如'\\012'就是八进制数012所对应的字符，也就是ASCII码10所对应的字符，即换行\n\n**需要注意的是转义序列在程序中是被当作字符而不是字符串来使用的**\n\n```c++\ncout<<'2'<<'\\t'<<'M'<<'\\n';\n```\n### 变量\n#### 默认初始化\n三条性质：\n\n1.定义在任何函数体外的变量会被初始化为0。 \n\n2.定义在函数体内部的变量不会被初始化。 \n\n3.类的对象未被初始化，则初值由类决定。\n\n#### 声明(declaration)和定义(definition)\n\ndeclaration: say the function exists. 在一个cpp文件中调用另一个cpp文件（一个函数），需要在cpp中声明这个被调用的函数\n\ndefinition: what the function is.\n\n①变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。\n\n②变量声明：用于向程序表明变量的类型和名字。\n\n③定义也是声明：当定义变量时我们声明了它的类型和名字。\n\n④extern关键字：通过使用extern关键字声明变量名而不定义它。\n\n1、定义包含了声明，但是声明不包含定义，\n\n如  int a = 0; //定义并声明了变量 a\n\nextern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。\n2、函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。\n\nvoid fun1();  //函数声明\n\nvoid fun1(){  //函数定义\n    cout<<\"fun1\"<<endl;\n}\n\n---\n\n### 复合类型(具体见另一篇文章)\n#### 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）\n为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化(比如 int &a = b, 之前已经定义b = 10)，使它指向一个已存在的对象(b)\n\n例如：\n\nint i, j;\n\nint &ri = i\t//定义int的引用ri，并初始化为变量i的引用 \n\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n\n#### 指针\n\n可以通过指针来间接访问内存\n##### 定义指针\nint a =10;\n数据类型 * 指针变量\nint * p; \n让指针记录变量a的地址， &这个操作符就是取地址。\np = &a；\n\n##### 使用指针\n可以通过解引用的方式来找到指针的内存，找到指针p（原数据的地址）中的原数据\n* p = 1000；//更改之后a的值也变为1000\n##### 指针所占用的内存空间\n在32位操作系统：占用4个字节\n在64位操作系统：占用8个字节(所有指针，int *，float * ，char *......)\n##### 空指针和野指针\n空指针：指针变量指向内存为0的空间\n用途：初始化指针变量\n注意：空指针指向的内存是不可以访问的, 0~255为系统占用内存\nint * p = NULL;\n\n---\n野指针：指针变量指向非法的内存空间\nint * p = (int * )0x1100; 自己定义的一个16进制数，自己定义的一块内存\n\n### const限定符  \n#### 常量表达式\n常量表达式（**const expression**）是指**不会改变**并且**在编译过程就能得到计算结果**的表达式。\n常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。需要计算一个编译时已知的常量，比如特定值的sine或cosin？确实你亦可以使用库函数sin或cos，但那样你必须花费运行时的开销。使用constexpr，你可以创建一个编译时的函数，它将为你计算出你需要的数值。用户的电脑将不需要做这些工作。\n一个对象是不是常量表达式由它的数据类型和初始值共同决定：\n\n```c++\nconst int max_files = 20;\t// 是常量表达式\nconst int limit = max_files + 1 //是常量表达式\nint staff_size = 27; // 不是常量表达式\nconst int sz = get_size();\t// sz不是常量表达式\n```\n\n尽管staff_size的初始值（27）是个字面常量值，但是由于它的数据类型只是个普通的int而非const int所以不属于常量表达式\n尽管sz本身是个常量，但是具体值到运行时才能获取到，所以也不是常量表达式\n**常量表达式就是等号左右两边都是常量的表达式。**\n一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型\n\n```c++\nconstexpr int mf = 20;\t//20是常量表达式\nconstexpr int limit = mf + 1; //mf + 1是个常量表达式\nconstexpr sz = size();\t//只有当size是一个constexpr函数时才是一条正确的声明语句\n```\n常量表达式必须是**字面值类型**：算数类型，引用类型和指针类型。\n**非字面值类型**：自定义类Sales_item, IO库，String类不属于字面值类型，也就不能被定义成constexp指针的初始值必须是nullptr或者是0，或者是储存于某个固定地址中的对象。\n函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其固定地址不变，能用来初始化constexpr指针。\nconstexpr声明中如果定义了指针，限定符constexpr仅对指针有效，与指针所指的对象无关：\n\n```c++\nconst int *p = nullptr;\t//p是一个 指向整型常量 的指针\nconstexprint *p = nullptr;\t//q是一个 指向整数 的 常量指针\n```\n\n---\n### 处理类型\n#### 类型别名\n有两种方法可以定义类型别名。\n+ 传统的方法是使用关键字**typedef**：\n```c++\ntypedef double wages;\t//wages是double的同义词,之后出现wages就和出现double一样\nwages x = 10.1；\ntypedef wages base, *p; //base是double的同义词，p是double*的同义词\n```\n+ 使用别名声明来定义类型的别名：\n相对来说更加直观、简单\n```c++\nusing SI = Sales_item; //SI是Sales_item的同义词\nusing x = double; \nx number = 666.66//之后使用x就像使用double一样\n这种方法的关键字using作为别名声明的开始，其后紧跟别名和等号，起作用是把等号左侧的名字规定成等号右侧的类型的别名。\n```\n#### auto类型说明符\nauto类型说明符：auto让编译器通过初试值来推算变量的类型。auto定义的变量必须有初始值。\n```c++\nauto item = val1 + val2;\n```\n此处编译器将根据val1和val2相加的结果来推断item的类型。如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item;如果这两个变量类型是double，则item的类型就是double，以此类推。\n##### 复合类型，常量和auto\n使用引用其实是使用引用的对象，特别是当被用作为初始值时，真正参与初始化的其实是引用对象的值。\n```c++\nint i = 0, &r = i;\nauto a = r; // a是一个整数（r是i的别名，而i是一个整数）\n```\nauto会忽略掉顶层const（常量指针），同时底层const（指向指针的常量）则会保留下来，比如当初始值是一个指向常量的指针时。\n但是\n\n```c++\nconst int ci = i, &cr = ci;\nauto b = ci; //b是一个整数（ci的顶层const特性被忽略了）\nauto c = &i; //c是一个整型指针\nconst auto f = ci； //如果希望推出的auto类型是一个顶层const，则需要明确指出\n```\n注意！！\n```c++\nconst int i = 42;\nauto *p = &i;//此时p的类型是const int*，指向指针的常量，底层const不会被忽略。\n```\n#### decltype\n作用：希望从表达式的类型推断出要定义的变量，但是不想用该表达式的值初始化变量。它的作用是选择并返回操作数的数据类型。\n```c++\ndecltype(f()) sum = x;\t//sum的类型就是函数f的返回类型\n```\n如果decltype使用的表达式是个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n```c++\nconst int ci = 0, &cj = ci;\ndecltype(cj) x = 0;\t//x的类型是const int\ndecltype(cj) y = x; //y的类型是const int&，y绑定到变量x\ndecltype(cj) z; //错误：z是一个引用，必须初始化\n```\ndecltype和引用\n```c++\nint i =42, *p = &i, &r = i;\ndecltype(r) = a; //a是int引用类型和通过引用r和i绑定\ndecltype(r+0) b; //正确，加法的结果是int，因此b是一个（未初始化的）int\ndecltype(*p) c; //错误，c是int&，必须初始化\n\ndecltype((i)) d; //错误，d是int&，必须初始化\ndecltype(i) e; //正确，e是一个未初始化的int\n```\n对于decltype：\n+ 推测引用变量本身的类型得到的仍是引用\n+ 如果表达式的内容是解引用操作（\\*p），decltype将得到引用类型\n+  推测变量的类型时，如果多加了一层括号，结果差别很大。双层括号的结果永远是引用，而decltype（variable）单层括号结果只有当varible本身就是一个引用时才是引用。\n\n---\n**总结一下上面的区别**\n\n+ typedef, using: 把一些double，int等已知的数据类型重命名，命名成自己想要的名称。\n+ auto：通过初始值来推算变量的数据类型\n+ decltype：把某一个变量的数据类赋给另一个变量，让这两个数据变量类型相同。\n\n**auto和decltype的区别**\n如果面对一个变量是引用，那么auto会把那个类型看作是和该引用绑定对象的类型（int），而decltype会把它看作是引用本身的引用类型（int &）\n```c++\nint i = 42, &r = i;\nauto a = r; //a的类型是int（和r绑定的对象的类型）\ndecltype(r) b = i; //b的类型是引用int&，所以必须初始化和对象i绑定\n```\n\n---\n### 自定义数据结构\n数据结构是把一组相关的数据元素组织起来然后使用他们的策略和方法。就比如说int就是把所有整数作为一种数据类型，所以我们也可以自己定义某一类具有共同点的元素作为数据类型。\n比如说Sales_data类型\n```c++\nstruct Sales_data{\n\tstd::string bookNo; //书的编号\n\tunsigned units_sold = 0; // 卖出的数量，无符数\n\tdouble revenue = 0.0; //收入\n}\n```\n自定义数据结构以关键字struct开始，紧跟着类名和实体，最后的分号不能省略\n还有一种自定义结构以class作为关键字，也就是常说的类。以后会经常遇到。\n#### struct和class的区别\n在C++中struct和class的唯一区别就在于**默认的访问权限不同**, 继承的时候不推荐使用struct\n+ struct默认权限为public\n+ class默认权限为private\n```c++\nclass C1{\n\tint a;\n};\nstruct C2{\n\tint a;\n};\nint main(){\n\tC1 c1; //实例化\n\tc1.a = 10; //错误，默认的情况下class的成员为private，只能在类内访问，不能在类外访问\n\tC2 c2；\n\tc2.a = 10； //正确，默认的情况下struct的成员为public，既能在类内访问，又能在类外访问\n}\n```\n类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。\n类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该对象的定义所以分号不可少。\n#### 类数据成员（attribute）\n+ 类的数据成员定义了类的对象的具体内容\n+ 每个对象有自己的一份数据成员拷贝\n+ 修改一个数据成员，不会印象其他对象\n+ 创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化（0，空字符...）。\n\n#### 头文件\n为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样，例如把Sales_data类定义在名为Sales_data.h的头文件中。\n头文件通常包含那些只能被定义一次的实体，如类、const变量和constexpr变量等\n##### 头文件的书写规范\n+ #include\"header.h\" //表明当前文件和\"header.h\"处于同一工程且同一目录，一般是自己的类文件\n+ #include<header.h> //表明header.h和当前文件不属于同一工程，是外部目录，一般是标准库\n##### 头文件保护符（header guard）\n就是为了在主文件中如果多次引用了某个头文件的话，第一次引用会把头文件拷贝进主文件，之后再引用，就不要再把头文件再拷贝过来一次。\n**/#define** 指令把一个名字设置为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef** 当且仅当变量已定义时为真，**#ifndef** 当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到**#endif**指令为止。这些功能就能有效地防止重复包含的发生：\n```c++\n# ifndef SALES_DATA_H // 如果没有定义过SALES_DATA_H\n# define SALES_DATA_H// 那么定义SALES_DATA_H\n# include<string>\nstruct Sales_data{\n\tstd::string bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n}\n# endif\n```\n后面如果再一次包含Sales_data.h,则#ifndef的检查结果将为假，编译器将会忽略#ifndef到#endif之间的部分。\n\n\n\n\n","tags":["C++"]},{"title":"引用和指针","url":"/2020/05/29/引用和指针/","content":"# 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n通常类的数据量较大，采用传值的方式传递和返回对象会调用拷贝构造函数进行对象的拷贝操作，会带来大量内存空间的开辟和释放，导致性能的损耗、降低效率。因此通常采用引用或指针的方式进行对象的传递，而实际上针对对象的操作通常都使用引用来进行。\n```c++\nint a = 10;\nint & ref = a;\nref = 20; //此时a的值也是20。\n```\n## 引用传参\n用一个例子解释引用的作用。\n```c++\n#include <iostream>\n#include \"Sales_item.h\"\nusing namespace std;\nvoid func1(int a){\n    a = a*3;\n}\n\nvoid func2(int & a){\n    a = a*3;\n}\n\nint main() {\n    int b = 10;\n    func1(b);\n    cout<<b<<endl; // 此时b = 10。\n    func2(b);\n    cout<<b<<endl;// 此时b = 30。\n}\n```\n### 使用函数1的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc1(b）等价于func1(**int a = b**）把b的10赋值给a{\n    a = a*3;a等于30。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b等于原来的10。\n}\n### 使用函数2的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc2(b）等价于func1(**int & a = b**）把b和引用a绑定，此时a是b的别名，a和b的地址相同，修改a的值等同于修改b的值{\n    a = a*3; a等于30，此时b也等于30，因为a和b此时已经绑定在一起了。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b已经通过函数2被改变了值为30。\n}\n\n---\n\n## const的引用\n可以把引用绑定到const对象上，就像绑定到其他对象上一样。但是对常量的引用不能被用作修改它所绑定的对象：\n```c++\nconst int ci = 1024;\nconst int &r1 = ci;\nr1 = 42;\t//错误：r1是对常量的引用，无法改变\nint &r2 = ci;\t//错误：试图让一个非常量引用指向一个常量对象\n```\n### 初始化和对const的引用\n！！注意！！\nint &r = 0;\t//错误，引用只能绑定对象\nconst int &r = 0; //正确，允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式\n引用类型必须和引用对象的类型一致，但是有两个**例外**\n在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式：\n\n```c++\nint i = 42;\nconst int &r1 = i;\nconst int &r2 = 42;\n\ndouble dval = 3.14;\nint &r2 = dval\t// 错误，因为引用和对象类型不同\nconst int &r3 = dval;\t//正确：输出3\n```\n### 对const的引用可能引用一个并非const的对象\n常量引用仅对引用可参与的操作做出来限定，对于引用对象本身是不是常量未作出限定。因为对象也可能是个非常量，所以允许其他途径改变它的值。\n+ 对象：非常量\n+ 引用： 常量\n导致绑定后的引用无法改变值，永远等于绑定前对象的初始值，如果之后对象的值改变，那么对象值将不等于绑定的引用值。\n```c++\nint i = 42;\nint &r1 = i;\t// 引用r1绑定对象i\nconst int &r2 = i;\t//引用r2页绑定对象i，但是不允许通过r2修改i的值\nr1 = 10；\t//r1并非常量，i的值修改为0\nr2 = 0；\t//错误：r2是一个常量引用\ni = 10；\t//此时r2还是等于42，可以修改i的值，i此时为10，但是无法修改与它绑定的引用的值\n```\n\n---\n\n# 指针\n指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点：\n+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。\n+ 指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\n## 指针的定义\n数据类型 * 指针变量\nint * ipl, * ipl2;\ndouble dp, * dp2;\n\n### 概念梳理\n```c++\nint a = 3;\nint *ptr = &3; //错误，指针必须指向变量不能指向字面值\nint *ptr = a; //错误，a缺少取址符号\nint *ptr = &a;// 正确\n```\n### 对于令指针为0\n```c++\nint *ptr;\nptr = 0;//令ptr指针为空指针\n\n-------------------------------\nint *ptr = 0; //令ptr指针为空指针\n\n-------------------------------\nint *ptr;\n* ptr = 0// 错误\n\n-------------------------------\nint a = 0;\n    int *ptr = &a; //指针指向一个值为0，名称为a的对象\n```\n## 获取对象的地址\n指针存放某个对象的地址，要想获取改地址，需要使用**取地址符&**。\nint ival = 42;\nint * p = & ival;\t// p存放变量ival的地址，或者说p是指向变量ival的指针。\n## 利用指针访问对象\n如果指针指向了一个对象，则允许使用 解引用符* 来访问该对象。 \n```c++\nint ival = 42;\nint * p = &ival; //\tp存放着ival的地址。 \ncout<< *p; // 由符号*得到指针所指的对象，输出42\n```\n对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也是给指针所指的对象赋值：\n\n\n```c++\n*p = 0;\t// 由符号*得到指针p所指的对象，即可经由p为变量ival赋值\ncout<<*p; // 输出0\n```\n## 概念区分\n+ & 和数据类型一起出现：声明一个引用\n+ \\* 和数据类型一起出现：声明一个指针\n+ & 单独出现：取地址符，和对象（变量）一起使用，代表对象的地址\n+ \\* 单独出现：解引用符，和指针一起使用，代表指针包含地址的值\n```c++\nint i = 42;\nint & r =i; // &紧随类型出现，因此是声明的一部分，r是一个引用，并且和对象i绑定在一起\nint *p; // *紧随类型出现，因此是声明的一部分，p是一个指针\np = & i;\t// &出现在表达式中，是一个取地址符\n*p = i；\t// *出现在表达式中，是解引用符\nint & r2 = *p // &是声明的一部分，*是一个解引用符\n```\n在声明语句中，& 和* 用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同的场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当成不同的符号来看。\n## 空指针\n空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。空指针生成方法：\n+ int \\*p = nullptr; \n+ int \\*p2 = 0;\n+ int \\*p3 = NULL;\n```c++\nif (pi)\n...// pi的值是0， 因此条件值是false\nif(pi2)\n...// pi指向ival，因此它的值不是0，条件是true\n```\n任何非0指针对应的条件值都是true。\n\n## void\\* 指针\nvoid\\*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\\*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址到底存放着什么类型的对象不了解。\n```c++\ndouble obj = 3.14, *pd = &obj;\nvoid *pv = &obj;\t// obj可以是任意类型的对象\npv = pd;\t//pv可以存放任意类型的指针\n```\n## 指向指针的指针\n指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。\n通过\\*的个数可以区分指针的级别。\\*\\*表示指向指针的指针，\\*\\*\\*表示指向指针的指针的指针。\n```c++\nint ival = 1024;\nint *pi = &ival;\t// pi指向int型的数\nint **ppi = &pi;\t// ppi指向一个int型的指针\n```\n同样对于指针的指针也需要解引用时也要解两次\\*\\*ppi\n\n## 指向指针的引用\n引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用\n```c++\nint i = 42;\nint *p;\t//p是一个int类型的指针\nint *&r = p;\t//r是一个对指针p的引用,所以是指针的别名，类型也属于指针（引用）\nr = &i;\t//r引用了一个指针，因此给r赋值&i就是另p指向i，因为r和p已经捆绑在一起了\n*r = 0;\t//解引用r得到i，也就是p指向的对象，将i的值改为0\n```\n要了解int \\*&r = p中的r的类型到底是什么，最简单的方法是从左向右阅读r的定义。离变量名最近的符号（&）对变量有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，这里的符号\\*说明r的引用是一个指针。\n\n## 指针和const\n指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：\n```c++\nconst double pi = 3.14;\t//pi是个常量，它的值不能改变\ndouble *ptr = &pi;\t//错误：ptr是个普通指针\nconst double *cptr = &pi\t//正确：cptr可以指向双精度常量\n*cptr = 42;\t//错误：不能给*cptr赋值\n```\n指针的类型必须与其所指对象的类型一致，但是有两个**例外**。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：\n+ 指针：常量\n+ 指针指向的对象：可以是非常量\n```c++\ndouble dval = 3.14;\t//对象：非常量\ncptr = &dval;\t//指针：常量\n```\n和常量引用一样，指向常量的指针没有规定其所指对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值能不能通过其他途径改变。\n\n### const指针\n+ 指向常量的指针（pointer to const）：const int\\*ptr = &pi: 指针变量保存的内存地址是可以修改的，指针变量所指向的内存也是允许读取数据的，但是我们不能修改指针变量里面所指向的内存里面的数据。**底层const：**指针所指的对象是个常量。\n\n+ 常量指针（const pointer）：int \\*const ptr= &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。常量指针必须初始化，初始化一旦完成，则它的值（存放在指针中的地址）就不能再改变了。**顶层const：**指针本身就是一个常量。\n\n+ 指向常量的常量指针：const int \\*const ptr = &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存是允许读取数据的，我们不可以修改指针变量里面所指向的内存里面的数据。**既是顶层const又是底层const：**指针本身是个常量，而且他所指的对象也是常量。\n```c++\nint main() {\n    int number1 = 233;\n    int number2 = 666;\n    \n    //指向常量的指针（pointer to const）\n    const int *pointer =  &number1;\n\t\tpointer = &number2;\t//可以修改指针变量保存的地址\n    *pointer = 666;\t//错误，不能修改指针变量里面所指向的内存里面的数据\n    \n    //常量指针（const pointer）\n    int *const pointer2 = &number1;\n    pointer2 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //可以修改指针变量里面所指向的内存里面的数据\n    \n    //指向常量的常量指针\n    const int *const pointer3 = &number1;\n    pointer3 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //错误，不可以修改指针变量里面所指向的内存里面的数据\n    \n}\n```\n执行拷贝时，常量是顶层const还是底层const区别明显。其中顶层const（常量指针）不受什么影响。但是底层const（指向常量的指针）的限制不容忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以赋值给常量，反之不行。","tags":["C++"]},{"title":"傅立叶变换在图像处理的应用","url":"/2020/05/09/傅立叶变换在图像处理的应用/","content":"**傅立叶**：任何连续的周期信号，可以由一组适当的正弦曲线组合而成。（Any univariate function can be rewritten as a weighted sum of sines and cosines of different frequencies.）\n\n---\n一个恰当的比喻是将傅立叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅立叶变换可以看作数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑时，讨论他的光谱或频率谱。同样，傅立叶变换使我们能通过频率成分来分析一个函数。\n\n---\n\n<iframe height=300 width=300 src=\"https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif\"></iframe>\n\n---\n\n## 用一个例子解释一维傅立叶变换\n\n我们一般描述一个函数都是基于时间域，如图所示表示了这个函数随时间变化的变化（x轴是时间的变化，y轴是（信号）强度的变化）。\t\n![timedomain](timedomain.JPG)\n但是其实还有一种方法也可以描述这个函数，就是频率域。就比如上图中的函数可以写成\nf(x) = 3sin(0.8x) + 7sin(0.3x) + 2sin(0.2x)\n的形式。就是相当于给了频率为0.8, 0.3和0.2的sin函数不同的权重并把它们加起来。所以也可以由下图来表示。\n![frequencedomain](frequencedomain1.JPG)\n![frequencedomain](frequencedomain2.JPG)\n虽然两张图看起来截然不同，但是他们表述的是同种东西，而傅立叶变换就是描述这种从时域到频率域的变换。\n当然也要考虑相位的变化。\n![phase](phase.JPG)\n\n---\n\n## 傅立叶变换在二维图像处理中的应用\n\n![DFT](dft.png)\n傅立叶变换在二维图像处理中想法与之前一维类似，图像处理中的傅立叶变换是基于二维矩阵，如图所示，x轴和y轴共同表示图像中的位置，z轴表示每个位置（像素点）的灰度值。\n![imagedomain](imagedomain.JPG)\n\n和之前的一维函数相比较可以得出对应关系：\n\n|一维函数|二维图像|\n|---|---|\n|时间|距离|\n|信号强度|灰度值|\n\n---\n\n\n### 傅立叶变换的特点\n\n图像DFT(离散傅立叶变换)的基本属性是其周期性和复共轭对称性。频谱以周期N在两个方向上无止境地重复，即F（u，v）= F（u + kN，v + lN）其中k，l∈[-∞，...，-1，0，1， 2，...，∞]。从具有2D DFT的N×N图像计算出的傅立叶系数F（u，v）的N×N块是此无限序列的单个周期\n![equation](equation.png)\n注意看这里对于频率域的每个点（u，v）都需要时间域所有点的相关信息。\n\n### 二维图像中傅立叶变换的原理\n二维的sin波动可以用如下公式表述：\n*z = a sin(ux+vy)*\nz是波的高度（强度）。\na是幅值，表示波的最高高度。\nu是波浪在x方向上重复的次数（x方向上的频率）。\nv是波浪在y方向上重复的次数（y方向上的频率）。\n如图所示，当v=0的时候，sin的波只在x轴方向波动，当u=0的时候，sin的波只在y轴方向波动，如果u和v都不为0，那么就会在xy叠加方向以角度u/v波动（比如对角线方向）。\n![waves](waves.png)\n如下图，把每个像素点上述的波叠加起来，然后这些波会相互抵消，相互叠加。\n![waves_overlay](waves2.png)\nu是波浪在x方向上重复的次数（x方向上的频率），它可以是1，2，3... \t1表示单位距离内在x方向上重复1次，2表示单位距离内在x方向上重复2次...\n比如，f（2，2）这个像素，它的灰度值在x方向上以sin波波动了3次，在y方向上以sin波波动了4次，那么它在频率域对于点F（3，4）就有一点贡献。F（u，v）的值就是这张图内所有像素点贡献值之和，就是在那个x方向u频率和y方向的v频率的sin波动的强度大小的矢量和。F(3，4)那点的亮度就是表示了整张图的所有像素点在x方向上以频率3灰度的波动和在y方向上以频率4灰度的波动之和的强度（能量大小）。在频率域上的中心点（0，0）表示在x和y方向上都没有波动，它的值是所有灰度值和的平均值。所以在频率域中，中间是低频率，外部是高频率。\n\n### 二维图像傅立叶变换在opencv中的实现\n```\nimport cv2 as cv\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimg = cv.imread('messi5.jpg',0) # 读入图片\nf = np.fft.fft2(img) # 用np自带功能把图片进行傅立叶变换\nfshift = np.fft.fftshift(f) # 调换象限，中心化处理\nmagnitude_spectrum = 20*np.log(np.abs(fshift)) #因为进行变换之后是复数，所以要取绝对值，用log函数是为了能把变换后的图像显示的更加清楚。\nplt.subplot(121),plt.imshow(img, cmap = 'gray') #subplot第一个数字是行数，第二个列数，第三个是index\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()\n```","tags":["图像处理"]},{"title":"二分法","url":"/2020/05/06/二分法/","content":"\n首先二分法只适用于已经排序过的数组。\n二分法的思想就是通过每次排除一半的数列，在剩余一半的数组中查找目标值并返回其所在的位置。相比于直接查找二分法的效率更高，其时间复杂度是O(log2n)。\n\n---\n\n### python代码实现：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return \"Target is not in the list.\"\n```\n\n### 用例子解释为什么循环执行的条件是left<=right：\n[3，8，15，21，35，54，63，79，82，92，97] #目标数列\n0     1      2     3      4      5       6     7      8       9     10 #目标数列的序号\n\n**第一轮**：\nleft_index = 0,  right_index = 10,  mid_index = (0+10)/2 = 5, taget = 87\n\n**第二轮**：\nleft_index = 0 < right_index = 10\nmid = 54<87\n所以left_index = mid_index+1 = 5+1 = 6\nmid_index = (6+10)/2 = 8所以mid对应的值是82\n\n**第三轮**\nleft_index = 6 < right_index = 10\nmid = 82<87\n所以left_index = mid_index+1= 8+1 = 9\nmid_index = (9+10)/2 = 9所以mid对应的值是92\n\n**第四轮**\nleft_index = 9 < right_index = 10\nmid = 92>87(Target value)\n所以right_index = mid_index-1 = 9-1 = 8\n\n**第五轮**\nleft_index = 9 **>** right_index = 8\n不满足while循环跳出\n\n---\n\n## 题目\n### leetcode 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n---\n\n这道题目可以用二分法查找元素，但是多出了如果被查找元素不在给定数列内，要把它插在合适的位置的要求。\npython解法的代码：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return left\n```\n只需要把最后的return \"Not in the list\"改成return left就行。\n**为什么最后改成return left就行**：\n从之前举的例子可以看出，在执行到第五轮的时候，将会跳出循环，此时，left和right的值都是要比查找值target大，所以才会跳出循环导致无法查找，所以这意味着此时只要返回left的index就可以了，就相当于把此时的left向后移动一位插入这个需要被查找的元素。\n\n### leetcode 69. x 的平方根\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n\n---\npython解法的代码\n```\ndef mySqrt(x):                              \n    left = 0                                \n    right = x                               \n    while left <= right:                    \n        mid = (left + right) // 2           \n        if mid ** 2 <= x < (mid + 1) ** 2:  \n            return mid                      \n        if mid ** 2 > x:                    \n            right = mid - 1                 \n        if (mid + 1) ** 2 <= x:             \n            left = mid + 1                         \n```\n思路和之前很相似，确定什么时候可以返回刚好是根号数，就是在这个数的平方小于或等于x的时候以及这个数加一的平方大于x的时候，有了这个限制条件就可以写代码了。因为另外两种情况下就正好在mid的左半边和mid的右半边进行寻找。","tags":["算法与数据结构"]},{"title":"相机标定(Camera Calibration)","url":"/2020/05/03/相机标定-Camera-Calibration/","content":"## 为什么需要相机标定\n+ 建立相机成像几何模型：通过拍摄得到的图片来重建3D现实，计算机视觉的首要任务就是要通过拍摄到的图像信息获取到物体在真实三维世界里相对应的信息，于是，建立物体从三维世界映射到相机成像平面这一过程中的几何模型就显得尤为重要，而这一过程最关键的部分就是要得到相机的内参和外参。\n\n\n+ 矫正透镜畸变：我们最开始接触到的成像方面的知识应该是有关小孔成像的，但是由于这种成像方式只有小孔部分能透过光线就会导致物体的成像亮度很低，于是聪明的人类发明了透镜。虽然亮度问题解决了，但是新的问题又来了：由于透镜的制造工艺，会使成像产生多种形式的畸变，于是为了去除畸变（使成像后的图像与真实世界的景象保持一致），人们计算并利用畸变系数来矫正这种像差。虽然理论上可以设计出不产生畸变的透镜，但其制造工艺相对于球面透镜会复杂很多，所以相对于复杂且高成本的制造工艺，人们更喜欢用数学来解决问题。\n## 坐标系\n+ **世界坐标系(world coordinate system)**：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。\n\n\n\n+ **相机坐标系(camera coordinate system)**：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位为m。\n\n\n\n+ **图像坐标系(image coordinate system)**：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 单位为m。\n\n\n\n+ **像素坐标系(pixel coordinate system)**：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。单位为个（像素数目）。\n\n### 四个坐标系之间的关系\n![coordinates](coordinates.jpg)\n\n世界坐标系：Xw、Yw、Zw。相机坐标系： Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。\n\n\n\n其中，相机坐标系的 轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点，相机坐标系与图像坐标系之间的距离为焦距f（也即图像坐标系原点与焦点重合）。像素坐标系平面u-v和图像坐标系平面x-y重合，但像素坐标系原点位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。\n\n## 相机模型\n\n首先我们知道物体本身是不发光的，我们所看到的有颜色的物体都是都是物体反射太阳或其他光源基于大脑的色觉系统所产生的。而相机就是基于人类的色觉系统所制造成的。比如下图的我们眼中的绿巨人浩克，多条不同方向的光线在他身上反射后会被右侧相机的光学传感器所接收。\n![Hulk](Hulk.png)\n\n如果不对这些光线做处理，绿巨人身上的每一点都会作用于光学传感器上的每一个像素，产生如下图的效果。\n![green](green.png)\n\n很显然，这并不是我们想要的结果，所以人们就想到如果能把多余的反射光线遮住，使得实物上的每一点和相机上的每一个像素相对应，由此就得出来最简单的单孔相机（pinhole）模型，如下图所示。\n\n![pinhole](pinhole.png)\n\n得到了简单的单孔模型之后，我们又引出了焦距（focus length）的概念，根据相似的定义可以知道焦距越小所得到图像也越小，而且是和实物上下颠倒。\n\n![focus length](focuslength.png)\n\n因为单孔模型会遮掉很多多余的反射光线，使得光线的利用率不高，所以为了提高光线的利用率我们想到可以把带小孔的遮光板换成透镜，这样既可以提高光线的利用率，又可以满足我们之前的要求。\n\n![lens](lens.png)\n\n---\n\n## 相机矩阵\n","tags":["图像处理"]}]
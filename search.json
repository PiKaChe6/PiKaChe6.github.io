[{"title":"C++Primer第八章笔记（IO库）","url":"/2020/11/15/C-Primer第八章笔记（IO库）/","content":"\n# IO库\n\n+ istream(输入流)类型，提供输入操作。\n+ ostream（输出流）类型，提供输出操作。\n+ cin，一个istream【对象】，从标准输入读取数据\n+ cout，一个ostream【对象】，向标准输出写入数据\n+ cerr，一个ostream【对象】，通常用于输出程序错误消息，写入到标准错误。\n+ \\>>运算符，用来从istream对象读取输入数据\n+ \\<<运算符，用来向一个ostream对象写入输出数据\n+ getline函数，从一个给定的istream读取一行数据，存入一个给定的string对象中。\n\n## IO类\n\n| 头文件   |                      类型                      |\n| :------- | :--------------------------------------------: |\n| iostream |         istream, wistream 从流读取数据         |\n|          |         ostream, wostream 向流写入数据         |\n|          |           iostream，wiostream 读写流           |\n| fstream  |       ifstream, wifstream 从文件读取数据       |\n|          |       ofstream, wofstream 向文件写入数据       |\n|          |           fstream，wfstream 读写文件           |\n| sstream  | istringstream, wistringstream 从string读取数据 |\n|          | ostringstream, wostringstream 向string写入数据 |\n|          |     stringstream，wstringstream 读写string     |\n\n\n宽字符版本的IO类型和函数的名字以 `w` 开始，如 `wcin`、`wcout` 和 `wcerr` 分别对应 `cin`、`cout`和`cerr`。它们与其对应的普通 `char` 版本都定义在同一个头文件中，如头文件 *fstream* 定义了 `ifstream` 和 `wifstream` 类型。\n\n通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用，这是通过 继承机制（inheritance） 实现的。\n\n### IO对象无拷贝或赋值\n\n【不能拷贝或对IO对象赋值】。\n\n```c++\nofstream out1, out2;\nout1 = out2;    \t\t\t// 错误：不能对流对象赋值\nofstream print(ofstream);   // 错误：不能初始化ofstream参数\nout2 = print(out2);     \t// 错误：不能拷贝流对象\n```\n\n由于IO对象不能拷贝，因此不能将函数形参或返回类型定义为流类型。进行IO操作的函数通常以【引用方式】传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的【引用不能是 const 的】。\n\n#### 条件状态 \n\nIO操作一个与生俱来的问题是可能发生错误。一些错误是可恢复的，而其他错误则发生在系统深处，已经超出了应用程序可以修正的范围。\n\nIO库条件状态：\n\n```c++\nint ival;\ncin >> ival;\n\n//如果输入Boo，读取操作就会产生错误。因为期待读入一个int，却得到了一个字符B。\n\n//最简单的优化方法是将它当作一个条件来使用\nwhile (cin >> word)\n  //ok:读取操作成功\n\n```\n\n`badbit` 表示系统级错误，如不可恢复的读写错误。通常情况下，一旦 `badbit` 被置位，流就无法继续使用了。在发生可恢复错误后，`failbit` 会被置位，如期望读取数值却读出一个字符。如果到达文件结束位置，`eofbit` 和 `failbit` 都会被置位。如果流未发生错误，则 `goodbit` 的值为0。如果 `badbit`、`failbit` 和 `eofbit` 任何一个被置位，检测流状态的条件都会失败。\n\n`good` 函数在所有错误均未置位时返回 `true`。而 `bad`、`fail` 和 `eof` 函数在对应错误位被置位时返回 `true`。此外，在 `badbit` 被置位时，`fail` 函数也会返回 `true`。因此应该使用 `good` 或 `fail` 函数确定流的总体状态，`eof` 和 `bad` 只能检测特定错误。\n\n【流对象（cin）】的 `rdstate` 成员返回一个 `iostate` 值，表示流的当前状态。`setstate` 成员用于将指定条件置位（叠加原始流状态）。`clear` 成员的无参版本清除所有错误标志；含参版本接受一个 `iostate` 值，用于设置流的新状态（覆盖原始流状态）。\n\n```c++\n// 记住cin的当前状态\nauto old_state = cin.rdstate();     // 记住cin的当前状态\ncin.clear();    \t\t\t// 使cin有效\nprocess_input(cin);     \t// 使用cin\ncin.setstate(old_state);    // 将cin置为原有状态\n```\n\n### 管理输出缓冲\n\n每个输出流都管理一个【缓冲区】，用于保存程序读写的数据。\n\n导致缓冲刷新（即数据真正写入输出设备或文件）的原因有很多：\n\n- 程序正常结束。\n- 缓冲区已满。\n- 使用操纵符（如 `endl`）显式刷新缓冲区。\n- 在每个输出操作之后，可以用 `unitbuf` 操纵符设置流的内部状态，从而清空缓冲区。默认情况下，对 `cerr` 是设置 `unitbuf` 的，因此写到 `cerr` 的内容都是立即刷新的。\n- 一个输出流可以被关联到另一个流。这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。默认情况下，`cin` 和 `cerr` 都关联到 `cout`，因此，读 `cin` 或写 `cerr` 都会刷新 `cout` 的缓冲区。\n\n`flush` 操纵符刷新缓冲区，但不输出任何额外字符。`ends` 向缓冲区插入一个空字符，然后刷新缓冲区。\n\n```c\ncout << \"hi!\" << endl;   // 输出hi和一个换行，然后刷新缓冲区\ncout << \"hi!\" << flush;  // 输出hi，然后刷新缓冲区，不附加任何额外字符\ncout << \"hi!\" << ends;   // 输出hi和一个空字符，然后刷新缓冲区\n123\n```\n\n如果想在每次输出操作后都刷新缓冲区，可以使用 `unitbuf` 操纵符。它令流在接下来的每次写操作后都进行一次 `flush` 操作。而 `nounitbuf` 操纵符则使流恢复使用正常的缓冲区刷新机制。\n\n```c\ncout << unitbuf;    // 所有输出操作后都会立即刷新缓冲区\n// 任何输出都立即刷新，无缓冲\ncout << nounitbuf;  // 回到正常的缓冲方式\n123\n```\n\n> 如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后， 它所输出的数据很可能停留在输出缓冲区中等待打印。\n>  \n> 当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则， 可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。\n\n当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。标准库将`cout`和`cin`关联在一起，因此下面的语句会导致`cout`的缓冲区被刷新：\n\n```c\ncin >> ival;\n```\n\n> 关联输入流和输出流的作用：交互式系统通常应该关联输入流和输出流。这意味着包括用户提示信息在内的所有输出，都会在读操作之前被打印出来。\n\n使用 `tie` 函数可以关联两个流。它有两个重载版本：\n\n+ 无参版本返回指向输出流的指针。如果本对象已关联到一个输出流，则返回的就是指向这个流的指针，否则返回空指针。\n+ `tie` 的第二个版本接受一个指向 `ostream` 的指针，将本对象关联到此 `ostream`。`x.tie(&o)`将流x关联到输出流o.\n\n```c\ncin.tie(&cout);     // 仅仅是用来展示：标准库将cin和cout关联在一起\n// old_tie指向当前关联到cin的流（如果有的话）\nostream *old_tie = cin.tie(nullptr); // cin不再与其他流关联\n// 将cin与cerr关联；这不是一个好主意，因为cin应该关联到cout\ncin.tie(&cerr);     // 读取cin会刷新 cerr而不是cout\ncin.tie(old_tie);   // 重建cin和cout间的正常关联\n```\n\n每个流同时最多关联一个流，但多个流可以同时关联同一个 `ostream`。向 `tie` 传递空指针可以解开流的关联。\n\n## 文件输入输出\n\n头文件 *fstream* 定义了三个类型来支持文件IO：`ifstream` 从给定文件读取数据，`ofstream` 向指定文件写入数据，`fstream` 可以同时读写指定文件。\n\n| 代码                    |                             含义                             |\n| :---------------------- | :----------------------------------------------------------: |\n| fstream fstrm;          |  创建未绑定的文件流。fstream是头文件fstream中定义的一个类型  |\n| fstream fstrm(s);       | 创建一个fstream,并打开名为s的文件。s可以是string类型，或者是c风格字符串的指针。这些构造函数都是explicit的。默认的文件模式mode依赖于fstream的类型 |\n| fstream fstrm(s, mode); |          与前一个构造函数类似，但按指定mode打开文件          |\n| fstrm.open(s)           | 打开名为s的文件，并将文件与fstrm绑定。s可以是一个string或者一个指向c风格字符串的指针。默认的文件mode依赖于fstream的类型。返回void |\n| fstrm.close()           |               关闭与fstrm绑定的文件。返回void                |\n| fstrm.is_open()         | 返回一个bool值，指出与fstrm关联的文件是否成功打开且尚未关闭  |\n\n### 使用 文件流 对象\n\n当我们想要读写一个文件时，可以定义一个文件流对象，并将文件与对象关联起来。每个文件流类型都定义了`open`函数，它完成一些系统操作，定位指定文件，并视情况打开为读或写模式。\n\n创建文件流对象时，如果提供了文件名（可选），`open` 会被自动调用。\n\n```c\nifstream in(ifile);   \t// 定义了一个【输入流】in对象，它被初始化为从文件读取数据，文件名由string类型的参数ifile指定。\nofstream out;   \t\t// 定义了输出流out，输出文件流未关联到任何文件\n```\n\n在C++11中，文件流对象的文件名可以是 `string` 对象或C风格字符数组。旧版本的标准库只支持C风格字符数组。\n\n#### 用fstream代替iostream&\n\n在要求使用基类对象的地方，可以用继承类型的对象代替。因此一个接受 `iostream` 类型引用或指针参数的函数，可以用对应的 `fstream` 类型来调用。如果有一个函数接受了一个ostream&参数，我们在调用这个函数时，可以传递给它一个ofstream对象。\n\n#### 成员函数open和close\n\n可以先定义空文件流对象，再调用 `open` 函数将其与指定文件关联。如果 `open` 调用失败，`failbit` 会被置位。\n\n```c++\nifstream in(ifile);\t\t\t//构筑一个ifstream并打开给定文件\nofstream out;\t\t\t\t\t\t//输出文件流未与任何文件相关联\nout.open(ifile + \".copy\");\t\t//打开指定文件\nif(out)\t\t\t\t//检查open是否成功，如果open失败，条件为假\n  \t\t\t\t\t\t//open成功，我们可以使用文件了\n```\n\n\n\n一旦一个文件流已经打开，它就保持与对应文件的关联。对一个已经打开的文件流调用 `open` 会失败，并导致 `failbit` 被置位。随后试图使用文件流的操作都会失败。如果想将文件流关联到另一个文件，必须先调用 `close` 关闭当前文件，再调用 `clear` 重置流的条件状态（`close` 不会重置流的条件状态）。\n\n```c++\nin.close();  //关闭文件\nin.open(iflie + \"2\");\t//打开另一个文件\n```\n\n如果open成功，则open会设置流的状态，使得good（）为true。\n\n```c++\nfor (auto p = argv + 1; p != argv + argc; ++p){\n  ifstream input(*p);\t//创建输出流并打开文件\n  if (input){\t\t\t\t//如果文件打开成功，“处理”此文件\n    progress(input);\n  }else\n    cerr << \"coulden't open: \" + string(*p);\n}// 每个循环步input（因为input是while循环的局部变量）都会离开作用域，因此会被销毁\n```\n\n\n\n> 当 `fstream` 对象被销毁时，`close` 会自动被调用。\n\n\n\n```c++\n// 编写函数，以读模式打开一个文件，将其内容读入到一个string的vector中，将每一行作为一个独立的元素存于vector中\n# include<fstream>\nusing std::ifstream;\nint main(){\n  ifstream in(\"/Users/jhyouergen/Desktop/test.md\");\n  vector<string>v1;\n  string s;\n  //如果想要保留空格（空白符）读取，就要用getline()，getline只要一遇到换行符就结束读取操作并返回结果。\n\twhile(getline(in, s))\n    v1.push_back(s);\n  for (auto i: v1){\n    cout<<i<<endl;\n  }\n}\n\n//将每个单词作为一个独立元素进行储存\nwhile(in>>s) //如果写入成功，会返回true\n  v1.push_back(s);\n//string对象会自动忽略开头空白并从第一个真正字符开始读起，直到遇到下一处空白位置。比如输入是\" Hello World \"读入的就是Hello。\n```\n\n---\n\n#### 看看ifstream的作用原理\n\nSales_record.md文件如下内容\n\nxxx 5 10\nyyq 10 20\n\n\n\n```c++\nifstream in(\"/Users/jhyouergen/Desktop/Sales_record.md\");\n//把全部文件读取到in流中\nstring s,z;\nint i,o;\nin >> s >> i >> o >> z; //in流把内容赋予给变量必须保持in流中的数据类型和变量的数据类型一致\n//此时“in”stream流中的前四个内容“xxx”，“5”，“10”，“yyq”就已经用掉了，此时“in”stream中就只剩下10， 20！\ncout<< s <<i << o <<z; //输出s：xxx， i：5， o：10， z：yyq\nint p;\nin >> p; //此时p等于10！\nif(in) //当in流中还有内容时为true；当in流中无内容时为false。\n```\n\n### 文件格式\n\n每个流都有一个关联的文件模式，用来指出如何使用文件。\n\n| 代码          | 含义                         |\n| ------------- | ---------------------------- |\n| in            | 以读的方式打开               |\n| out           | 以写的方式打开               |\n| app（append） | 每次写操作前均定位到文件末尾 |\n| ate           | 打开文件后立即定位到文件末尾 |\n| trunc         | 截断文件                     |\n| binary        | 以二进制方式进行打开         |\n\n+ 调用open打开文件\n+ 用一个文件名初始化流（ifstream in(ifile)）来隐式打开文件也可以\n\n指定文件模式有如下限制：\n\n- 只能对 `ofstream` 或 `fstream` 对象设定 `out` 模式。\n- 只能对 `ifstream` 或 `fstream` 对象设定 `in` 模式。\n- 只有当 `out` 被设定时才能设定 `trunc` 模式。\n- 只要 `trunc` 没被设定，就能设定 `app` 模式。在 `app` 模式下，即使没有设定 `out` 模式，文件也是以【输出】方式打开。\n- 默认情况下，即使没有设定 `trunc`，以 `out` 模式打开的文件也会被截断。如果想保留以 `out` 模式打开的文件内容，就必须同时设定 `app` 模式，这会将数据追加写到文件末尾；或者同时设定 `in` 模式，即同时进行读写操作。\n- `ate` 和 `binary` 模式可用于任何类型的文件流对象，并可以和其他任何模式组合使用。\n- 与 `ifstream` 对象关联的文件默认以 `in` 模式打开，与 `ofstream` 对象关联的文件默认以 `out` 模式打开，与 `fstream` 对象关联的文件默认以 `in` 和 `out` 模式打开。\n\n每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与 `ifstream` 关联的文件默认以 `in` 模式打开；与 `ofstream` 关联的文件默认以 `out` 模式打开；与 `fstream` 关联的文件默认以 `in` 和 `out` 模式打开。\n\n#### 以out模式打开文件会丢失已有数据\n\n默认情况下，打开 `ofstream` 对象时，文件内容会被丢弃，阻止一个 `ofstream` 清空给定文件内容的方法是同时指定 `app` 模式：\n\n```c++\nofstream out(\"file1\");//隐含以输出模式打开文件并截断文件\nofstream out2(\"file1\", ofstream::out);// 隐含地截断文件\nofstream out3(\"file1\", ofstream::out | ofstream::trunc);\n//显式地截断文件\n\n//为了保留文件内容，我们必须显式指定app模式\nofstream app(\"file2\", ofstream::app);//隐含为输出模式\nofstream app2(\"file2\", ofstream::out | ofstream::app);\n```\n\n\n\n【流对象】每次打开文件时都可以改变其文件模式。\n\n```c++\nofstream out;   \t\t\t// 未指定文件打开模式\nout.open(\"scratchpad\");    \t// 模式隐含设置为输出和截断\nout.close();    \t\t\t// 关闭out，以便我们将其用于其他文件\nout.open(\"precious\", ofstream::app);   // 模式为out和app\nout.close();\n```\n\n> 保留 被 `ofstream` 打开的文件 中已有数据 的唯一方法是显式指定 `app` 或 `in` 模式。\n\n## string流\n\n头文件 *sstream* 定义了三个类型来支持内存IO：`istringstream` 从 `string` 读取数据，`ostringstream` 向 `string` 写入数据，`stringstream` 可以同时读写 `string` 的数据。\n\n| 代码            | 含义                                                         |\n| --------------- | ------------------------------------------------------------ |\n| sstream strm;   | strm是一个未绑定的stringstream对象。sstream是头文件sstream中定义的一个【类型】 |\n| sstream strm(s) | strm是一个sstream对象，保存string s的一个拷贝。此构造函数是explicit的 |\n| strm.str()      | 返回strm所保存的string的拷贝                                 |\n| strm.str(s)     | 将string s拷贝到strm中。返回void                             |\n| strm.clear()    | 将strm清空                                                   |\n\n### 使用istringstream(主要作用就是把一行string分成单个单词进行输出/保存)\n\n当某些工作是对整行文本进行处理， 而其他一些工作是处理【行内的单个单词】时，通常可以使用 `istringstream`。\n\n一个文件列出了一些人和他们的电话号码。\n\nmorgan 2015552368 8625550123\ndrew 9735550130\nlee 6095550132 2015550175 8005550000\n\n```c++\n// 成员默认为公有\nstruct PersonInfo\n{\n    string name;\n    vector<string> phones;\n};\n\n\nstring line, word;   // 分别保存来自输入的一行和单词\nvector<PersonInfo> people;    // 保存来自输入的所有记录\n// 逐行从输入读取数据，直至cin遇到文件尾（或其他错误）\nwhile (getline(cin, line)) //\n{\n    PersonInfo info;    \t\t\t// 创建一个保存此记录数据的对象\n    istringstream record(line);    \t// 将记录绑定到刚读入的行\n    record >> info.name;    \t\t// 自动读取空格前的字符并传入info.name变量\n    while (record >> word)  \t\t// 读取电话号码，当读完line时，内层while循环就结束了。\n        info.phones.push_back(word);   // 保持它们\n    people.push_back(info);    \t\t// 将此记录追加到people末尾\n}\n```\n\n编写程序，将来自一个文件中的行保存在一个vector<string>中。然后使用一个istringstream从vector读取元素，每次读取一个单词。\n\n```c++\nint main(){\n    ifstream in(\"/Users/jhyouergen/Desktop/Sales_record.md\");\n    string line;\n    vector<string> v1;\n    while (getline(in, line)) { \n      //把Sales__record文件中的内容逐行读入\n        v1.push_back(line);\n    }\n\n    for (auto i:v1){\n        istringstream record(i);\n        string s;\n        while(record >> s){\n          //把每行中的单词逐个输出\n            cout<<s<<endl;\n        }\n    }\n\n}\n```\n\n### 使用ostringstream\n\n当逐步构造输出， 希望最后一起打印时， `ostringstream` 是很有用的。\n\n+ 如果号码都是有效的，我们希望输出一个新的文件，包含改变格式后的号码。\n+ 对于那些无效的号码，我们不会将它们输出到新文件中，而是打印一条包含人名和无效号码的错误信息。\n\n由于我们不希望输出有无效号码的人，因此对每个人，直到验证完成所有电话号码后才可以进行输出操作。但是，我们可以先将输出内容“写入”到一个内存ostringstream中：\n\n```c++\nfor (const auto &entry : people)\n{ \n\t// 对people中每一项，每一项都是PersonInfo类型\n    ostringstream formatted, badNums;   \t\n  // 每个循环步创建的对象\n    for (const auto &nums : entry.phones)\n    { \n    \t// 对每个数\n        if (!valid(nums)) // valid函数负责完成号码的验证\n        {\n            badNums << \" \" << nums;  \t\t\n          // 将数的字符串形式存入badNums\n        }\n        else\n            // 将格式化的字符串\"写入\"\n            formatted << \" \" << format(nums);\n    }\n    if (badNums.str().empty())   \t\t\t// 没有错误的数\n        os << entry.name << \" \"  \t\t\t// 打印名字\n            << formatted.str() << endl;   \t// 和格式化的数\n    else  // 否则，打印名字和错误的数\n        cerr << \"input error: \" << entry.name\n            << \" invalid number(s) \" << badNums.str() << endl;\n}\n```\n\n","tags":["-C++"]},{"title":"C++Primer第七章笔记（类）","url":"/2020/11/12/C-Primer第七章笔记（类）/","content":"\n# 类\n\n+ 定义抽象数据类型\n+ 访问控制与封装\n+ 类的其他特性\n+ 类的作用域\n+ 构造函数再探\n+ 类的静态成员\n\n## 定义抽象数据类型\n\n### 设计Sales_data类\n\n`Sales_item` 类有一个名为 `isbn` 的 **成员函数（member function）**， 并且支持 `+ 、= 、+= 、<< 和 >>` 运算符。\n\n`Sales_data` 的接口应该包含以下操作：\n\n- 一个 `isbn` 成员函数，用于返回对象的 `ISBN` 编号\n- 一个 `combine` 成员函数，用于将一个 `Sales_data` 对象加到另一个对象上\n- 一个 `add` 的函数，执行两个 `Sales_data` 对象的加法\n- 一个 `read` 函数，将数据从 `istream` 读入到 `Sales_data` 对象中\n- 一个 `print` 函数， 将 `Sales_data` 对象的值输出到 `ostream`\n\n### 定义改进的Sales_data\n\n**成员函数（member function）** 的声明必须在类的内部，定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数(和类无关的函数)，它们的定义和声明都在类的外部。\n\n```c++\nstruct Sales_data\n{   \n    string isbn() const{return bookNo;}\n    Sales_data& combine(const Sales_data&);\n    double avg_price() const;\n    \n    \n    string bookNo;\n    unsigned units_sold = 0;\n    double revenue = 0.0;\n\n    \n};\n//Sales_data的非成员接口函数\n//为什么在参数部分要使用类的引用作为形参类型：\n//因为在函数内要改变这个类的具体内容，而不只是拷贝这个类，所以要用引用\nSales_data add(const Sales_data&, const Sales_data&);\nstd::ostream &print(std::ostream&, const Sales_data&);\nsrd::istream &read(std::istream&, Sales_data&);\n```\n\n**定义在类内部的函数是隐式的inline函数**\n\n#### 引入const成员函数\n\n` string isbn() const{return bookNo;}`此处const的含义。\n\n可以等价理解为\n\n`string isbn(const Sales_data*const this){return bookNo;}`\n\n`this通过一个对象调用一个函数，那个对象的地址就是this（this就是一个指针`),在c++中所有的成员函数都有this作为隐藏参数。\n\n默认情况下，this的类型是指向类 类型非常量 版本的常量指针（自己的地址无法改变），意味着不能把this绑定到一个**常量对象**，所以不能在一个常量对象上调用普通的成员函数。 \n\nC++允许在成员函数的参数列表后面添加关键字 `const`，表示 `this` 是一个指向常量的指针。使用关键字 `const` 的成员函数被称作 **常量成员函数（const member function）**。\n\n因为this是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，isbn可以读取调用它的对象的数据成员，但是不能写入新值。\n在函数体内都只是读取数据成员的值，而不会做任何改变。\n\n`常量对象，以及常量对象的引用或指针都只能调用常量成员函数（在函数的参数列表后面添加关键字const的函数）`\n\n成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的顺序。\n\n### 在类的外部定义成员函数\n\n类外部定义的成员的名字必须包含他所属的类名：\n\n```c++\ndouble Sales_data::avg_price()const{\n  if (units_sold)\n    return revenue/units_sold;\n  else\n    return 0;\n}\n```\n\n当使用revenue和units_sold时，实际上它隐式地使用了Sales_data的成员。\n\n### 定义一个返回this对象的函数\n\n```c++\nSales_data& Sales_data::combine(const Sales_data &rhs){\n  units_sold += rhs.units_sold; //把rhs的成员加到this对象的成员上\n  revenue += rhs.revenues;\n  return *this;\n}\n```\n\n### 定义类相关的非成员函数(不能通过 类.函数(total.isbn()) 来运用的函数)\n\n辅助函数：比如add、read和print等。尽管这些函数定义的操作从概念上来说属于类的接口组成部分，但它们实际上并不属于类本身。\n\n通常把函数的声明和定义分开来。如果函数在概念上属于类但是不定义在类中，则函数的声明应该与类在同一个头文件中。\n\n1. read函数：将数据从istream读入到Sales_data对象中去\n   `if(read(cin,total))` ==>等于`if(cin>>total.bookNo>>total.units_sold>>cin>>total.revenue)`\n\n```c++\n//接受IO类型的应用作为参数，因为IO类型不能被拷贝，因此我们只能通过引用来传递他们，而且因为读写都会改变流的内容，所以两个函数接受的都是普通引用，而非对常量的引用。\nistream &read(istream &is, Sales_data &item){\n\tdouble prince = 0;\n\tis >> item.bookNo >> item.units_sold << price;\n\titem.revenue = price * item.units_sold;\n\treturn is;\n}\n```\n\n2. print函数:负责将给定对象的内容打印到给定的流中 \n\n`print(cout, total)<<endl;`==>等价于\n`cout<<total.isbn()<<\" \"<<item.units_sold<<\" \"<<item.revenue<<\" \"<<item.avg_prince();\n\n```c++\nostream &print(ostream &os, const Sales_data &item){\n\tos<<item.isbn()<<\" \"<<item.units_sold<<\" \"   \t\t<<item.revenue<<\" \"<<item.avg_price();\n\treturn os;\n}\n```\n\n3. add函数\n\n```c++\nSales_data add(const Sales_data &lhs, const Sales_data &rhs){\n\tSales_data sum = lhs;\n\tsum.combine(rhs);\n\treturn sum;\n}\n\n```\n\n### 构造函数\n\n类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做构造函数。\n\n构造函数的名字和类名相同。构造函数没有返回类型。\n\n构造函数不能被声明成const。当我们创建类的const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量属性”。因此，构造函数在const对象的构造过程中可以向其写值。\n\n#### 默认构造函数\n\n如果类没有显示地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。默认构造函数无需任何实参。\n\n+ 如果存在类内的初始值，用它来初始化成员\n\n+ 否则，默认初始化该成员\n\n+ 如果类内包含有内置类型或者复合类型（指针）的成员，则只有当这些成员全部都人为被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。\n\n1. 默认构造函数`Sales_data() = default`\n2. `Sales_data(const std::string &s):bookNo(s){}`\n   `Sales_data(const std::string &s, unsigened n, double p):bookNo(s), units_sold(n), revenue(p*n){}`\n\n在冒号和冒号和花括号之间的部分（:bookNo(s), units_sold(n), revenue(p*n)）是构造函数初始值列表，他负责为新创建的对象的一个或几个数据成员赋初始值。把s赋给bookNo, n赋给units_sold, p\\*n赋给revennue。\n\n上面的函数体是空的，因为构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数题也就为空了。\n\n3. 以istream为参数的构造函数需要执行一些实际的操作。（在类的外部定义构造函数）因为read（）函数在类的外部\n\n```c++\nSales_data::Sales_data(std::istream &is){\n\tread(is, *this); //read函数的作用是从is中读取一条交易信息然后存入this对象中\n}\n\n//\nSales_data total(cin);//把输入的内容（cin）给到total的构造函数，构造函数会用read函数把cin读入的内容初始化给total的bookNo，units_sold和revenue\nif (cin){\n\tSales_data trans(cin);//把输入的内容（cin）给到trans的构造函数\n\twhile (read(cin, trans))\n\tif (total.isbn() == trans.isbn()){\n\ttotal = add(total, trans);\n\t\t}\n```\n\n用this来吧对象当成一个整体访问，而非直接访问某个成员。在这里我们使用\\*this将“this”对象作为实参传递给read函数。\n\n### 拷贝、赋值和析构\n\n如果不主动对类的对象进行拷贝、赋值和销毁，那编译器将替我们完成。\n\n```c++\ntotal = trans;\n//它的行为与下面的代码相同\ntotal.bookNo = trans.bookNo;\ntotal.units_sold = trans.units_sold;\ntotal.revenue = trans.revenue;\n```\n\n如果类包含vector或者string成员，则其拷贝、赋值和销毁的合成版能够正常工作。\n\n## 访问控制与封装\n\n+ 定义在public说明符之后的成员在整个程序内可被访问，public成员定义类的接口。\n\n+ 定义在private说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，private部分封装了（即隐藏了）类的实现细节。(在类的外部无法使用total.bookNo; 如果bookNo是private性质的话)\n\n一般来说，作为接口的一部分，\n\n构造函数和一部分成员函数应该定义在 public 说明符之后，\n而数据成员和作为实现部分的函数则应该跟在 private 说明符之后\n\n### 使用class或struct关键字\n\n+ 如果我们使用struct关键字，则定义在第一个访问说明符之前（默认的）的成员是public的\n+ 如果我们使用class关键字，则定义在第一个访问说明符之前（默认的）的成员是private的\n\n### 友元\n\n如果Sales_data的数据成员是private的，那么read、print、add函数无法正常编译了，因为尽管这几个函数是类的接口的一部分，但他们不是类的成员。\n\n类可以允许其他类或者函数访问它的非公有元素(private部分)，方法是令其它类或者函数称为它的友元。\n\n```c++\nstruct Sales_data\n{\nfriend istream& read(istream& is, Sales_data& item);\nfriend ostream& print(ostream& os, const Sales_data& item);\nfriend Sales_data add(Sales_data& item1, Sales_data& item2);\npublic:\n    Sales_data(istream& is);\n    string isbn() const{return bookNo;}\n    Sales_data& combine(const Sales_data& rhs){\n        units_sold += rhs.units_sold;\n        revenue += rhs.revenue;\n        return *this;\n    }\n\n\nprivate:\n    string bookNo;\n    unsigned units_sold = 0;\n    double revenue = 0.0;\n\n\n};\nistream& read(istream& is, Sales_data& item);\nostream& print(ostream& os, const Sales_data& item);\nSales_data add(Sales_data& item1, Sales_data& item2);\n```\n\n## 类的其他特性\n\n由类定义的**类型名字（typedef string::size_type pos）**和其他成员一样存在访问限制，可以是 `public` 或 `private` 中的一种。\n\n```c++\nclass Screen \n{\npublic:\n\ttypedef std::string::size_type pos;\nprivate:\n\tpos cursor = 0;\n\tpos height = 0, width = 0;\n\tstd::string contents;\n\n// *******************\n\npublic:\n    // 使用类型别名等价地声明一个类型名字\n    using pos = std::string::size_type;\n    // 其他成员与之前的版本一致\n};\n```\n\n定义在类内部的成员函数是自动内联的。\n\n如果需要显式声明内联成员函数，建议只在类外部定义的位置说明 `inline`。\n\n> 和我们在头文件中定义 `inline` 函数的原因一样，`inline` 成员函数也该与类定义在同一个头文件中。\n\n成员函数也可以被重载\n\n#### 可变数据成员\n\n使用关键字 `mutable` 可以声明 **可变数据成员（mutable data member）**。可变数据成员永远不会是 `const` 的，即使它在 `const` 对象内。因此 `const` 成员函数可以修改可变成员的值。\n\n```c++\nclass Screen \n{\npublic:\n    void some_member() const;\nprivate:\n    mutable size_t access_ctr;  // 即使在一个const对象内也能被修改\n    // 其他成员与之前的版本一致\n};\nvoid Screen::some_member() const\n{\n    ++access_ctr;   // 保存一个计数值，用于记录成员函数被调用的次数\n    // 尽管some_member是一个const成员函数（常量成员函数不能改变调用它的对象的内容），但是access_ctr是个可变成员，因此任何成员函数，包括const函数在内都能改变它的值\n}\n```\n\n提供类内初始值时，必须使用 `=` 或花括号形式。\n\n### 返回\\*this的成员函数\n\n```c++\nScreen &set(char c){\n  contents[cursor] = c; //设置当前光标所在位置的新值\n  return *this;\t\t//将this对象作为左值返回\n}\n\nmyScreen.set('#')\n//为什么这个函数的返回类型是Screen（类）的引用& 而不是Screen类型？\n//因为如果定义返回类型不是引用，那么set返回值将是*this的副本，而不是*this本身，那么我们想要设置该光标位置所在的值就不是对于myScreen这个对象来设置，而是对它的副本来设置了\n```\n\n> const 成员函数如果以引用形式返回 *this，则返回类型是常量引用。\n\n+ 非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用const成员函数。\n+ 虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的选择。\n\n```c++\nclass Screen \n{\npublic:\n    // 根据对象是否是const重载了display函数\n    Screen &display(std::ostream &os)\n    { do_display(os); return *this; }\n    const Screen &display(std::ostream &os) const\n    { do_display(os); return *this; }\n    \nprivate:\n    // 该函数负责显示Screen的内容\n    void do_display(std::ostream &os) const\n    { os << contents; }\n    // 其他成员与之前的版本一致\n};\n\nScreen myScreen(5,3);\t\t\t\t//myscreen是非常量对象\nconst Screen blank(5, 3);\t\t//blank是常量对象\nmyScreen.set('#').display(cout);    //调用非常量版本\nblank.display(cout);    \t\t\t//调用常量版本\n\n\n```\n\n### 类类型\n\n每个类定义了唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。\n\n我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，也可以把类名跟在关键字 `class` 或 `struct` 后面：\n\n```cpp\nSales_data iteml;\t\t\t// 默认初始化Sales_data类型的对象\nclass Sales_data iteml;\t\t// 一条等价的声明\n```\n\n可以仅仅声明一个类而暂时不定义它。这种声明被称作 **前向声明（forward declaration）**，用于引入类的名字。在类声明之后定义之前都是一个 **不完全类型（incomplete type）**。\n\n```cpp\nclass Screen;   // Screen类的声明\n```\n\n不完全类型只能在非常有限的情景下使用：\n\n- 可以定义指向不完全类型的指针或引用，\n- 也可以声明（不能定义）以不完全类型作为参数或返回类型的函数。\n\n必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间。因为只有当类全部完成后才算被定义，所以一个类的成员类型不能是该类本身。\n\n但是一旦类的名字出现，就可以被认为是声明过了，因此类可以包含指向它自身类型的引用或指针。\n\n```cpp\nclass Link_screen\n{\n    Screen window;\n    Link_screen *next;\n    Link_screen *prev;\n};\n\n```\n\n### 友元再探\n\n除了普通函数，类还可以把 【其他类】 或【其他类的成员】 函数声明为友元。此外， 友元函数能定义在类的内部， 这样的函数是隐式内联的。\n\n友元类的成员函数可以访问此类包括非公有成员在内的所有成员。\n\n```cpp\nclass Screen \n{\n    // Window_mgr的成员可以访问Screen类的私有部分\n    friend class Window_mgr;\n    // Screen类的剩余部分\n};\n```\n\n> 每个类负责控制自己的友元类或友元函数\n\n把其他类的成员函数声明为友元时，必须明确指定该函数所属的类名。\n\n如果类想把一组重载函数声明为友元，需要对这组函数中的每一个分别声明。\n\n```c++\nstruct X\n{\n    friend void f() { /* 友元函数可以定义在类的内部 */ }\n    X() { f(); }   // 错误：f还没有被声明\n    void g();\n    void h();\n};\n\nvoid X::g() { return f(); }     // 错误：f还没有被声明\nvoid f();   \t\t\t\t\t// 声明那个定义在x中的函数\nvoid X::h() { return f(); }     // 正确：现在f的声明在作用域中了\n\n```\n\n## 类的作用域\n\n一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须提供类名和函数名。在类的外部，成员的名字被隐藏起来了。\n\n当成员函数定义在类外时，返回类型中使用的名字位于类的作用域之外，此时返回类型必须指明它是哪个类的成员。\n\n函数的返回类型通常出现在函数名之前。因此当成员函数定义在类的外部时，返回类型中使用名字都位于类的作用域之外。这时，返回类型必须指明它是哪个类的成员。\n\n```c++\nclass Window_mgr{\n  public:\n  ScreenIndex addScreen(const Screen&)\n};\n//首先处理返回类型，之后我们才进入Window_mgr的作用域\nWindow_mgr::ScreenIndex //注意这之后没有分号\nWindow_mgr::addScreen(const Screen &s){\n  screen.push_back(s);\n  return screens.size() - 1;\n}\n```\n\n#### 名字查找与作用域\n\n> 编译器处理完类中的全部声明后才会处理成员函数的定义。\n\n成员函数体直到整个类可见后才会被处理，因此它能使用类中定义的任何名字。\n\n声明中使用的名字，包括返回类型或参数列表，都必须确保使用前可见。\n\n- 如果某个成员的声明使用了类中尚未出现的名字，编译器将会在定义该类的作用域中继续查找。\n- 如果类的成员使用了外层作用域的某个名字，而该名字表示一种类型，则类不能在之后重新定义该名字。\n\n\n```c++\ntypedef double Money;\nclass Account\n{\npublic:\n    Money balance() { return bal; } // 使用外层作用域的Money\nprivate:\n    typedef double Money; \t\t\t// 错误：不能重新定义Money\n    Money bal;\n    // ...\n};\n```\n\n成员函数中名字的解析顺序：\n\n- 在成员函数内查找该名字的声明，只有在【函数使用之前】出现的声明才会被考虑。\n- 如果在成员函数内没有找到，则会在类内继续查找，这时会考虑类的所有成员。\n- 如果类内也没有找到，会在成员函数定义之前的作用域查找。\n\n```c++\n// 注意：这段代码仅为了说明而用，不是一段很好的代码\n// 通常情况下不建议为参数和成员使用同样的名字\nint height;   // 定义了一个名字，稍后将在Screen中使用\nclass Screen\n{\npublic:\n    typedef std::string::size_type pos;\n    void dummy_fcn(pos height)\n    {\n        cursor = width * height;  // 哪个height? 是那个参数\n    }\nprivate:\n    pos cursor = 0;\n    pos height = 0, width = 0;\n};\n\n\n```\n\n尽管类的成员被隐藏了，但我们仍然可以通过加上类的名字或显式地使用 `this` 指针来强制访问成员。\n\n```c++\n// 不建议的写法：成员函数中的名字不应该隐藏同名的成员\nvoid Screen::dummy_fcn(pos height) \n{\n    cursor = width * this->height;  \t// 成员height\n    // 另外一种表示该成员的方式\n    cursor = width * Screen::height;  \t// 成员height\n}\n\n// 建议的写法：不要把成员名字作为参数或其他局部变量使用variable(不要使用相同的名字命名多个参数)\nvoid Screen::dummy_fcn(pos ht) \n{\n    cursor = width * height;  \t\t\t// 成员height\n}\n\n\n```\n\n```c++\nType Exercise::setVal(Type parm) { \n    val = parm + initVal();  //此处使用的是类内的initVal函数\n    return val;\n}\n```\n\n总结：看到 Exercise(类)::setVal(Type parm) 给它说明了这个函数是来自于类Exercise的，那么表示函数内所有的东西（形参，函数内的变量都是用的是这个类定义的参数）。但是最初的的Type没有指定是哪个作用域的，所以是全局的参数。\n\n## 构造函数再探\n\n### 构造函数初始值列表\n\n```cpp\nclass ConstRef\n{\npublic:\n    ConstRef(int ii);\nprivate:\n    int i;\n    const int ci;\n    int &ri;\n};\n\n//构造函数的两种写法 \n//1. 先默认初始化，再重新赋值给这些变量\nConstRef::ConstRef(int ii){\n  i = ii;   \t//正确\n  ci = ii;\t  //错误，ci已经被默认初始化为0，不能给const int再赋值，再改变一个const参数的值\n  ri = i;\t\t\t//错误，ri是一个引用，默认初始化的时候没有给它绑定对象，没有被初始化，产生错误。\n}\n\n\n//2. 直接初始化变量\n//正确：显式地初始化引用和const成员\nConstRef::ConstRef(int ii): i(ii), ci(ii), ri(i) { };\n```\n\n> 尽量使用 2.直接初始化变量的形式建立构造函数，避免产生错误。\n\n> 最好令构造函数初始值的顺序与成员声明的顺序一致，并且尽量避免使用某些成员初始化其他成员。\n\n> 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。\n\n初始化顺序只与数据成员在类中出现的次序有关，而与初始值列表的顺序无关。\n\n```c++\nstruct X {\n\tX (int i, int j): base(i), rem(base % j) {}\n\tint rem, base;\n};\n```\n\n在类 `X` 中，两个数据成员出现的顺序是 `rem` 在前，`base` 在后，所以当执行 `X` 对象的初始化操作时先初始化 `rem`。如上述代码所示，初始化 `rem` 要用到 `base` 的值，而此时 `base` 尚未被初始化，因此会出现错误。该过程与构造函数初始值列表中谁出现在前面谁出现在后面没有任何关系。\n\n修改的方法很简单，只需要把变量 `rem` 和 `base` 的次序调换即可，形式是：\n\n```cpp\nstruct X {\n\tX (int i, int j): base(i), rem(base % j) {}\n\tint base, rem;\n};\n```\n\n### 委托构造函数\n\nC++11扩展了构造函数初始值功能，可以定义 委托构造函数（delegating constructor）。委托构造函数使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些(或者全部)职责委托给了其他构造函数。\n\n```c++\nclass Sales_data\n{\npublic:\n    // 非委托构造函数使用对应的实参初始化成员\n    Sales_data(std::string s, unsigned cnt, double price):\n    \tbookNo(s), units_sold(cnt), revenue(cnt*price) {  }\n    // 其余构造函数全都委托给另一个构造函数\n   Sales_data():Sales data(\"\", 0, 0) {  }\n\t Sales_data(std::string s):Sales_data(s, 0, 0) {  }\n\t Sales_data(std::istream &is):Sales data() { read(is, *this); }\n    // 其他成员与之前的版本一致\n}\n\n\n```\n\n默认构造函数\n\n当对象被默认初始化或值初始化时会自动执行默认构造函数。\n就是在类内为构造函数准备好了实参。如果某个构造函数包含若干形参，但是同时为这些形参都提供了默认实参，则该构造函数也具备默认构造函数的功能。\n\n默认初始化的发生情况：\n\n- 在块作用域内不使用初始值定义非静态变量或数组。\n- 类本身含有类类型的成员且使用合成默认构造函数。\n- 类类型的成员没有在构造函数初始值列表中显式初始化。\n\n值初始化的发生情况：\n\n- 数组初始化时提供的初始值数量少于数组大小。\n- 不使用初始值定义局部静态变量。\n- 通过 `T()` 形式（*T* 为类型）的表达式显式地请求值初始化。\n\n类必须包含一个默认构造函数。\n\n> 在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。\n\n对于类来说编译器是不会默认初始化一个类的\n\n```c++\nclass NoDefalut{\npublic:NoDefalut(int a):val(a){} //NoDefault类无默认构造函数\n    int val;\n};\nclass C{\npublic:\n    NoDefalut nd;\n    C(int i = 0): nd(i){} //在这里C的构造函数赋予实参0，作为C的默认构造函数！\n};\n```\n\n#### 4）隐式的类类型转换\n\n如果构造函数【只接受一个实参】，则它实际上定义了转换为此类类型的隐式转换机制。这种构造函数被称为 **转换构造函数（converting constructor）**。\n\n> 能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。\n\n```c++\n//combine 函数的定义\nSales_data& combine(const Sales_data& rhs){\n        units_sold += rhs.units_sold;\n        revenue += rhs.revenue;\n        return *this;\n    }\n\n\nstring null_book = \"9-999-99999-9\";\n//构造一个临时的Sales_data对象\n//该对象的units_sold和revenue等于0，bookNo等于null_book\nitem.combine(null_book);//编译器用给定的string自动创建了一个Sales_data对象。新生成的这个（临时）Sales_data对象被传递给combine。\n```\n\n编译器只会自动执行一步类型转换。\n\n```cpp\n// 错误：需要用户定义的两种转换。\n// (1) 把\"9-999-99999-9\"转换成string\n// (2) 再把这个(临时的)string转换成Sales_data\nitem.combine(\"9-999-99999-9\");\n// 正确：显式地转换成string，隐式地转换成Sales_data\nitem.combine(string(\"9-999-99999-9\"));\n// 正确: 隐式地转换成string，显式地转换成Sales_data\nitem.combine(Sales_data(\"9-999-99999-9\"));\n```\n\n在要求隐式转换的程序上下文中，可以通过将【构造函数】声明为 `explicit` (清楚的)的加以阻止。\n\n```cpp\nclass Sales_data\n{\npublic:\n    Sales_data() = default;\n    Sales_data(const std::string &s, unsigned n, double p):\n        bookNo(s), units_sold(n), revenue(p*n) { }\n    explicit Sales_data(const std::string &s): bookNo(s) { }\n    explicit Sales_data(std::istream&);\n    // 其他成员与之前的版本一致\n};\n\n\nitem.combine(null_book);//错误：string构造函数是explicit的\nitem.combine(cin);//错误: istream的构造函数是explicit的\n```\n\n`explicit` 关键字只对接受一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 `explicit` 的。只能在类内声明构造函数时使用 `explicit`关键字，在类外定义时不能重复。\n\n执行拷贝初始化时（使用 `=`）会发生隐式转换，所以 `explicit` 构造函数只能用于直接初始化。\n\n```c++\nSales_data item1 (null_book);   // 正确: 直接初始化\n\nSales_data item2 = null_book;\t// 错误：不能将explicit构造函数用于拷贝形式的初始化过程\n```\n\n> 当我们用 `explicit` 关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。\n\n尽管编译器不会将 `explicit` 的构造函数用于隐式转换过程，可以使用 `explicit` 构造函数显式地强制转换类型。\n\n```cpp\n// 正确: 实参是一个显式构造的Sales_data对象\nitem.combine(Sales_data(null_book));\n// 正确：static_cast可以使用explicit的构造函数\nitem.combine(static_cast<Sales_data>(cin));\n```\n\n### 聚合类\n\n聚合类使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下【所有条件】时，我们说它是聚合的：\n\n+ 所有成员都是public\n\n+ 没有定义任何构造函数\n\n+ 没有类内初始值\n\n+ 没有基类，也没有virtual函数\n\n下面的类是一个聚合类：\n\n```cpp\nstruct Data\n{\n    int ival;\n    string s;\n};\n```\n\n可以使用一个用花括号包围的成员初始值列表初始化聚合类的数据成员。【初始值顺序必须与声明顺序一致】。如果初始值列表中的元素个数少于类的成员个数，则靠后的成员被值初始化。\n\n```cpp\n// val1.ival = 0; val1.s = string(\"Anna\")\nData val1 = { 0, \"Anna\" };\n\n// 错误：不能使用\"Anna\"初始化ival，也不能使用1024初始化s\nData va12 = { \"Anna\", 1024 };\n```\n\n### 字面值常量类\n\n数据成员都是字面值类型的【聚合类】是字面值常量类（字面值类型：算术类型、指针、引用，不是字面值类型的有：IO库、String类型 ）。或者一个类不是聚合类，但符合下列全部条件，则也是字面值常量类：\n\n- 数据成员都是字面值类型。\n- 类至少含有一个 `constexpr` 【构造函数】。\n- 如果数据成员含有类内初始值，则内置类型成员的初始值必须是常量表达式。如果成员属于类类型，则初始值必须使用成员自己的 `constexpr` 构造函数。\n- 类必须使用析构函数的默认定义。\n\n`constexpr` 构造函数用于生成 `constexpr` 对象以及 `constexpr` 函数的参数或返回类型。\n\n`constexpr` 构造函数必须初始化所有数据成员，初始值使用 `constexpr` 构造函数或常量表达式。\n\n## 类的静态成员\n\n使用关键字 `static` 可以声明类的静态成员，可以是 `public` 的或 `private` 的，静态数据成员的类型可以是常量、引用、指针、类类型等等。\n\n```cpp\nclass Account\n{\npublic:\n    void calculate() { amount += amount * interestRate; }\n    static double rate() { return interestRate; }\n    static void rate(double);\nprivate:\n    std::string owner;\n    double amount;\n    static double interestRate;\n    static double initRate();\n};\t\n```\n\n静态成员存在于任何对象之外，对象中不包含与静态成员相关的数据。因此，每个Account对象将包含两个数据成员：owner和amount。只存在一个interestRate对象而且它被所有Account对象共享。\n\n类似的， 静态成员函数也不与任何对象绑定在一起。\n由于静态成员不与任何对象绑定，因此静态成员函数不能声明为 `const` 的，也不能在静态成员函数内使用 `this` 指针。\n\n用户代码可以使用作用域运算符访问静态成员，也可以通过类对象、引用或指针访问。类的成员函数可以直接访问静态成员。\n\n```c++\ndouble r;\nr = Account::rate(); // 使用作用域运算符访问静态成员\n\nAccount ac1;\nAccount *ac2 = &ac1;\n// 调用静态成员函数rate的等价形式\nr = ac1.rate(); \t// 通过Account的对象或引用\nr = ac2->rate(); \t// 通过指向Account对象的指针\n\n//成员函数不用通过作用域运算符就能直接使用静态成员\nclass Account\n{\npublic:\n    void calculate() { amount += amount * interestRate; }\nprivate:\n    static double interestRate;\n    // 其他成员与之前的版本一致\n};\n\n```\n\n在类外部定义静态成员时，不能重复 `static` 关键字，其只能用于类内部的声明语句。\n\n> 和类的所有成员一样，当我们指向类外部的静态成员时，必须指明成员所属的类名。`static`关键字则只出现在类内部的声明语句中。\n\n由于静态数据成员不属于类的任何一个对象，因此它们并不是在创建类对象时被定义的。通常情况下，不应该在类内部初始化静态成员。【而必须在类外部定义并初始化每个静态成员】。一个静态成员只能被定义一次。一旦它被定义，就会一直存在于程序的整个生命周期中。\n\n```cpp\n// 定义并初始化一个静态成员\ndouble Account::interestRate = initRate();\n```\n\n> 建议把静态数据成员的定义与其他非内联函数的定义放在同一个源文件中，这样可以确保对象只被定义一次。\n\n尽管在通常情况下，不应该在类内部初始化静态成员。但是可以为静态成员提供 `const` 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 `constexpr`。\n\n初始值必须是常量表达式，因为这些成员本身就是常量表达式， 所以它们能用在所有适合于常量表达式的地方。\n\n```cpp\nclass Account\n{\npublic:\n    static double rate() { return interestRate; }\n    static void rate(double);\nprivate:\n    static constexpr int period = 30;  // period是常量表达式\n    double daily_tbl[period];\n};\n```\n\n> 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。\n\n静态成员独立于任何对象。\n\n特别的， 静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用：\n\n```cpp\nclass Bar\n{\npublic:\n\t// ...\nprivate:\n    static Bar mem1;   \t// 正确：静态成员可以是不完全类型\n    Bar *mem2;    \t\t// 正确：指针成员可以是不完全类型\n    Bar mem3;   \t\t// 错误：数据成员必须是完全类型\n};\n```\n\n静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参。\n\n```cpp\nclass Screen\n{\npublic:\n    // bkground表示一个在类中稍后定义的静态成员\n    Screen& clear(char = bkground);\nprivate:\n    static const char bkground;\n};\n```\n\n非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分， 这么做的结果是无法真正提供一个对象以便从中获取成员的值， 最终将引发错误。","tags":["C++"]},{"title":"C++Primer第六章笔记（函数）","url":"/2020/11/06/C-Primer第六章笔记/","content":"\n#  函数\n\n+ 函数基础\n+ 参数传递\n+ 返回类型和return语句\n+ 函数重载\n+ 特殊用于语言特性\n+ 函数匹配\n+ 函数指针\n\n## 函数基础\n\n函数包括:\n\n+ 返回类型\n+ 函数名字\n+ 形参（parameter）\n  通过调用运算符来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针：圆括号之内是一个用逗号隔开的实参（argument）列表，我们用实参初始化的形参。调用表达式的类型就是函数的返回类型。\n\n### 函数的形参列表\n\n函数的形参列表可以为空，但是不能省略。想要定义一个不带形参的函数，最常用的办法是书写一个空的形参列表。不过为了与c语言兼容，也可以使用void关键字表示函数没有形参：\n\n+ void f1（） // 隐式的定义了空形参列表\n+ void f2（void）//显式的定义了空形参列表\n  形参列表中通常是用逗号隔开，其中每个形参都是含有一个声明符的声明。即使两个形参的类型一样，也必须把两个类型都写出来：\n  int f3\\*(int v1, v2)  //错误\n  int f4\\*(int v1, int v2) //正确\n  任意两个形参名都不能相同，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。\n\n### 函数的返回类型\n\n大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。函数的返回类型**不能是数组类型或函数类型**，但可以是指向数组或函数的指针。\n\n### 局部对象\n\n在c++语言中名字有作用域，对象有生命周期\n\n+ 名字的作用域是程序文本的一部分，名字在其中可见\n+ 对象的生命周期是程序执行过程中该对象存在的一段时间\n  形参和函数体内部定义的变量称为**局部变量**。它们对函数而言是局部的，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他声明中。\n\n在所有函数体之外定义的**对象**存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束时被销毁。局部变量的生命周期依赖于定义的方式。\n\n### 自动对象\n\n我们把只存在于块执行期间的对象称为**自动对象**。当块的执行结束后，块中创建的自动对象的值就变成为定义的了。\n\n形参是一种自动对象。函数开始时为形参申请储存空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。\n\n### 局部静态对象\n\n某些时候，有必要令**局部变量的生命周期贯穿函数调用以及之后的时间**。可以将局部变量定义成static类型从而获得这样的对象。**局部静态对象**在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。**函数结束之后，局部静态对象依然存在**\n\n```c++\nsize_t count_calls()\n{\t\n\tstatic size_t ctr = 0;\n\treturn ++ctr; \n}\n\nint main(){\n\tfor(size_t i =0; i !=10; ++i)\n\t\tcout<<count_calls()<<endl;\n\treturn 0;\n}\n\n```\n\n这段程序将输出从1到10的数字。如果ctr不是static变量的话，那么将输出10个1。\n\n如果局部静态变量没有显式的初始值，它将执行值初始化，内置类型的局部静态变量初始化为0。\n\n\n### 函数声明\n\n类似于变量，函数只能定义一次，但是可以申明多次。\n\n函数的声明和函数的定义非常类似，唯一的区别是函数申明无需函数体，用一个分号代替即可。\n\n```c++\nvoid print(vector<int>::const_iterator beg, vector<int>::const_iterator end);\n```\n\n函数的三要素（返回类型、函数名、形参类型）描述了函数的接口，说明了调用函数所需要的全部信息。函数声明也称作**函数原型**。\n\n### 在头文件进行函数声明\n\n于变量类似，函数也应该在头文件中声明而在原文件中定义。\n\n定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。\n\n**含有函数声明的头文件应该被包含到定义函数的源文件中。**\n\n声明函数就是告诉这个文件，我这里会用到这些函数，但是函数的具体定义却要定义在源文件中。\n\n比如编写一个名为Chapter6.h的头文件。\n\n```c++\n#ifndef C___PRIMER_EX_CHAPTER6_H\n#define C___PRIMER_EX_CHAPTER6_H\nint f2(int i);\nint calc(int v1, int v2);\ndouble square(double x);\n#endif //C___PRIMER_EX_CHAPTER6_H\n```\n\n### 分离式编译\n\n分离式编译允许我们把程序分割到几个文件中去，每个文件独立编译。这一过程通常会产生后缀名是 .obj（Windows） 或 .o（UNIX） 的文件，该文件包含 对象代码（object code）。之后编译器把对象文件 链接（link） 在一起形成可执行文件。\n**头文件是连接主函数程序，和多个函数库程序的桥梁，所以要在主函数程序和库函数程序中都include 头文件，使他们建立联系。**\n\n#### 编译和连接多个源文件\n\n假设fact\n\n+ **函数的定义**位于一个名为fact.cc的文件中\n+ 它的**声明**位于名为Chapter6.h的头文件中\n  显然与其他所有用到fact函数的文件一样，fact.cc应该包含Chapter6.h的头文件。\n+ 在名为factMain.cc的文件中创建main函数，main函数将调用fact函数。\n\nfact.cpp文件\n\n```\n#include \"Chapter6.h\"\nint fact(int ival){\n    int ret = 1;\n    while (ival !=1){\n        ret*=ival;\n        ival--;\n    }\n    return ret;\n}\n```\n\nChapter6.h头文件\n\n```c++\n#ifndef C___PRIMER_EX_CHAPTER6_H\n#define C___PRIMER_EX_CHAPTER6_H\nint fact(int ival);\n#endif //C___PRIMER_EX_CHAPTER6_H\n```\n\nfactMain.cpp文件\n\n```c++\n#include<iostream>\n#include \"Chapter6.h\"\nusing std::cout;\nint main()\n\n{\n    cout<<fact(4)<<endl;\n}\n```\n\n## 参数传递\n\n每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。\n\n形参的类型决定了形参和实参交互的方式。如果形参是引用类型，它将绑定到对应的实参上。否则，将实参的值拷贝后赋给形参。\n\n+ 当形参是引用类型时，我们说它对应的实参被**引用传递**或者函数被**传引用调用**。和其他引用一样，引用形参是它绑定的对象的别名，也就是说，引用形参是它对应的实参的别名。\n\n+ 当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被**值传递**或者函数**传值调用**\n\n\n### 传值参数\n\n当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。\n\n### 指针形参\n\n指针的行为和其他非引用类型一样。当执行指针拷贝时，拷贝的是指针的值，拷贝之后，两个指针是不同的指针。因为指针可以使我们间接的访问它所指的对象，所以通过指针可以修改它所指对象的值。\n\n```c++\nint n = 0, i = 42;\nint *p = &n, *q = &i; //p指向n，q指向i\n*p = 42;\t//n的值改变；p不变\np = q； //p指向了i；但是i和n的值都不改变\n```\n\n指针的形参行为与之类似：\n\n```c++\n// 该函数接受了一个指针，然后将指针所指的值置为0\nvoid reset(int *ip){\n\t*ip = 0; //解引用，改变了ip所指对象的值\n\tip = 0;\t//只改变了ip的局部拷贝，实参并未改变\n}\n```\n\n调用reset函数之后，实参所指的对象被置为0，但是实参本身并没有改变。\n\n```c++\nint i = 42;\nreset(&i); //改变i的值而非i的地址\ncout<<\"i=\"<<i<<endl; //输出i = 0\n```\n\n### 引用传参 指针穿参\n\n引用传参\n\n```c++\nvoid Swap(int& v1, int& v2){\n    int v3;\n    v3 = v2;\n    v2 = v1;\n    v1 = v3;\n}\n```\n\n指针传参\n\n```c++\nvoid Swap(int* v1, int* v2){\n    int v3;\n    v3 = *v2;\n    *v2 = *v1;\n    *v1 = v3;\n}\n```\n\n### 传引用参数\n\n通过使用引用形参，允许函数改变一个或多个实参的值。\n下面是使用引用形参的好处：\n\n#### 1.使用引用避免拷贝，提高程序效率\n\n拷贝大的类类型对象或者容器（比如说string）对象比较低效，甚至有的类类型（包括IO类型在内）根本就不支持拷贝操作。当某种类型不支持拷贝操作时，函数只能通过**引用形参**访问该类型对象。\n**当函数无需修改引用形参的值时最好使用常量引用。**\n\n#### 2. 使用引用形参返回额外信息（同时返回多个值成为可能）\n\n一个函数只能返回一个值，然而有时函数需要同时返回多个值，引用形参为我们一次返回多个值提供了有效的途径。\n\n自己定义一个find_char函数，它返回\n\n+ string对象中某个指定字符第一次出现的位置。\n+ 该字符出现的总次数\n\n方法：\n\n+ 定义一个新的数据类型，让它包含位置和数量两个成员\n+ 给函数传入一个额外的引用实参，令其保存字符出现的次数。这样返回的是第一次出现的位置，但是出现的次数的变量也会因为是引用而随之改变。\n\n```c++\n//返回s中c第一次出现的位置索引\nstring::size_type find_char(const string &s, char c, string::size_type &occurs){\n\tauto ret = s.size();\n\toccurs = 0;\n\tfor(decltype(ret)i = 0; i!=s.size(); ++i){\n\tif(s[i] == c){\n\t\tif(ret == s.size())\t\t\t\t\t\t//刚才初始化的时候把ret初始化为了s.size（）所以当ret等于size的时候表明了此时c是第一次出现\n\t\t\tret = i;                \n\t\t++occurs;\n\t}\n\t}\n\treturn ret;\n}\n```\n\n### const形参和实参\n\n如果确定这个形参是个常量，在之后的程序里面不改变的话，要尽量使用**const形参**，因为：\n\n1. 非常量（比如int）不可以初始化常量（const int），但是常量可以初始化非常量。常量作为形参被初始化的范围更广，可以是常量、非常量、字面值。\n2. 让调用者知道，这个形参是个常量。\n\n当形参是const时，当用实参初始化形参时会忽略掉顶层const。形参的顶层const被忽略掉了。当形参有顶层const时，传给他常量对象或者非常量对象都是可以的：\n\n```c++\n\tvoid fcn(const int i){\n\t\tfcn能够读取i，但是不能向i写值\n\t}\n```\n\n调用fcn函数时，既可以传入const int也可以传入int。\n\n！！对const的引用可能引用一个并非const的对象（允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式），但是对非const的引用却不能是const的对象。！！\n\n```c++\nint testfunction(int &val1){\n\treturn val1+1;\n}\nint testfunction(const int &val1){\n\treturn val1+1;\n}\n\nint main(){\n\tconst int a =10;\n\tint b = 20；\n\tcout<<testfunction(a)<<endl;//会报错，因为testfunction的形参非const，所以实参也只能是非const\n\tcout<<testfunction(b)<<endl;//正确，允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式\n}\n```\n\n\n\n#### 指针或引用形参与const\n\n形参的初始化方式和变量的初始化方式一样。我们可以用非常量初始化一个const对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。\n\n```c++\nint i =42;\nconst int *cp = &i; //底层const 地址可以改，但是指针指向的数据不能改\nconst int &r = i; //不能通过r改变i\nconst int &r = 42; // 正确，允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式。\nint *p = cp; //错误：p的类型和cp的类型不匹配 \nint &r3 = r; //错误，r3的类型和r不匹配\nint &r4 = 42; //错误：不能用字面值初始化一个非常量引用\n```\n\n#### 尽量使用常量引用\n\n把函数不会改变的形参定义成（普通）的引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参。此外，使用引用而非 常量引用也会极大地限制函数所能接受的类型，因为不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参。\n比如：\n\n```c++\nstring::size_type find_char(string &s, char c, string::size_type &occurs);\n\n---\n//\t初始化\nfind_char(\"hello world\", 'o', ctr);\n//错喔，因为是string &s，所以不能用字面值初始化\n\n---\n//修改\nstring::size_type find_char(string s, char c, string::size_type &occurs);//不推荐，因为这样要复制整个s对象，如果s太大，降低效率\n\n//或\nstring::size_type find_char(const string &s, char c, string::size_type &occurs);\n```\n\n### 数组形参\n\n数组的特殊性质：\n\n+ 不允许拷贝数组\n+ 使用数组时会将其转换成指针\n\n因为**不能拷贝数组**，所以无法以值传递的方式使用数组参数。因为数组会被转化成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。\n\n尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：\n\n+ 声明为指针\n+ 声明为维度不限的数组\n+ 声明为维度确定的数组\n\n```c++\n//尽管形式不同，但是这三个print函数是等价的\n//每个函数都有一个const int*类型的形参\nvoid print(const int*);\nvoid print(const int[]);\nvoid print(const int[10]);\n```\n\n尽管表现的形式不同，但上面的三个函数是等价的：每个函数的唯一形参都是const int\\*。\n当编译器处理对print函数的调用时，只检查传入的参数是否是const int\\*类型：\n\n```c++\nint i = 0, j[2] = {0, 1};\nprint(&i); //正确：&i的类型是int*\nprint(j); //正确：j转换成int*并指向j[0]\n```\n\n如果我们传给print函数的是一个数组，**则实参自动地转换成指向数组首元素的指针**，数组的大小对函数的调用没有影响。\n\n因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息。**因为你传进来就是一个指向首元素指针，缺少数组长度的信息，这样这样在函数内部就很难操作这个数组。**管理指针形参有三种常用的技术：\n\n#### 1. 使用标记指定数组长度\n\n管理数组实参的第一种方法就是要求数组本身包含一个结束标记，使用这种方法的典型式例是c风格字符串。c风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。函数在处理c风格字符串时遇到空字符串停止：\n\n```c++\nvoid print(const char*cp){\n\tif(cp)\t\t\t\t\t\t\t//若cp不是一个空指针\n\t\twhile(*cp)\t\t\t\t//只要指针所指的字符不是空字符\n\t\t\t\tcout<<*cp++\t\t//输出当前字符并将指针向前移动一个位置\n}\n```\n\n这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况，但是对于像int这样所有取值都是合法值的数据就不太有效了。\n\n#### 2. 使用标准库规范\n\n管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库的启发（类似于迭代器）：\n\n```c++\n//输出beg到end之间（不含end）的所有元素\nvoid print(const int*beg, const int*end){\n\twhile(beg!= end)\n\t\tcout<<*beg++<<endl; //输出当前元素并将指针向前移动一个位置\n}\n```\n\n为了调用这个函数，我们需要传入两个指针：一个指向要输出的首元素，另一个指向尾元素的下一位置：\n\n```c++\nint j[2] = {0, 1};\n//j转换成指向它首元素的指针\n//第二个实参是指向j尾后的指针\nprint(begin(j), end(j));\n```\n\n这里的begin(j)和end(j)是指针\n\n注意⚠️  之前遇到的begin和end：\n\n+ begin成员负责返回指向的第一个元素（或第一个字符）的迭代器。\n+ end成员则负责返回指向容器尾元素的下一个位置的迭代器，也就是说，该迭代器指示的是容器的一个根本不存在的“尾后”元素。\n\n```c++\nauto b = v.begin() //b表示v的第一个元素\nauto e = v.end() //e表示v尾元素的下一个位置\n// b和e的类型相同, v是vector或string\n```\n\n#### 3. 显式传递一个表示数组大小的形参\n\n第三种管理数组实参的方法是专门定义一个表示数组大小的形参：\n\n```c++\nvoid print(const int ia[], size_t size){\n// const int ia[]等价于const int* ia\n//size表示数组的大小，将它显示地传给函数用于控制对ia元素的访问\n\tfor(size_t i = 0; i!= size; ++i){\n\t\tcout<<ia[i]<<endl;\n\t}\n}\n```\n\n#### 数组形参和const\n\n当函数不需要对数组元素执行写操作的时候，数组的形参应该是**指向const的指针**，只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。\n\n#### 数组引用形参\n\nc++语言允许将变量定义成数组的引用，基于同样道理，形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上：\n\n```c++\nvoid print(int (&arr)[10]){\n\tfor(auto elem: arr){\n\t\tcout<<elem<<endl;\n\t}\n}\n```\n\n注意⚠️ &arr两端的括号必不可少\n\n```c++\nf(int &arr[10]) //错误：将arr声明成了含有10个int引用的数组\nf(int (&arr)[10]) //正确：arr是具有10个int整数的整型数组的引用\n```\n\n#### 传递多维数组\n\n多维数组其实是数组的数组。\n将多维数组传递给函数时，真正传递的是指向数组的首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针。数组第二维（以及后面所有的维度）的大小都是数组类型的一部分，不能省略：\n\n```c++\nvoid print(int(*matrix)[10], int rowSize){}\n```\n\n上述语句将matrix声明成指向含有10个整数的数组的指针。\n注意⚠️：\\*matrix两端的括号必不可少\n\n```c++\n\tint *matrix[10];\t//10个指针构成的数组\n\tint (*matrix)[10];\t//指向含有10个整数的数组的指针\n```\n\n也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度，所以最好不要把它包括在形参列表内：\n\n```c++\n//等价定义\nvoid print(int matrix[][10], int rowSize){}\n```\n\nmatrix的声明看起来是一个二维数组，实际上形参是指向含有10个整数的数组的指针。\n\n#### 小例题\n\n编写一个函数，令其交换两个两个int指针。\n\n+ 写法1:\n\n```c++\nvoid swapPointer(int *ptr1, int *ptr2){\n\tint *tmp = ptr1;\n\tptr1 = ptr2;\n\tptr2 = tmp;\n}\n```\n\n错误：用了函数前后 指针的地址以及指针所指的值都没有发生改变。以值传递的方式使用指针，所有改变都局限于函数内部，当函数执行完毕后既不会改变指针本身的值，也不会改变指针所指的内容。\n\n+ 写法2:\n\n```c++\nvoid swapPointer(int *ptr1, int *ptr2){\n\tint tmp = *ptr1; //将tmp初始化为ptr1绑定的值\n\t*ptr1 = *ptr2; //将ptr1指向ptr2绑定的值\n\t*ptr2 = tmp;\n}\n```\n\n用了函数前后 指针的地址没有改变但是**指针所指的值都发生改变**。第二个函数同样以值传递的方式使用指针，但是在函数内部通过解引用的方式直接访问内存并修改了指针的方式。\n\n+ 写法2:\n\n```c++\nvoid swapPointer(int &v1, int&v2){\n\tint tmp = v1;\n\tv1 = v2;\n\tv2 = tmp;\n}\n//使用\nswapPointer(*ptr1, *ptr2);\n```\n\n第三个函数的参数形式是 int\\*&，其含义是，该参数是一个引用，引用的对象是内存中的一个 int 指针，使用这种方式可以把指针当成对象，交换指针本身的值。需要注意的是，最后一个函数既然交换了指针，当然解引用该指针所得的结果也会相应发生改变。\n\n### main：处理命令行选项\n\n到目前为止，我们定义的main函数只有空形参列表\n\n```c++\nint main(){...}\n```\n\n由于main函数不能被其它函数调用， 因此不可能在程序内部取得实际值。那么，在何处把实参值赋予main函数的形参呢? 实际上,**main函数的参数值是从操作系统命令行上获得的**。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数即可把这些实参传送到main的形参中去。\n\n\n然而，有时候我们确实需要给main传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如，假定main函数位于可执行文件prog之内，我们可以传递下面的选项：\n\n```c++\n\tprog -d -o ofile data0\n```\n\n这些命令行选项通过两个（可选的）形参传递给main函数：\n\n```c++\n\tint main(int argc, char *argv []){...}\n```\n\n第二个形参argv是一个数组，它的元素是指向c风格字符串的指针。第一个形参argc表示数组中字符串的数量。因为第二个形参是数组，所以main函数也可以定义成：\n\n```c++\n\tint main(int argc, char **argv){...}\n```\n\n其中argv指向char\\*\n当实参传递给main函数之后，argv的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令提供的实参。最后一个指针之后的元素的值保证为0。\n以上面提供的命令为例，argc应该等于5，argv应该包含如下的c风格字符串：\n\n```c++\nargv[0] = \"prog\";\nargv[1] = \"-d\";\nargv[2] = \"-o\";\nargv[3] = \"ofile\";\nargv[4] = \"data0\";\nargv[5] = 0;\n```\n\n**当使用argv中的实参时，一定要记得可选的实参从argv[1]开始；argv[0]保存程序的名字，而非用户输入**\n\n从而可以得出结论：两个参数中第一个参数argc表示在Dos命令行中的输入的程序名和参数个数之和，第二个参数中argv[0]记录的程序名，后面的argv[i]记录的输入参数。\n\n另外argc argv是标识符，可以修改名称。\n\n\n### 含有可变形参的函数\n\n有时候我们无法提前预知应该向函数传递几个实参。\n\n+ 如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型；\n+ 如果实参的类型不同，我们可以编写一种特殊的函数，也就是所谓的可变参数模版。\n+ 还有一种特殊的形参类型（即参略符），一般用于与c函数交互的接口程序。\n\n#### initializer_list形参\n\n如果所有的实参类型相同，可以传递一个名为initializer_list的标准库类型。inizitializer_list用于表示某种特点类型的值的数组。\n\ninitializer_list提供的操作\n\n```c++\ninitializer_list<T> lst;  //默认初始化；T类型元素的空列表\n\ninizializer_list<T> lst{a, b, c...} //lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素是const\n\nlst2(lst) \nlst2 = lst //两条语句效果一样；拷贝或赋值一个initializer_list对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素\n\nlst.size() //列表中的元素数量\n\nlst.begin() //返回指向lst中首元素的指针\n\nlst.end() //返回指向lst尾元素下一位置的指针\n```\n\n和vector一样，initializer_list也是一种模版类型，定义initializer_list对象时，必须说明列表中所含元素的类型：\ninitializer_list<string> ls // initializer_list的元素类型是string\ninitializer_list<int> li //initializer_list的元素类型是int\n\n和vector不一样的是，initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中元素的值。\n\n我们使用如下的形式输出错误信息的函数，使其可以作用于可变数量的实参：\n\n```c++\nvoid error_msg(initializer_list<string> il){\n\tfor(auto beg = il.begin(); beg != il.end(); ++beg)\n\t\tcout<<*beg<<endl;\n\tcout<<endl;\n}\n```\n\n**如果相向initializer_list形参中传递一个值的序列(多个参数)，则必须把序列放在一对花括号内**：\n\n```c++\n// expected和actual是string对象\nif (expected != actual)\n error_msg({\"functionX\", expected, actual});\nelse\n\terror_msg({\"functionX\", \"okay\"});\n```\n\n在上面的代码我们调用了同一个函数error_msg,但是两次调用传递的参数数量不同；第一次调用穿了3个值，第二次调用只传了两个。\n\n含有initializer_list形参的函数也可以同时拥有其他形参。\n\n```c++\nvoid error_msg(ErrCode e, initializer_lsit<string> il){\n\tcout<<e.msg()<<\": \";\n\tfor(const auto: &elem: il)\n\t\tcout<<elem<<\"\";\n\tcout<<endl;\n}\n```\n\n#### 省略符形参\n\n省略符形参应该仅仅用于C和C++通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。\n\n省略符形参只能出现在列表的最后一个位置，它的形式无外乎以下两种：\t\n\n```c++\n\tvoid foo(parm_list,...)\n\tvoid foo(...)\n```\n\n第一种指定了foo函数部分形参的类型，对应这些形参的实参将会执行正常的类型检查，省略符形参对应的实参无需类型检查。在第一种形式中，形参声明后面的逗号是可选的。\n\n### 返回类型和return语句\n\nreturn语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。return语句由两种形式：\n\n```c++\nreturn;\nreturn expression;\n```\n\n### 返回无值函数\n\n没有返回值return语句只能用在返回类型是void的函数中。返回void的函数不要求非得有return语句，因为在这类函数的最后一句后面会隐士地执行return。\n\n通常情况下，void函数如果想要在中间的位置提前退出，可以使用return语句。return的这种用法有点类似于我们用break语句退出循环。\n\n```c++\nvoid swap(int &v1, int &v2){\n\t//如果两个值是相等的，则不需要交换，直接退出。\n\tif(v1 = v2)\n\t\tretun;\n\tint tmp = v2;\n\tv2 = v1;\n\tv1 = tmp;\n} \n```\n\n#### 有返回值函数\n\n**在含有return语句的循环后面应该也有一条return语句，如果没有的话该程序就是错误的。**\n\n#### 值是如何被返回的\n\n返回一个值的方式和初始化一个变量或形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。\n\n#### 返回引用\n\n同其他引用类型一样，如果函数返回引用，则该引用仅是它所引用对象的一个别名。\n如果看到函数名称前面带有引用符号的话，就表示着，这个函数返回的是一个对象的引用，而这个对象就是跟在return后面的那个对象。这个对象必须是个全局变量而不能是局部变量。\n\n比如某个函数挑出两个string形参中较短的那个并返回其引用：\n\n```c++\n//挑出两个string对象中较短的那个，返回其引用\nconst string &shortString(const string &s1, const string &s2){\n\treturn s1.size() <= s2.size()? s1:s2; //返回的是s1或者是s2的引用，这个s1或s2是输入的实参，是全局变量\n}\n```\n\n其中**形参和返回类型**都是const string的引用，不管是调用函数还是返回结果都不会真正拷贝string对象。\n\n#### 不要返回局部对象的引用或指针\n\n函数完成后，它所占用的储存空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域：\n\n```c++\nconst string &manip(){\n\tstring ret;  //局部对象\n\tif (!ret.empty())\n\t\treturn ret; // 错误：这里返回的是ret的引用，ret是个局部变量！错误，无法返回局部变量的引用。\n\telse\n\treturn \"Empty\"; // 错误：\"Empty\"是一个局部临时量\n}\n```\n\n字符串“Empty”字面值转换成一个局部临时的string对象，如前所诉，返回局部对象的引用是错误的；同样，返回局部对象的指针也是错误的。函数一旦完成，局部对象被释放，指针也将指向一个不存在的对象。\n\n#### 返回 类 类型的函数和调用运算符\n\n如果函数返回指针，引用或类的对象，我们就能使用函数调用的结果访问结果的对象成员。\n\n```c++\n//例如，我们可以通过如下形式得到较短的string对象的长度\n//调用string对象的size成员，该string对象是由shortString函数返回的\nauto sz = shortString(s1, s2).size()\n```\n\n#### 引用返回左值\n\n函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。\n\n```c++\nchar &get_val(string &str, string::size_type ix){\n\treturn str[ix]; \t\t//返回的是str中第ix+1个元素的引用\n}\nint main(){\n\tstring s(\"a value\");\n\tcout<<s<<endl;\n\tget_val(s, 0) = 'A'; //等于s[0] = 'A',函数调用语句在左侧\n\tcout<<s<<endl；\n\treturn 0;\n}\n```\n\n把函数调用放在赋值语句的左侧可能看起来有点奇怪，但是其实没什么特别的。返回值是个引用，因此调用是个左值，和其他左值一样它也能出现在赋值运算符的左侧。\n\n#### 列表初始化返回值\n\n函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。\n\n```c++\nvector<string> process()\n{\n//expected 和actual是string对象\nif (expected.empty())\n\treturn {};\nelse if (expected == actual)\n\treturn {\"functionX\", \"okay\"};\nelse \n\treturn{\"function\", expected, actual};\n}\n```\n\n如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且该值所占空间应该不大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。\n\n#### 主函数main的返回值\n\n我们允许main函数没有return语句直接结束。如果控制达到了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。\n\n#### 递归\n\n如果一个函数调用了它自身，不管调用时直接的还是间接的，都称为递归函数。\n\n```c++\nint factorial(int val){\n\tif(val > 1)\n\t\treturn factorial(val-1)*val;\n\treturn 1;\n}\n```\n\n\n什么时候返回的引用无效，什么情况下返回常量的引用无效\n\n- 如果引用所引的是函数开始之前就已经存在的对象（这个对象是全局变量，而不是局部变量），则返回该引用是有效的；\n- 如果引用所引的是函数的局部变量，则随着函数结束局部变量也失效了，此时返回的引用无效。\n\n### 返回数组指针\n\n因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。\n\n指针是一种复合类型，\nint\\* 是指向int类型的指针。是一种类型\nint\\*ptrs[10];  ptrs是含有10个整型指针的数组。也是一种类型。\nint\\*ptrs[9];  ptrs是含有9个整型指针的数组。也是一种和上面不一样的类型。\nint (*Parray)[10] = &arr; // Parray 指向一个含有10个整型的数组，也是一种类型。\n\n#### 1. 使用类型别名\n\n```c++\n\ttypedef int arrT[10]; //arrT是一个类型别名，它表示的类型是含有10个整数的数组\n\tusing arrT = int[10]; //和上面等价\n\tarrT *func(int i); //func返回一个指向(含有10个整数的数组)的指针\n```\n\n`arrT *func(int i)`理解这一句，把arrT置换成int， `int *func(int i)`函数的返回类型就是一个指向int的指针。而arrT目前的类型就是含有10个整数的数组。\n\n#### 2. 声明一个返回数组指针的函数（直接声明）\n\n要想在声明func时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：\n\n```c++\nint arr[10];\t\t\t\t\t\t//arr是一个含有10个整数的数组\nint *p1[10];\t\t\t\t\t\t//p1是一个含有10个指针的数组\nint (*p2)[10] = &arr;\t\t//p2是一个指针，它指向含有10个整数的数组\n```\n\n和这些声明一样，如果我们想要定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字的后面且形参列表应该先于数组的维度。\n\n```c++\nint (*func(int i))[10];\n```\n\n+ func(int i)表示调用func函数时需要一个int类型的实参。\n\n+ （\\*func(int i)）意味着我们可以对函数调用的结果执行***解引用**操作。\n\n+ （\\*func(int i)）[10]表示解引用func的调用将得到一个大小是10的数组。\n\n+ int （\\*func(int i)）[10]表示数组中的元素是int类型。\n\n  \n\n#### 3. 使用尾置返回类型\n\n任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：\n\n```c++\n//func接受一个int类型的实参，返回一个指针，该指针类型指向含有10个整数的数组\nauto func(int i) -> int(*)[10];\n```\n\n#### 4. 使用decltype\n\n还有一种情况，如果我们知道函数返回的指针将指向那个数组，就可以使用decltype关键字声明返回类型。\n\n```c++\nint odd[] = {1, 3, 5, 7, 9};\nint even[] = {0, 2, 4, 6, 8};\n// 返回一个指针，该指针指向含有5个整数的数组\ndecltype(odd) *arrPtr(int i){\n\treturn (i%2)? &odd:&even; //因为返回的是指针所以这里要有取地址符号！\n}\n```\n\ndecltype并不负责把数组类形转化成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时附加一个*符号。\n\n### 函数重载\n\n如果一个作用域内的几个函数名字相同但是形参列表不同，我们称之为**重载函数**。\n比如：\n\n```c++\n\tvoid print(const char*op);\n\tvoid print(const int *beg, const int *end);\n\tvoid print(const int ia[], size_t size);\n```\n\n当调用这些函数的时候，编译器会根据传递的实参类型推断想要的是哪个函数。\n**main函数不能重载**\n\n#### 定义重载函数\n\n有一种典型的数据库应用，需要创建几个不同的函数分别根据名字、电话、账户号码等信息查找记录。函数重载使得我们可以定义一组函数，它们的名字都是lookup，但是查找的依据不同。我们能通过以下形式中的任意一种调用lookup函数：\n\n```c++\nRecord lookup(const Account&);\t\t//因为是函数的声明，所以没必要给形参添加名字，根据Account查找记录\nRecord lookup(const Phone&);\t\t\t//根据Phone查找记录\nRecord lookup(const Name&);\t\t\t\t//根据Name查找记录\n```\n\n对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。假设有两个函数，他们的形参列表一样但是返回的类型不一样，则第二个声明是错误的：\n\n```c++\nRecord lookup(const Account&);\nbool lookup(const Account&);\t//错误：与上一个函数相比只有返回值的类型不同\n```\n\n#### 重载和const形参\n\n一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来：\n\n```c++\n\tRecord lookup(Phone);\n\tRecord lookup(const Phone); //错误，重复声明了Record lookup\n```\n\n如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const的底层的：\n\n```c++\nRecord lookup(Account&);\t\t\t//函数作用与Account的引用\nRecord lookup(const Account&);  // 新函数，作用于常量引用\n\nRecord lookup(Account*);\t\t\t\t   //新函数，作用于指向Account的指针\nRecord Lookup(const Account*); \t\t\t//新函数，作用于指向常量的指针\n```\n\n因为const不能转化成其他类型，所以我们只能把const对象（或指向const的指针）传递给const形参。相反的，因为非常量可以转换成const，所以上面的四个函数都能作用于非常量对象 或者 指向非常量对象 的指针。\n\n### 重载与作用域\n\n在不同的作用域中无法重载函数名\n\n```c++\nvoid print(const string&);\nvoid print(double);\t//重载print函数\nvoid fooBar(int ival){\n\tvoid print(int); //不好的习惯：通常来说，在局部作用域中声明函数不是一个好的选择\n\t//新作用域：隐藏了之前的print\n\tprint(\"Value: \"); //错误：print(const string&)被隐藏掉了\n\tprint(ival);//正确，当前print（int）可见\n\tprint(3.14);//正确：调用print(int);print(double)被隐藏掉了，这里double类型的实参转化成了int类型，合法调用。\n}\n```\n\n这里就是在fooBar函数内（新作用域）又重新声明了print函数，所以fooBar内之后的部分只能是print(int)。之前的void print(const string&)无效。\n\n## 特殊用途语言特性\n\n+ 默认实参\n+ 内联函数\n+ constexpr函数\n\n### 默认实参\n\n某些函数有这样一种形参，在函数的很多次调用中都被赋予了一个相同的值，此时，我们把这个反复出现的值称为函数的默认实参。\n例如，使用string对象表示窗口的内容。一般情况下希望该窗口的高、宽和背景字都使用默认值。但是同时也允许用户为这几个参数自由指定与默认值不同的数值：\n\n```c++\ntypedef string::size_type sz; //string::size_type函数返回的是一个无符号的整型数\nstring screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');\n```\n\n为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中，一旦某个形参被赋予了默认值，他后面的所有形参都必须要有默认值。\n使用：\n\n```c++\nstring window;\nwindow = screen(); //等价于screen（24，80，'\t'）\nwindow = screen(66);//等价于screen（66，80，'\t'）\nwindow = screen（66，256）; //等价于screen（66，256，'\t'）\nwindow = screen(66，256，'#');//等价于screen（66，256，'#'）\nwindow = screen(, , '?')//错误：只能省略尾部实参\n```\n\n默认实参负责填补函数调用尾部实参，所以在设计含有默认实参的函数时，尽量让不怎么使用默认实参的形参出现在前面，而让那些经常使用默认值的形参出现在后面。\n\n#### 默认实参声明\n\n通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。\n\n#### 默认实参初始值\n\n局部变量不能作为默认实参。除此之外，只要表达式的类型能转化成形参所需类型，该表达式就能作为默认实参。\n\n### 内联函数和constexpr函数\n\n内容短小的函数前面加inline变成内联函数，可以提高函数运行效率。\n\n普通函数调用比求等价表达式的值要慢一些。在大多数机器上，一次函数调用其实包含着一系列工作：调用前要保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。\n\n**内联函数可避免函数调用的开销**\n\n**内联函数inline：**引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：\n\n- 1.在内联函数内不允许使用循环语句和开关语句；\n- 2.内联函数的定义必须出现在内联函数第一次调用之前；\n- 3.类结构中所在的类说明内部定义的函数是内联函数。\n\n如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 **inline**，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。\n\n```c++\ninline const string & shorterString(const string &s1, const string &s2){\n  return s1.size() <= s2.size() ? s1 : s2\n}\n```\n\n\n\n内联函数的定义应该放在头文件中。因为内联函数的定义对编译器而言必须是可见的，以便编译器能够在调用点内联展开该函数的代码，所以仅有函数的原型不够。并且，与一般函数不同，内联函数有可能在程序中定义不止一次，此时必须保证在所有源文件中定义完全相同，把内联函数的定义放在头文件中可以确保这一点。\n\n### constexpr函数\n\n用于常量表达式（值不会改变并且在编译过程就能得到计算结果的表达式）的函数\n\n+ 函数的返回类型以及所有形参的类型都得是**字面值类型**（算数类型、引用和指针都属于字面值类型。自定义类、IO库、string类型则不属于字面周类型）\n+ 函数体中必须有且只有一条return语句（`constexpr` 函数只能包含 `return` 语句，不允许执行其他任务。）\n\n### 调试帮助\n\n程序可以包含一些用于**调试**的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉这些调试代码。\n\n+ assert预处理宏\n\nassert宏使用一个表达式作为它的条件：\n\n```c++\nassert(expr);\n```\n\n首先对assert求值，如果表达式为假（即0），assert输出信息并终止程序的执行。如果表达式为真（即非0），assert什么也不做。\n\n不需要为assert提供声明，直接可以使用assert。\n\nassert常用于检查“不能发生的条件”。例如，一个对输入文本进行操作的程序可能要求所有给定单词的长度都大于某个阈值。\n\n```c++\nassert(word.size() > threshold)\n```\n\n+ NDEBUG预处理变量\n\nassert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查。\n\n可以使用#define语句定义NDEBUG，从而关闭调试状态。\n\n除了用于assert外，也可以使用NDEBUG编写自己的条件调试代码。如果NDEBUG未定义，将执行#ifndef和#endif之间的代码：如果定义了NDEBUG，这些代码将被忽略掉：\n\n```c++\nvoid print(const int ia[], size_t size)\n{\n  #ifndef NDEBUG\n  //__func__是编译器定义的一个局部静态变量，用于存放函数的名字\n  cerr<<__func__<<\": array size is \"<<size<<endl;\n  #endif\n}\n```\n\n如果在程序头部添加#define NDEBUG\n那么程序中在`#ifdefine NDEBUG`和`#endif`之间 或者assert()内的的程序将不会被执行。\n\ncout对应于标准输出流\ncerr对应于标准错误流\n\n使用变量\\_\\_func\\_\\_输当前调试函数的名字。编译器为每个函数都定义了\\_\\_func\\_\\_,他是const char的一个静态数组，用于存放函数的名字。\n\n```C++\n__FILE__存放文件名的字符串字面值\n__line__存放当前行号的整型字面值\n__TIME__存放文件编译时间的字符串字面值\n__DATE__存放文件编译日期的字符串字面值\n```\n\n可以使用这些常量在错误消息中提供更多信息\n\n```c++\nif (word.size()<threshhold)\n  cerr<<\"Error: \"<<__FILE__\n  \t\t<<\" : in function\"<<__func__\n  \t\t<<\" at line \"<<__line__<<endl\n  \t\t<<\"Compiled on\"<<__DATE__\n  \t\t<<\" at \"<<__TIME__<<endl;\n```\n\n## 函数匹配\n\n1. 确定候选函数和可行函数\n   候选函数：\n\n+ 与备调用的函数同名\n+ 其声明在调用点可见\n\n可行函数：\n\n+ 其形参数量与本次调用提供的实参数量相等\n+ 每个实参的类型与对应的形参类型相同或者能转换成形参的类型\n\n2. 寻找最佳匹配\n\n   实参类型与形参类型越接近，它们匹配的越好。\n\n3. 含有多个形参的函数匹配\n\n   + 该函数每个实参的匹配都不劣于其他可行函数的匹配\n   + 至少有一个实参的匹配优于其他可行函数提供的匹配\n\n### 实参类型转化\n\n为了确定最佳匹配，编译器将实参类型到形参类型的转化划分成几个等级，具体排序如下所示：\n\n1. 精确匹配：\n\n+ 实参类型和形参类型相同\n+ 实参从数组类型或函数类型转换成对应的指针类型\n+ 向实参添加顶层const或者从实参中删除顶层const\n\n2. 通过const转换实现的匹配\n3. 通过类型提升实现的匹配(char-->int)\n4. 通过算数类型的转换或指针转化实现匹配(double-->int)\n5. 通过类类型转化实现匹配\n\n## 函数指针\n\n函数指针指向的是函数而非对象，函数指针指向某种特定类型。函数的类型由它的**返回类型和形参**共同决定，与函数名无关。\n\n只要函数们的返回类型相同，并且函数们的形参类型和数量相同，那么就可以说这些函数是同一个类型。\n\n```c++\nbool lengthCompare(const string&, const string&);\n//该函数的类型是 bool(const string&, const string&)\n\n//函数指针\nbool (*pf)(const string &, const string&); //pf指向一个函数，该函数的参数是两个const string的引用，返回值是bool类形\n!!一定要加括号\n```\n\n### 使用函数指针\n\n当我们把函数名作为一个值使用时，该函数自动地转化成指针。\n\n```c++\npf  = lengthCompare;   //pf指向名为lengthCampare的函数\npf  = &lengthCompare;  //等价的赋值语句：取地址符时可选的\n```\n\n可以直接使用指向函数的指针调用该函数，无需提前解引用指针\n\n```c++\nbool b1 = pf(\"hello\", \"goodbye\");  //调用lengthCompare函数\nbool b2 = (*pf)(\"hello\", \"goodbye\"); //一个等价调用\nbool b3 = lengthCompare(\"hello\", \"goodbye\"); //另一个等价调用\n\n//在指向不同函数类型的指针间 不存在 转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数：\n\nstring::size_type sumLength(const string&, const string&);\nbool cstringCompare(const char*, const char*);\npf = 0; //正确：pf不指向任何函数\npf = sumLength; //错误：返回的类型不匹配\npf = lengthCompare; //正确：函数和指针的类型精确匹配\n```\n\n### 函数指针形参（函数中的某个或多个形参的类型是另一个函数（函数指针））\n\n虽然不能定义函数类型的形参，但是形参可以是**指向函数的指针**。\n\n```c++\nvoid useBigger(const string&s1, const string&s2, bool pf(const string&, const string&)); //第三个形参是函数类型，它会自动地转换成指向函数的指针\n\nvoid useBigger(const string&s1, const string&s2, bool(*pf)(const string&, const string&)); //等价声明：显式地将形参定义成指向函数的指针。\n\n可以直接把函数作为实参使用，此时它会自动转换成指针：\nuseBigger(s1, s2, lengthCompare);\n```\n\n简化使用函数指针类型：\t\n\n```c++\n//Func和Func2是函数类型\ntypedef bool Func(const string&, const string&); \ntypedef decltype(lengthCompare) Func2; //等价的类型\n\n//FuncP和FuncP2是指向函数的指针\n//decltype返回函数类型，只有在前面加上*才能得到指针\ntypedef bool(*FuncP)(const string&, const string&);\ntypedef decltype(lenthCompare) *FuncP2; //等价的类型\n\n//useBigger的等价声明，第一条语句中，编译器自动地将Func表示的函数类型转化成指针\nvoid useBigger(const string&, const string&, Func);\nvoid useBigger(const string&, const string&, FuncP2);\n```\n\n### 返回指向函数的指针\n\n函数可以返回指向函数的指针（返回另一个函数类型）。但返回类型不会像函数类型的形参一样自动地转换成指针，必须显式地将其指定为指针类型，即加上 `*`\n\n```c++\nusing F = int(int*, int); //F是函数类型，不是指针\nusing PF = int(*)(int*, int); //PF是指针类型\n\nPF f1(int); //正确：PF是指向函数的指针。f1返回指向函数的指针\nF f1(int);//错误：F是函数类型，f1不能返回一个函数类型\nF *f1(int);//正确：显示地指定返回类型是指向函数的指针\n```\n\n例子\n\n```c++\n//编写函数的声明，令其接受两个int形参并且返回类型也是int；然后声明一个vector对象，令其元素是指向该元素的指针。\nint func(int, int);\nusing\tPF1 = int(*)(int, int);\ntypedef func PF2;\n1. vector<PF1>v1;\n2. vector<PF2*>v2; //两种都可以\n\n//编写4个函数，分别对这两个int执行加、减、乘、除运算；在上一题创建的vector对象中保存指向这些函数的指针。\n\nint add(int v1, int v2){\n\treturn v1+v2;\n}\nint subtract(int v1, int v2){\n\treturn v1-v2;\n}\nint mutiply(int v1, int v2){\n\treturn v1*v2;\n}\nint devide(int v1, int v2){\n\treturn v1/v2;\n}\nint main(){\n  using F = int(int, int);\n  typedef decltype(F)* PF;\n  vector<PF> v1;\n  v1 = {add, subtract, multiply, devide};\n  \n//调用上述vector对象的每个元素并输出其结果   \n  for (auto i : v1)\n    cout<<i(2,2)<<endl;\n //输出4，0，4，1\n\n\n}\n```\n\n","tags":["C++"]},{"title":"C++Primer第五章笔记","url":"/2020/07/12/C-Primer第五章笔记/","content":"# 语句\n\n+ 简单语句\n+ 语句作用阈\n+ 条件语句\n+ 迭代语句\n+ 跳转语句\n+ try语句块和异常处理\n## 简单语句\n### 空语句\n如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时使用空语句。感觉像是python中的pass。一种常见的情况是，当循环的全部工作在条件部分就可以完成时，我们通常会用到空语句。例如，我们想要读取输入流的内容知道遇到一个特定值为止，除此之外什么事情也不做：\n```C++\nwhile(cin>>s && s!= sought)//重复读入数据直至到达文件末尾或某次输入的等于sought\n;//空语句\n```\n### 复合语句\n复合语句是指用花括号括起来的语句和声明序列，复合语句也被称作块（block）。\n例如我们常常要在循环体中做很多事情，此时就要把多条语句用花括号括起来，从而把语句序列转变成块。\n```C++\nwhile (val <= 10){\n\tsum += val;\n\t++val;\n}\n```\n## 语句作用阈\n可以在if、switch、while和for语句的控制结构内定义变量。定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了：\n```c++\nwhile(int i = get_num()) //每次迭代是创建并初始化i\n\tcout<<i<<endl;\ni = 0; //错误：在循环外部无法访问i\n```\n如果其他代码也需要访问控制变量，则变量必须定义在语句的外部\n```C++\nauto beg = v.begin();\nwhile(beg != v.end() && *beg >=0)\n\t++beg;\nif (beg == v.end())\n```\n### 例子\n```C++\nwhile(string::iterator iter != s.end()){...}\n```\n是错误的，因为iter是刚刚定义的对于string的迭代器，还没有被初始化，上面的代码直接把为初始化的迭代器与s.end()比较会发生错误。\n正确写法\n```c++\nstring::iterator iter = s.begin();\nwhile (iter != s.end()){...};\n```\n## 条件语句\n+ if语句：根据条件决定控制流\n+ switch语句，计算一个整型表达式的值，然后根据这个值从几条执行路径中选择一条\n### if语句\n条件不管是表达式还是变量，其类型都必须能转化成布尔类型\n#### 悬垂else\n当代码中的if分支多于else分支时，C++规定else与离它最近的尚未匹配的if匹配。或者最好使用花括号。\n### switch语句\nswitch语句提供了一条便利的途径使得我们能够在若干个固定选项中作出选择。举个例子，假如我们想统计五个元音字母在文本中出现的次数，程序逻辑应该如下所示：\n+ 从输入的内容中读取所有字符\n+ 令每个字符都与原因字母的集合比较\n+ 如果字符与某个元音字母匹配，将该字母数量加1.\n+ 显示结果\n```c++\nunsigned aCnt = 0, eCnt = 0, iCnt = 0, oCnt = 0, uCnt = 0;\nchar ch;\nwhile (cin >> ch){\nswitch(ch){\n\tcase'a':\n\t\t++aCnt;\n\t\tbreak;\n\tCase'e':\n\t\t++eCnt;\n\t\tbreak;\n\tcase'i':\n\t\t++iCnt;\n\t\tbreak;\n\tcase'o':\n\t\t++oCnt;\n\t\tbreak;\n\tcase'u':\n\t\t++uCnt;\n\t\tbreak;\n\t\t\n}\n}\n```\nswitch语句首先对括号里的表达式求值，该表达式跟在关键字switch的后面，可以是一个初始化的变量声明。如果switch语句的表达式和所有case都没有匹配上，将直接跳转到switch结构之后的第一条语句。\ncase关键字和它对应的值一起被称为case标签。**case标签必须是整型常量表达式,不能是变量！**\n```c++\nchar ch = getVal();\nint ival = 42;\nswitch(ch){\n\tcase 3.14: //错误：case标签不是一个整数\n\tcase ival: //错误：case标签不是一个常量\n}\n```\n#### switch内部控制流\n如果某个case标签匹配成功，将从该标签开始往后顺序执行所有case分支，除非程序显式地中断了这一过程，否则直到switch的结尾处才会停下来。要想避免执行后续case分支的代码，我们必须显示地告诉编译器终止执行过程。大多数情况下，在下一个case标签之前应该有一个break语句。\n\n然而，也有一些时候默认的switch行为才是程序真正需要的。每个case标签只能对应一个值，但是有些时候我们希望两个或更多个值共享同一组操作。此时我们就故意省略掉break语句，使得程序能够连续执行若干个case标签。\n比如想要统计所有元音字母出现的总次数：\n\n```c++\nunsigned vowelCnt = 0;\nswitch(ch){// 出现了a,e,i,o,u中的任意一个都会将vowelCnt的值加1\n\tcase'a':\n\tcase'e':\n\tcase'i':\n\tcase'o':\n\tcase'u':\n\t\t++vowelCnt;\n\t\tbreak;\n}\n```\n**为例安全起见，最好在最后一个标签的后面也加上break；**\n#### default标签\n如果没有任何一个case标签能匹配上switch表达式的值，程序将执行紧更在default标签后面的语句。例如，可以增加一个计数值来统计非元音字母的数量，只要在default分支内不断递增名为otherCnt的变量就可以了：\n```c++\nswitch(ch){\n\tcase'a': case'e': case'i': case'o': case'u':\n\t++vowelCnt;\n\tbreak;\ndefault:\n\t++otherCnt;\n\tbreak;\n}\n```\n#### switch内部的变量定义\n如果程序跳转到了某个特定的case，则switch结构中该case标签之前的部分会被忽略掉。这种忽略掉一部分特定代码的行为引出了一个有趣的问题：如果被忽略过的代码中含有变量的定义该怎么办？\n\n答案是：如果在某一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法的。\n\n使程序能够统计含有以下两个字符的字符序列的数量：ff、fl和fi。\n```c++\nint main()\n\n{   unsigned ffCnt =0, flCnt = 0, fiCnt = 0;\n    char c, before = '\\0';\n    cout<<\"Pls typ a short text: \"<<endl;\n    while(cin.get(c)){\n        if (before == 'f')\n        {switch (c)\n        {\n        case 'f':\n            ffCnt++;\n            break;\n        case 'l':\n            flCnt++;\n            break;\n        case 'i':\n            fiCnt++;\n            break;\n        default:\n            break;\n        }\n        }\n        before = c;\n        }\n        cout<< \"The text contain \"<<ffCnt<<\" ff\"<<endl;\n        cout<< \"The text contain \"<<flCnt<<\" fl\"<<endl;\n        cout<< \"The text contain \"<<fiCnt<<\" fi\"<<endl;\n}\n```\n\n## 迭代语句\n### while语句\n定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。\n#### 使用情景\n+ 不确定到底要迭代多少次\n+ 我们想在循环结束后访问循环控制变量\n```c++\nvector<int> v;\nint i; \nwhile(cin>>i)\n\tv.push_back(i); //v.push_back(t)\t向尾端添加一个值为t的元素\n//寻找第一个负值\nauto beg = v.begin();\nwhile (beg != v.end() && *beg>=0)\n\t++beg;\nif(beg == v.end())\n```\n### 传统的for语句\nfor(init-statement; condition; expression)\n\tstatement\nfor语句中定义的对象只在for循环体内可见。\n#### for语句头中的多重定义\n和其他声明一样，init-statement也可以定义**多个对象**。但是init-statement只能有**一条声明语句，**因此，所有变量的基础类型必须相同。比如，下面的循环把vector的元素拷贝一份添加到原来的元素后面：\n```c++\nfor(decltype(v.size()) i =0, sz = v.size(); i !=sz; ++i)\n\tv.push_back(v[i]);\n```\n### 范围for语句\nfor (declaration: expression)\n\tstatement\n\nexpression表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者vector或string等类型的对象，这些类型的共同特点是拥有能返回迭代器的begin和end成员。\n\ndeclaration定义一个变量，序列中的每个元素都能得到转换成该变量的类型。确保类型相容最简单的办法是使用auto类型说明符。**如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。**\n\n#### 例子\n把vector对象中的每个元素都翻倍：\n```c++\nvector<int> v = {0,1,2,3,4,5,6,7,8,9};\nfor(auto &r : v) //范围变量必须是引用类型，这样才能对元素执行写操作\n\tr *= 2;  \n```\n不能通过范围for语句增加vector对象的元素。在范围for语句中预存了end（）的值。一旦在序列中添加（删除）元素，end函数的值就可能变得无效了。\n\n### do while语句\ndo\n\tstatement \nwhile(condition);\n和while的区别是，do while不管条件的值如何，我们都至少执行一次循环。\n\n## 跳转语句\n+ break\n+ continue\n+ goto\n+ return\n\n### break语句\nbreak语句负责终止离他最近的while、do while、 for或者switch语句，并从这些语句之后的第一条语句开始继续执行。\n\n### continue语句\ncontinue语句终止最近的循环中的当前迭代并立即开启下一次迭代。continue语句只能出现在for、while和do while循环内部，或者嵌套在此类循环里的语句或块的内部。\n+ 和break语句类似的是，出现在嵌套循环中的continue语句也仅作用于离它最近的循环。\n+ 和break不同的是，只有当switch语句嵌套在迭代语句内部时，才能在switch里使用continue。\n\n例如，下面的程序每次从标准输入中读取一个单词。循环只对那些以下划线开头的单词感兴趣，**其他情况下，我们直接终止当前的迭代并获取下一个单词。**\n```c++\nstring buf;\nwhile(cin>>buf && !buf.empty()){\nif (buf[0] != '_') //注意⚠️ 这里是不等于\n\tcontinue; //接着读取下一个输入\n//程序执行到了这里，说明当前输入是以下划线开始的；接着处理buf\n}\n```\n### goto语句\ngoto语句的作用是从goto语句无条件跳转到同一函数的另一条语句。\n**不要在程序中使用goto语句，因为它使得程序既难以理解又很难修改**\ngoto语句的语法形式是\n\tgoto label；\n其中，label是用于标识一条语句的标识符。带标签语句是一种特殊的语句，在它之前有一个标识符以及一个冒号：\n\tend: return; //带标签语句，可以作为goto的目标\n标签标示符独立于变量或者其他标识符的名字，因此，标签标识符可以和程序中的其他实体的标识符使用同一个名字而不会相互干扰。goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内。\n\n## try语句块和异常处理\n异常处理：\n+ throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题。我们说throw引发了异常。\n+ try语句块，异常处理部分使用try语句块处理异常。try语句块以关键字try开始，并以一个或多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。因为catch子句处理异常，所以他们也常被称作异常处理代码。\n+ 一套异常类，用于在throw表达式和相关的catch子句之间传递异常的具体信息。\n\n### throw表达式\n程序的异常检测部分使用throw表达式引发一个异常。throw表达式包含关键字throw和紧随其后的一个表达式，其表达式的类型就是抛出的异常类型。throw表达式后面通常紧跟一个分号，从而构成一条表达式语句。\n\n比如之前程序检查读入的记录是否是关于同一种书籍的。在真实的程序中，应该把对象相加的代码和用户交互的代码分离出来。此例中，我们改写程序使得检查完成后不再直接输出一条信息，而是**抛出一条异常：**\n```c++\nif(item.isbn()!=item2.isbn())\n\tthrow runtime_errow(\"Data must be refer to same ISBN\")\n// 如果程序执行到了这里，表示两个ISBN是相同的\ncout<<item1 + item2<<endl;\n```\n\n在这段代码中，如果ISBN不一样就抛出一个异常，该异常是类型runtime_error的对象。抛出异常将终止当前的函数，并把控制权转移给处理该异常的代码。\n\n类型runtime_error是标准库异常的一种，定义在stdexcept头文件中。我们必须初始化runtime_error的对象，方式是给它提供一个string对象或者一个c风格的字符串，这个字符串中有一些关于异常的辅助信息。\n\n### try语句块\ntry语句块的通用语法形式是\n```c++\ntry{\n\t\tprogramm-statements\n} catch (exception-declaration){\n\thandler-statements\n}catch (exception-declaration){\n\thandler-statements\n}\n```\ntry语句块的一开始的关键字是try，随后紧跟着一个块。\n跟在try块之后的是一个或多个catch子句。catch子句包括三部分：关键字catch、括号内一个（可能未命名的）对象的声明（称作**异常声明**，exception declaration）以及一个块。当选中了某个catch子句处理了异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。\ntry语句块中的programm-statements组成程序的正常逻辑，像其他任何块一样，programm-statesments可以有包括声明在内的任意c++语句。一如既往，try语句块内声明的变量在块外无法访问，特别在catch子句内也无法访问。\n\n### 编写处理代码\n假设执行Sales_item对象加法的代码是与用户交互的代码分离开来的。其中与用户交互的代码负责处理发生的异常。它的形式可能如下所示：\n```c++\nwhile(cin>>item1>>item2){\n\ttry{\n\t\t\t//执行添加两个Sales_items对象的代码\n\t\t\t//如果添加失败，代码抛出一个runtime_error的异常\n\t} catch(runtime_error err){\n\t\t//提醒用户两个ISBN必须一致，询问是否重新输入\n\t\t\tcout<<err.what()\n\t\t\t\t\t<<\"\\nTry Again? Enter y or n\"<<endl;\n\t\t\tchar c;\n\t\t\tcin>>c;\n\t\t\tif (!cin||c == 'n')\n\t\t\t\tbreak;\n\t}\n}\n```\n程序本来要执行的任务出现在try语句块中，这是因为这段代码可能会抛出一个runtime_error类型的异常。\n\ntry语句块对应一个catch子句，该子句负责处理类型为runtime_error的异常。如果try语句块的代码抛出了runtime_error异常，接下来执行catch块内的语句。\n\n`err.what()`what是runtime_error类的一个成员函数。每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是c风格字符串（即const char\\*）。其中，runtime_error的what成员返回的是初始化一个具体对象时所用的string对象的副本。如果上一节编写的代码抛出异常，则本节的catch子句输出\n```c++\n\tData must refer to same ISBN\n\tTry Again? Enter y or n\n```\n\n### 函数在寻找处理代码的过程中退出\n在复杂系统中，程序在遇到抛出的异常代码前，其执行路径可能已经经过了多个try语句块。例如，一个try语句块可能调用了包含另一个语句块的函数，新的try语句块可能调用了包含又一个try语句块的新函数，以此类推。\n\n寻找处理代码的过程与函数调用链刚好相反。\n1. 当异常被抛出时，首先搜索抛出该异常的函数。\n2. 如果没有找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。\n3. 如果还没有找到匹配catch子句，这个新的函数也被终止，继续搜索调用它的函数。\n4. 以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的catch子句为止。\n5. 如果最终还没有找到任何匹配的catch子句，程序转到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。\n\n### 标准异常\nc++标准库定义了一组类，用于报告标准库函数遇到的问题，这些异常类也可以在用户编写的程序中使用，它们分别定义在4个头文件中：\n+ exception头文件定义了最通用的异常类exception。它只报告异常的发生，不提供任何额外信息。\n+ stdexcept头文件定义了几种常用的异常类，在下表中列出\n+ new头文件定义了bad_alloc异常类型\n+ type_info头文件定义了bad_cast异常类型\n\n|异常类|解释|\n|---|---|\n|exception|最常见的问题|\n|runtim_error|只有在运行时才能检测出问题|\n|range_error|运行时错误：生成的结果超出了有意义的值域范围|\n|overflow_error|运行时错误：计算上溢|\n|underflow_error|运行时错误：计算下溢|\n|logic_error|程序逻辑错误|\n|domain_error|逻辑错误：参数对应的结果值不存在|\n|invald_argument|逻辑错误：无效参数|\n|length_error|逻辑错误：试图创建一个超出该类型最大长度的对象|\n|out_of_range|逻辑错误：使用一个超出有效范围的值|\n\n我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。\n\n其他异常类型的行为则恰好相反：应该使用string对象或者c风格字符串初始化这些类型的对象，但不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。\n\n异常类型只定义了what的成员函数，该函数没有任何参数，返回值是一个指向c风格字符串的const char\\*。该字符串的目的是提供关于异常的一些文本信息。\n\nwhat函数返回的c风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串。对于其无初始值的异常类来说，what返回的内容由编译器决定。\n\n### 例子\n从标准读取两个整数，输出第一个数除以第二个数，如果第二个数是0抛出异常，在用try语句块去捕获异常。catch子句应该为用户输出一条信息，询问其是否重新输入并执行try语句块的内容\n```c++\nint main()\n\n{\n    int i1,i2;\n    cout<<\"Pls enter 2 integer values: \"<<endl;\n    while(cin>>i1>>i2){\n        try{\n            if (i2 == 0)\n            {\n                throw runtime_error(\"The denominator can't be 0.\");\n            }\n            cout<<(i1/i2)<<endl;\n        } catch(runtime_error err){\n            cout<<err.what()<<\"\\nTry Again? Enter y or no\"<<endl;\n            char c;\n            cin>>c;\n            if(c == 'n'){\n                break;\n            }\n        }\n    }\n}\n```\n\n\n","tags":["C++"]},{"title":"C++Primer第四章笔记","url":"/2020/06/30/C-Primer第四章笔记/","content":"\n# 第四章表达式\n\n## 基础\n\n### 基本概念\n\n+ 一元运算符：作用于一个运算对象，如取地址符（&）和解引用符（\\*）\n+ 二元运算符：作用于两个运算对象，如相等（==）和乘法（\\*）\n+ 三元运算符\n\n#### 重载运算符（override）\n\n定义了运算符作用于内置类型和复合类型的运算时所执行的操作。**自定义运算符的过程事实上是为已存在的运算符赋予了另外一层含义**。IO库的>>和<<运算符以及string对象，vector对象和迭代器使用的运算符都是重载运算符。\n#### 左值和右值\n当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）\n### 优先级与结合律\n复合表达式是指含有两个或多个运算符的表达式。\n一个式子，如果没有括号，那么计算顺序和正常计算顺序一致，乘除优先于加减。加上括号就括号优先。\n```c++\nint ia[] = {0,2,4,6,8}; \nint last = *{ia + 4}; //ia是指向数组的首元素的指针，ia+4是指向指向第4个元素的指针，再解引用得到ia[4]得到8\nlast = *ia + 4;\t//先解引用得到首元素的值为0，再加4得到的值为4\n```\n### 求值顺序\n对于那些没有指定执行顺序的运算来说，如果表达式指向并修改了同一个对象，将会引发错误并产生为定义的行为。\n```c++\nint i = 0;\ncout<< i<< \" \"<<++i<<endl;\n```\n编译器可能先求++i的值再求i的值，此时输出结果为1 1；也可控先求i的值再求++i的值，输出结果是0 1。\n有4种运算符明确规定了运算对象的求职顺序。\n+ && 逻辑与运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值。\n+ || 逻辑或运算符\n+ （？：）条件运算符\n+ ， 逗号运算符\n\n#### 求值顺序、优先级、结合律\n+ 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求\n+ 如果改变了某个运算对象的值，在表达式的其他地方不要在使用这个运算对象。（\\*++iter除外）\n\n---\n\n## 算数运算符\n一元正号运算符（+ expr）、加法运算符和减法运算符都能作用与指针。\n一元正号运算符作用与一个指针或者算数值时，返回运算对象值的一个（提升后的）副本：\n\n```c++\nint i = 1024;\nint k = -i; //k是-1024\nbool b = true;\nbool b2 = -b; //b2是true\n```\n布尔变量b的值为真，参与运算时将被提升整数值1，对它求负后的结果是-1.将-1再转换回布尔值并将其作为b2的初始值，显然这个初始值不等于0，转换成布尔值后为1。所以b2的值是真！\n\n整数相处的接果还是整数，也就是说，如果商含有小数部分，直接弃除\n```c++\nint ivall = 21/6 //ivall是3，结果进行删节，余数被抛弃掉了\nint ivall = 21/7 //ival是3，没有余数，结果是整数值\n```\n\n+ -m/n和m/（-n）都等于-（m/n）\n+ m%(-n)等于m%n\t  (-m)%n等于-(m%n)\n-21 % -8  结果是 -5\n21 % -5 结果是 1\n\n---\n\n## 逻辑和关系运算符\n关系运算符作用于算数类型或者指针类型，逻辑运算符作用于任意能转换成布尔值的类型。逻辑运算和关系运算符的返回值都是布尔类型。值为0的运算对象表示假，否则表示为真。\n\n短路求值：\n\n+ 对于逻辑与（&&）运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值。\n```C++\nindex != s.size() && !isspace(s[index])\n```\n首先会检查index是否达到了string对象的末尾，以此确保只有当index在合理范围内时才会计算右侧运算对象的值。\n+ 对于逻辑或（||）运算符来说，当且仅当左侧的运算对象为假时才对右侧运算对象求值。\n假定有一个储存着若干个string对象的vector对象，要求输出string对象的内容并且在遇到空字符串或者以句号结束的字符串时进行换行。使用基于范围for循环处理string对象中的每个元素。\n```c++\nint main()\n{   \n    vector<string> text = {\"hello\", \"world\", \"Nihao\", \"dawdaw.\",\"Loamo\",\"zz\",\"\\0\",\"houge\",\"ll\"};\n    for(const auto &s: text){\n        cout<<s;\n        if (s.empty()||s[s.size()-1]=='.'){\n            cout<<endl;\n        }\n    }\n\n}\n```\n只有当非string对象非空时才需要求第二个运算对象的值，也就是检查string对象是否以句号结尾。s被声明了对常量的引用。因为text的元素是string对象，可能非常大，所以将s声明成引用类型可以避免对元素的拷贝。又因为不需要string对象进行写操作，所以s被声明成对常量的引用。\n\n### 关系运算符\n`if(i<j<k)`不正确，因为会先计算i<k的结果，结果是true或者是false，然后再把true和false与k做比较，会产生问题。`if (i<j && j<k)`当i小于j并且j小于k时条件为真\n### 相等性测试与字面布尔值\n\n如果想测试一个算数对象或指针对象的真值，最直接的方法就是将其作为if语句的条件：\n\n+ 对象\n\n```c++\nint val = 2;\nif（val）{}\t//如果val是任意的非0值 1,100,-2只要是非0都可以，条件为真\nif(!val){}\t//如果val是0，条件为真\nif（val == true）{} //只有当val等于1时条件才为真\n```\n当布尔值转化成其他算数类型时，false转化成0而true转化成1。\n**进行比较运算时除非比较的对象是布尔类型，否则不要用布尔字面值true和false作为运算对象**\n\n+ 指针\n```c++\nconst char *cp = \"Hello World\";\nif (cp && *cp)\n```\n首先if判断cp指针是否为空指针或者无效指针。\n如果cp是空指针或无效指针之间返回false。\n如果cp不是空指针和无效指针，检查\\*cp是否为空字符，如果是空字符则返回false，如果不是则返回true。\n这里cp指向const的“Hello world”string对象，不为空且有效，\\*cp是cp指针的解引用，cp指向string的第一个字符的首地址，不是空字符所以返回true。\n\n## 赋值运算符\n\n+ 赋值运算符的左侧运算对象必须是一个可以修改的左值。\n+ 如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧的元素运算对象的类型。\n+ 无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧的运算对象。\n```c++\nint i = 0, j = 0, k = 0; //初始化而非赋值\nconst int ci = i; //初始化而非赋值\nk = 3.1415926； //结果：类型是int，值是3\n```\n### 赋值运算满足右结合律\n```c++\nint ival, jval;\nival = javl = 0;\nstring s1, s2;\ns1 = s2 = \"OK\";\nint ival, *pval;\nival = pval = 0; //错误：pval的类型是指向整型的指针，ival的类型是整型，指针类型无法转换成为整型\n```\n对于多重赋值语句中的每一个对象，它的类型或者右边对象类型相同、或者可由右边类型转换得到。\n### 赋值运算优先级较低\n因为赋值运算的优先级相对较低，所以通常需要给赋值部分加上括号使其符合我们的意愿。\n```c++\nint i;\nwhile((i = get_value())!=42){\n\t\n}\n```\n不断循环读取数据直到遇到42为止。\n其处理过程是首先将get_value函数的返回值赋给i，然后比较i和42是否相等。\n\n---\n\n## 递增和递减运算符\n+ 前置版：`j = ++i`运算符首先将运算对象加1（或减1），然后将改变后的对象作为求值结果 \n+ 后置版：`j = i++`也会将运算对象加1（或减1），但是求值结果是运算对象改变之前的那个值的副本\n```c++\nint i = 0, j;\nj = ++i; // j = 1, i = 1: 前置版本得到递增之前的值\n---\nint i = 0, j;\nj = i++; //j = 0， i=1: 后置版本得到递增之前的值\n```\n**除非必须，否则不用递增递减运算符的后置版本**\n因为后置版本会储存赋值之前的值，占用空间，造成不必要的浪费\n\n### 在一条语句中混用解引用和递增运算符\n如果我们想在一条复合表达式中既将变量加1或减1又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。\n可以使用后置的递增运算符来控制循环输出的一个vector对象内容直至遇到（但不包括）第一个负值为止。\n```c++\nauto pbeg = v.begin();\nwhile(pbeg != v.end() && *beg>= 0){\n\tcout<< *pbeg++<<endl;\n}\n```\n**后置递增运算符的优先级高于解引用运算符**，因此\\*pbeg++等价于\\*(pbeg++)。pbeg++把pbeg的值加1，然后返回pbeg的初始值的副本作为其求值结果（还没有加1的状态），此时解引用运算符的运算对象是pbeg未增加之前的值。最终这条语句输出pbeg开始时指向的那个元素，并将指针向前移动一个位置。\n\n## 成员访问运算符\n\n+ 点运算符(\\*ptr).mem\n+ 箭头运算符ptr->mem\n```c++\nstring s1 = \"a string\", *p = &s1;\nauto n = s1.size();\nn = (*p).size(); //运行p所指对象的size成员\nn = p->size();\t//等价于(*p).size()\n```\n箭头运算符作用于一个指针类型的运算对象，结果是一个左值。\n点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果所属的对象是右值，那么结果是右值。\n\n## 条件运算符\n条件运算符（？：）允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：\ncond？expr1:expr2；\n先求cond的值，如果条件为真对expr1求值并返回该值，否则对expr2求值并返回该值。\n```c++\nstring finalgrade = (grade < 60) ? \"fail\":\"pass\";\n```\n### 嵌套条件运算符\n允许在条件运算符的内部嵌套另一个条件运算。也就是说，条件表达式可以作为另外一个条件运算符的cond或expr。使用一对嵌套的条件运算符可以将成绩分成三档：优秀（high pass）、合格（pass）和不合格（fail）：\n```c++\nfinalgrade = (grade > 90)?\"high pass\":(gerade<60)?\"fail\":\"pass\";\n```\n### 在输出表达式中使用条件运算符\n条件运算符的优先级非常低，因此当一条长表达式中嵌套了条件运算子表达式，通常需要在它的两端加上括号。例如，有时需要根据条件值输出两个对象中的一个：\n```c++\ncout<<((grade<60)?\"fail\":\"pass\");\n```\n## 位运算符\n位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。位运算符提供检查和设置二进制位的功能，一种名为bitset的标准库类型也可以表示任意大小的二进制位集合，所以位运算同样能用于bitset类型。使用位运算符的好处是运算速度非常快。\n| 运算符 | 功能   | 用法           | 解释                                   |\n| ------ | ------ | -------------- | -------------------------------------- |\n| ~      | 位求反 | ~ expr         | 操作数为1，结果为0；操作数为0，结果为1 |\n| <<     | 左移   | expr1 << expr2 | 把左边的数转化成二进制向左移动右边位   |\n| >>     | 右移   | expr1 >> expr2 | 把左边边的数转化成二进制向右移动右边位 |\n| &      | 位与   | expr & expr    | 两个操作数同时为1结果为1               |\n| ^      | 位异或 | expr ^ expr    | 两个操作数相同，结果为0；不相同结果为1 |\n| \\|     | 位或   | expr \\| expr   | 两个操作数之要有一个为1，结果就为1     |\n### 举例\n\n#### 位与\n十进制\t\t4\t\t&\t\t 5\n二进制\t\t100\t&\t\t101\n每个位置上与关系：1和1是1，0和0是0，0和1是1，结果100 转化成十进制还是4\n#### 位非\n~2\n二进制： 10\n取反：      01-----> 十进制： 1； **错误**\n因为假设是char是占8位\n二进制： 00000010\n取反： \t11111101 （第一位是1---->负数）\n负数二进制转十进制：\n将负数二进制取反，然后+1，结果为负\n11111101 ----> 00000010 +1 = 00000011 转十进制 3 再加负号 -3\n\n#### 左移\n<< 和 cout<<样子相同 但是含义完全不同，cout<<是重载运算符\n2 << 3\n先转化为二进制 10 ----> 左移三位 10 000 ----> 转化为10进制 2^4 =16 \n\n\n**关于符号位如何处理没有明确规定，所以强烈建议仅将位运算符用于处理无符号类型。**\n\n### 移位运算符\n\\>>和<<运算符的内置含义是对其运算对象执行基于二进制位的移动操作，首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生为定义的行为。二进制位或者向左移（<<）或者向右移（>>），移出边界之外就被舍弃掉了。\n\n### 移位运算符（又叫IO运算符）满足左结合律\n```c++\ncout<<\"hi\"<<\"there\"<<endl;\n((cout<<\"hi\")<<\"there\")<<endl; //等效于\n```\n移位运算符的优先级不高不低，介于中间：比算数运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高\n```c++\ncout << 42 + 10 //正确：+的优先级更高，因此输出求和结果\ncout << (10 < 42) //正确：括号使运算按照我们的期望组合在一起，输出1\ncout << 10 < 42 //错误：试图比较cout和42\n```\n\n\n## sizeof运算符\nsizeof运算符返回一条表达式或一个类型名字所占的字节数 (1个字节占8比特)。sizeof运算符满足右结合律，其所得的值是一个size_t类型的常量表达式。运算符的运算对象有两种形式：\n+ sizeof (type)\n+ sizeof expr\n在第二种形式中，sizeof返回的是表达式结果类型的大小。与众不同的一点是，sizeof并不实际计算其运算对象的值：\n```c++\nSales_data data, *p;\nsizeof(double); //结果是8 占8个字节\nsizeof(\"abcd\"); //结果是5 占5个字节，因为string结尾默认有\\0站一个字节\nsizeof(Sales_data); //存储Sale_data类型的对象所占的空间大小\nsizeof data; //data的类型的大小，即sizeof(Sales_data)\nsizeof p; //指针所占的空间大小\nsizeof *p  //p所指类型的空间大小，即sizeof(Sales_data)\nsizeof data.revenue; //Sales_data的revenue成员对应的类型的大小\nsizeof Sale_data::revenue; //另一种获取revenue大小的方式\n```\nC++11新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是sizeof运算符无需我们提供一个具体的对象，因为想要知道类成员的大小无需真的获取该成员。\nsizeof运算符的结果部分地依赖于其作用的类型：\n+ 对char或者类型位char的表达式执行sizeof运算，结果为1。\n+ 对引用类型执行sizeof运算得到被引用对象所占空间的大小。\n+ 对指针执行sizeof运算得到指针本身所占空间的大小。\n+ 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效\n+ 对数组执行sizeof运算得到整个数组所占空间大小，等价于对数组中的所有元素各执行一次sizeof运算并将所得结果求和。注意，sizeof运算不会把数组转换成指针来处理\n+ 对string对象或vector对象（sizeof(string)）执行sizeof运算值返回该类型固定部分的大小，不会返回对像中的元素占用了多少空间。如果想要知道元素占用了多少可以直接(sizeof(\"abcd\"))\n\n### 通过sizeof确定数组中的元素个数\n因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中的元素的个数\n```c++\nconstexpr size_t sz = sizeof(ia)/sizeof(*ia);\nint arr2[sz]; \n```\n因为sizeof的返回值是一个常量表达式，所以我们可以用sizeof的结果声明数组的维度。\n### 例子\n```c++\n \t\tint x[10]; \n    int *p = x;\n    cout<< sizeof(x)/sizeof(*x) <<endl; // 40/4 = 10\n    cout<< sizeof(p)/sizeof(*p) <<endl;\t// 8/4 = 2\n```\n+ sizeof(x), x是一个有10个元素的数组，所以它的sizeof是所有的10个int元素之和。10\\*4 = 40\n+ sizeof(\\*x) 返回x所指类型的空间大小，即sizeof(int)\n+ sizeof(p) 返回指针所占的空间大小\n+ size(\\*p) 返回p所指对象类型所占空间大小，即sizeof(int)\n\n## 逗号运算符\n逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。和逻辑与、逻辑或以及条件运算符一样，逗号运算符也规定了对象求值的顺序。\n对于逗号运算符来说，首先对左侧的表达式求值，然后将求值的结果丢弃掉，逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。\n逗号运算符经常被用在for循环当中：\n\n```c++\nvector<int>::size_type cnt = ivec.size(); // 将把从size到1的值赋给ivec的元素\nfor(vector<int>::size_type ix = 0; iX != ivec.size(); ++ix, --cnt){\n\tivec[ix] = cnt;\n\t}\n```\n这个循环在for语句的表达式中递增ix、递减cnt，每次迭代循环ix和cnt相应改变。只要ix满足条件，我们就把当前元素设成cnt的当前值。在for循环中前置和后置效果一样，因为for循环中的是；这是因为递增递减运算符与真正使用这两个变量的语句位于不同的表达式中，所以不会有什么影响。\n\n### 解释语句的含义\n```c++\nsomeValue? ++x, ++y:--x,--y\n```\n因为条件运算符的优先级大于逗号运算符，所以someValue? ++x, ++y:--x,--y 实际上是\n(someValue ? ++x, ++y : --x ), --y;\n+ 如果someValue为true：先执行++x，++y最后再执行--y\n+ 如果someValue为false：先执行--x，最后执行--y\n\n## 类型转换\n如果两种类型可以相互转换，那么它们就是关联的。\n```c++\nint ival = 3.541 + 3;\n```\n加法的两个运算对象类型不同：3.541是double，3的类型是int。c++语言不会将两个不同类型的值相加，而是先根据类型转化规则设法将运算对象的类型统一后再求值。上述的类型转换是自动执行的，无需程序员的介入，因此它们被称为**隐式转换**。\n\n### 算数转化\n#### 算数转换\n算数转换的规则定义了一套类型转化的层次，其中运算符的元素安对象将转换成最宽的类型。例如，如果一个运算对象的类型是long double（最宽的类型，范围最大的类型），那么不论另外一个运算对象的类型是什么都会转化成long double。还有一种更普遍的情况，当表达式中既有浮点类型也有整数类型时，整数值降转化成相应的浮点类型。\n##### 整型提升\n整型提升负责把小整数类型转化成较大的整数类型。对于bool、char、signed char、unsigned char、short和 unsigned short等类型来说，只要它们所有可能的值都存在int里，它们就会提升成int类型；否则，提升成unsigned int类型。就如我们所熟知的，布尔值false提升成0、true提升成1。\n##### 无符号类型的运算对象\n如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中的各个整数类型的相对大小了。\n+ 和往常一样，首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。\n+ 如两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。\n+ 如果一个运算对象是无符号类型，另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么将带符号的运算对象转换成无符号的。例如，假设两个类型分别是unsigned int和int，则int类型的运算对象转化成unsigned int类型。需要注意的是，如果int类型的值恰好为负，则会有副作用。（**带符号---->无符号**）\n+ 带符号类型大于无符号类型，此时运算结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号的运算对象转换成带符号类型。如果不能，那么带符号类型转换成无符号类型。\n##### 例子\n```c++\nbool flag;\nshort sval;\nint ival;\nlong lval;\nfloat fval;\nchar cval;\nunsigned short usval;\nunsigned int uival;\nunsigned long ulval;\ndouble dval;\n\n3.1415926L + 'a'; //'a'提升成int，然后该int值转化成long double\ndval + ival; //ival转化成double\ndval + fval; //fval转化成double\nival = dval; //dval转化成（切除小数部分后）int\nflag = dval; //如果dval是0，则flag是false，否则flag是true\ncval + fval; //cval(char)提升成int，然后该int值转化成float\nsval + cval; //sval（short）和cval（char）都转化float\ncval + lval； //cval转化成long\nival + ulval; //ival转化成unsigned long\nusval + ival; //根据unsigned short和int所占空间大小进行提升\nuival + lval; //根据unsigned int和long所占空间的大小进行转换\n```\n#### 其他隐式类型转化\n##### 数组转化成指针\n在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。\n```c++\nint ia[10]; //含有10个整数的数组\nint* ip = ia; //ia转化成指向数组首元素的指针\n```\n**当数组被用作decltype关键字的参数，或者作为取地址（&）、sizeof以及typeid等运算对象时，上述转换也不会发生。**\n##### 指针的转换\n+ 常量数值0或者字面值nullptr能转换成任意指针类型\n+ 指向任意非常量的指针能转化成void\\*\n+ 指向任意对象的指针能转化成const void\\*\n##### 转化成布尔类型\n存在一种从**算数类型**或**指针类型**向布尔类型自动转化的机制。如果指针或算数类型的值为0，转换结果是false，否则转换的结果是true。\n```c++\nchar *cp = get_string();\nif (cp) //如果指针cp不是0，条件为真\nwhile (*cp) //如果*cp不是空字符，条件为真\n```\n##### 转换成常量\n允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，如果T是一种类型，我们就能将指向T的指针或引用分别转换成指向const T的指针或引用。\n```c++\nint i;\nconst int &j = i;  //非常量转换成const int的引用\nconst int *p = &i; //非常量的地址转换成const的地址\nint &r = j, *q = p; //错误： 不允许const转化成非常量： j本来是const引用，需要先转换成非常量才能赋值给非常量int\n```\n##### 类类型定义的转换\n类类型能定义由编译器自动执行转换，不过编译器每次只能执行一种类类型的转换。\n```c++\nwhile(cin>>s) //while的条件部分把cin转换成布尔值\n```\n条件部分本来需要一个布尔类型的值，但是这里实际检查的是istream类型的值。幸好，IO库定义了从istream向布尔值转换的规则，根据这一规则，cin自动转换成布尔值。\n#### 显示转换\n```c++\nint i, j;\ndouble slope = i/j;\n```\n如果想在上面的代码中执行浮点数除法，就要使用某种方法将i和/或j显示的转化成double，这种方法称作强制类型转换（cast）。\n##### 命名的强制类型转化\ncast-name<type>(expression)\n其中，type是转换的目标类型而expression是需要转换的值。如果type是引用类型，则结果是左值。cast-name是\n+ static_cast\n+ dynamic_cast\n+ const_cast\n+ reinterpret_cast(重新解释)\n\n###### static_cast\n任何具有明确定义的类型转换，**只要不包含底层const**，都可以使用static_cast。例如，通过一个运算对象强制转换成double类型就能使表达式执行浮点数除法：\n```c++\ndouble slope = static_cast<double>(j) / i;\n```\nstatic_cast 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用static_cast找回存在于void*指针中的值：\n```c++\nvoid* p = &d; //正确：任何非常量对象的地址都能存入void*\ndouble *dp = static_cast<double>(p); // 正确：将void*转换回初始的指针类型\n```\n当我们把指针存放在void*中，并且使用了static_cast将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，**因此我们必须确保转换后所得的类型就是指针所指的类型**。类型一旦不符，将产生未定义的后果。\n\n---\n\n**底层const，常量指针（const pointer）**：针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。\n\n---\n###### const_cast（去掉const性质）\nconst_cast只能改变运算对象的底层const：\n```c++\nconst char *pc;\nchar *p = const_cast<char>(pc);\n```\n对于将常量对象转换成非常量对象的行为，我们一般称其为 “去掉const性质”。\n只有const_cast能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能使用const_cast改变表达式类型：\n```c++\nconst char *cp;\nchar *q = static_cast<char*>(cp) //错误：static_cast不能去掉const性质\nstatic_cast<string>(cp); //正确：字符串字面值转换成string类型\nconst_cast<string>(cp); //错误：const_cast只能改变常量属性\n```\n###### reinterpreter_cast\nreinterpreter_cast通常为运算对象的位模式提供较低层次上的重新解释。\n```c++\nint *ip;\nchar *pc = reinterpreter_cast<char*>(ip);\n```\npc所指的真实对象是一个int而非字符，如果把pc当成普通的字符指针使用就可能在运行时发生错误，要尽量避免使用reinterpreter_cast。","tags":["C++"]},{"title":"C++Primer第三章笔记","url":"/2020/06/18/C-Primer第三章笔记/","content":"\n#### 第三章（字符串，向量和数组）\n### 命名空间using的声明\n\n作用域操作符（::）的含义是：编译器应从操作符左侧所示的作用域中寻找右侧那个名字。比如std::cin就是要使用std中的名字cin。\n**每个名字都要有独立的using声明。**\n```c++\n#include<iostream>\nusing std::cin;\nusing std::cout;\nusing std::endl; //之后使用cin，cout和endl就可以直接用了\n...\n```\n**头文件不应该包含using声明**\n因为头文件会被引用到主文件中，对于某些程序来说由于不经意间包含了一次名字，反而可能产生始料未及的名字冲突。\n\n其实也可以使用`using namespace std；`可以一次性包含整个std命名空间。但是不太推荐，因为可能我们自己也不清楚整个命名空间都有哪些关键字，冒然`using`进来，增加了命名冲突的可能性。\n\n#### 自定义namesapce\nnamespace的主要功能是避免命名冲突，因为很多大型软件开发都是很多个程序员合作完成的，不同程序员可能会用相同的名字定义相同的函数，但是当最终把这些函数合并在一起之后编译运行的过程就会产生冲突，因为不知道该运行哪个函数。\n比如两个函数：\n```c++\nvoid func1(){\n cout<<\"Hello World\"<<endl;\n}\nvoid func1(){\n cout<<\"Yuxiang Guo\"<<endl;\n}\nint main(){\nfunc1(); //会产生冲突\n}\n```\n\n---\n```c++\nnamespace programm1{\n int func1(){\n cout<<\"Hello World\"<<endl;\n }\n}\nnamespace programm2{\nint func1(){\n\tcout<<\"Yuxiang Guo\"<<endl;\n}\n}\nint main(){\nprogramm1::func1(); //使用就不会产生冲突了\n}\n```\n---\n\n### 标准库类型string\nstring表示可变长的字符序列，使用string类型必须首先包含string头文件。\nstring is an array of character\n#include<string>\nusing std::string;\n\n#### 定义和初始化string对象\n```c++\nstring s1; //默认初始化，s1是一个空字符串\nstring s2 = s1；//s2是s1的副本\nstring s3 = \"hiya\"; //s3是该字符串字面值的副本\nstring s4(10, 'c'); //s4的内容是cccccccccc\n```\n#### string对象上的操作\n| 操作| 解释|\n|---|---|\n| os<<s| 将s写到输出流os中，返回os|\n| is>>s|从is中读取字符串赋给s，字符串以空白分隔，返回is|\n| getline(is, s)| 从is读取一行赋给s，返回is|\n| s.empty()| s为空返回true，否则返回false|\n| s.size()| 返回s中字符的个数|\n| s[n]| 返回s中的第n个字符的引用，位置n从0计起|\n| s1+s2| 返回s1和s2连接后的结果|\n| s1=s2| 用s2的副本代替s1中原来的字符|\n| s1==s2| 如果s1和s2中所含的字符完全一样，则他们相等|\n| s1!=s2| string对象的相等性判断对字母大小写敏感|\n| <, <=, >, >=| 利用字符在字典中的顺序进行比较，且对大小写敏感|\n\n#### 读写string\n\nstring对象会自动忽略开头空白并从第一个真正字符开始读起，直到遇到下一处空白位置。\n比如输入是`\"   Hello\tWorld   \"`读入的就是`Hello`。\n\n#### 使用getline读取一整行\n如果想要保留空格（空白符）读取，就要用getline()，getline只要一遇到换行符就结束读取操作并返回结果。\n`getline(cin, s)`读取输入的一整行直到换行符位置并把它赋值给s。触发getline函数返回的那个换行符实际上被丢弃掉了，得到的string对象并不包含换行符。\n\n#### 空格和空字符串区别\n从字符串的长度:——>空字符的长度为0,空格符的长度为1\n```c++\n    char a[] = \"\\0\"; //空字符串\n    char b[] = \" \"; //空格\n    cout << strlen(a) << endl;   //0\n    cout << strlen(b) << endl;   //1\n```\n#### empty和size操作\n**连续回车两下代表输入一个空字符！！！**\n每次读入一整行，输出其中超过80个字符的行\n\n```c++\n#include<string>\nusing std::string;\nusing std::cin;\nusing std::cout;\nusing std::endl;\nstring line;\nwhile(getline(cin, line)){\n\tif (line.size() > 80){\n\tcout<<line<<endl;\n\t}\n}\n```\n如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigned可能带来的问题。\n#### string::size_type类型\n对于size函数来说，返回的是一个string::size_type的类型的值，这是一种新的类型。string::size_type函数返回的是一个无符号的整型数。**如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigend可能带来的问题。**\n#### 比较string对象\n+ 如果两个string对象长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短string对象小于较长string对象\n+ 如果两个string对象在某些对应的位置上不一样，则string对象的比较结果其实是string对象中第一对想异字符比较结果\n```c++\nstring str = \"Hello\";\nstring phrase = \"Hello World\";\nstring slang = \"Hiya\";\n```\nstr < pharse\nslang > str\nslang > pharse\n#### 字面值和string对象相加\n算术类型、引用和指针都属于字面值类型。某些类也是字面值类型，它们可能含有constexpr函数成员。自定义类Sales_item、IO库、string类型不属于字面值类型。\n当把string对象和**字符字面值**及**字符串字面值**混在一条语句中使用时，必须确保每个加法运算符（+）的两侧至少有一个是string\n\n```c++\nstring s1 = \"Hello\" + \", \" //错误，“hello”类型是const char[5], \", \"类型是const char[3]，加号左右两边至少要有一个string\nstring s2 = \"Hello\"\nstring s1 = s2 + \", \"\t//正确\nstring s3 = s2 + \", \" + \"world\" //正确 等价于（s2 + \", \"）+ \"world\"\nstring s4  = \"Hello\" + \", \" + s2 //错误 等价于（\"Hello\" + \", \"） + s2\n```\n+ string对象可以和字面值相加\n+ 两个字面值不能相加\n+ 多个相加时注意加法的左结合律\n#### string和char*的区别\n在C++中，char仍然是一个primitive type（原始类型），而string已经经过封装，成为了一个class（类）用到它时，我们需要 #include <string>，它是C++ Standard Library （C++标准库）的一部分。\nC++中使用char*定义字符串，同样不能改变字符串内的字符的内容，但却可以把另外一个字符串付给它，相当于指针指向了另一个字符。\n\n```c++\n#include<iostream>\nusing namespace std;\nint main()\n{\n\tchar* pstr = \"hello world\";\n\tpstr = \"aa\";\n\tpstr[1] = \"a\";\t//报错\n\tcout<<pstr<<endl;\n}\n```\nC++中string的定义字符串，同样不能改变字符串内的字符，但却可以把另外一个字符串付给它\n```c++\n#include<iostream>\n#include<string>\nusing namespace std;\nint main()\n{\n\tstring str1;\n\tstr1= \"hello world\";\n\tstr1=\"aa\";\n\tstr1[1]=\"a\";\n\tcout<<str1<<endl;\n}\n```\n#### 处理string对象中的字符\n##### 处理字符串某个字符的函数\n| 函数        | 解释                                               |\n| ----------- | -------------------------------------------------- |\n| isalnum(c)  | 当c是字母或数字为真                                |\n| isalpha(c)  | 当c是字母时为真                                    |\n| iscntrl(c)  | 当c是控制字符时为真                                |\n| isdigit(c)  | 当c是数字时为真                                    |\n| isgraph(c)  | 当c不是空格但可打印时为真                          |\n| islower(c)  | 当c是小写字母时为真                                |\n| isprint(c)  | 当c是可打印字符时为真                              |\n| ispunct(c)  | 当c是标点符号为真                                  |\n| isspace(c)  | 当c是空白（空格）时为真                            |\n| isupper(c)  | 当c是大写字母时为真                                |\n| isxdigit(c) | 当c是十六进制数时为真                              |\n| tolower(c)  | 如果c是大写字母，输出对应的小写字母：否则原样输出c |\n| toupper(c)  | 如果c是小写字母，输出对应的大写字母：否则原因输出c |\n\n前面提到string是可变长的字符序列\n有三种方式可以访问其中的字符\n+ 范围for语句\n+ 下标运算符\n+ 迭代器\n##### 范围for语句\n用范围for语句比用普通for循环语句更加代码更加简洁。\n```c++\nstring str = \"some string\";\nfor (auto c: str){\t//输出str中的每个字符，通过使用auto让编译器来决定变量c的类型，这里的c是char/\n\tcout<<c<<endl;\n}\n```\n##### 使用范围for语句改变字符串中的字符\n```c++\nstring str = \"Hello world\";\nfor(auto& i : str){\t注意，这里i必须是引用，这样才能改变str中的值。\n\ti = toupper(i);\n}\ncout<<str<<endl;\t//输出的是“HELLO WORLD”\n```\n#### 下标运算符（只处理一部分字符）\ns[0]是第一个字符，s[s.size()-1]是最后一个字符\n\n---\n\n### 标准库类型vector\n标准库类型vector表示对象集合，其中所有**对象的类型都相同。**集合中的每个对象都有一个与之对应的索引，索引用于访问对象。vector是一个**类模版**（类模版不是类），由vector生成的类型必须包含vector中元素的类型，例如vector<int>。模版就是一个类，但是比如类中的某个attribute的类型可以作为变量让用户来自己选择。\n要想使用vector必须包含适当的头文件\n```c++\n# include<vector>\nusing std::vector;\n```\nvector的元素不能是引用，vector的元素也可以是一个vector：\n`vector<vector<int>>`\n学习vector的时候可以和string对比学习\n1. 定义和初始化\n2. 支持的操作\n3. 处理vector对象中的字符\n+ 范围for语句\n+ 下标运算符\n+ 迭代器\n\n#### 定义和初始化vector对象\n\n| 代码| 含义|\n|---|---|\n| vector<T> v1| v1是一个空的vector，它的潜在类型是T类型，执行默认初始化|\n| vector<T> v2(v1)| v2中包含了v1所有元素的副本|\n| vector<T> v2 = v1| 等价于v2(v1), v2中包含了v1所有元素的副本|\n| vector<T> v3(n, val)| v3包含了n个重复的元素，每个元素的值都是val|\n| vector<T> v4(n)| v4包含了n个重复地执行了初始化的对象|\n| vector<T> v5{a, b, c}| v5包含了初值个元素，每个元素被赋予了相对应的初始值|\n| vector<T> v5 = {a, b, c} | 等价于v5{a, b, c}|\n\n`vector<string> svector;`最常见的就是先定义一个空的vector，然后当运行时获取的元素再逐一添加，执行元素拷贝时，两个vector对象的类型必须相同。\n\n##### 列表初始化和创建指定数量的元素的比较\n+ 列表初始化，用花括号`vector<string> v1{\"a\", \"an\", \"the\"};`\n+ 创建指定的元素比较，用圆括号`vector<int> v2(10, -1);`10个int类型的元素，每个都被初始化为-1。`vector<string> v3(10, \"Hi\");`10个string类型的元素，每个都被初始化为Hi。\n\n如果vector不给赋处置，则默认：\n```c++\nvector<int> ivec(10);\t//10个元素，每个都初始化为0\nvector<string> svec(10);\t//10个元素，每个都初始化为空string对象\n```\n区分()和{}\n```c++\nvector<int> v1(10); // v1有10个元素，每个都是0\nvector<int> v2{10};\t//v2有一个元素，该元素的值时10\nvector<int> v3(10, 1);\t//v3有10个元素，每个值都是1\nvector<int> v4{10, 1};\t//v4有2个元素，分别是10和1\nvector<string> v5{\"hi\"};\t//v5有一个元素是“hi”\nvector<string> v6(\"hi\");\t//错误，不能使用字符串字面值构建vector对象\nvector<string> v7{10};\t//注意，类型是string，所以v7有10个默认初始化的元素\nvector<string> v8{10, \"hi\"};\t//v8有10个元素值为“hi”的元素\n```\n\n#### 向vector对象中添加元素\n先定义一个空的vector对象，再在运行时向其中添加具体值。使用`push_back`。如果循环体内包含了有向vector对象添加元素的语句，则不能使用范围for循环。\n```c++\nvector<int> v2;\nfor(int i; i <100; ++i){\n\tv2.push_back(i);\n}\n```\n#### 支持的操作\n|代码|含义|\n|---|---|\n|v.empty()| 如果v不含有任何元素，返回真；否则返回假|\n|v.size()| 返回v中元素的个数|\n|v.push_back(t)| 向尾端添加一个值为t的元素|\n|v[n]| 返回v中的第n个位置上的元素的**引用**|\n|v1 = v2| 将v2中的元素拷贝替换v1中的元素|\n|v1 = {a, b, c...}| 将列表中的元素拷贝替换v1中的元素|\n|v1 == v2| v1和v2相等当且仅当他们的元素数量相同且对应位置上的元素值都相同|\n|v1 != v2| ...|\n|<, <=, >, >=| 以字典顺序进行比较|\n\n---\n\n**访问vector对象的元素**\n赋值需要用引用\n```c++\nvector<int> v{1, 2, 3, 4, 5, 6, 7, 8, 9};\nfor (auto &i: v ){\t\n\ti *= i;\n}\n```\n只要vector对象不是一个常量，就能向下标运算符返回的元素赋值。\n**vector.size()的问题**\nvector 的size函数返回vector大小，返回值类型为size_type，Member type size_type is an unsigned integral type，即无符号整数；\nvector a;// 没有初始化时没有元素\na.size()返回一个无符号整型，当a的大小是0时，a.size() - 1返回一个正数18446744073709551615，导致访问越界。\n所以使用for循环的时候可以使用decltype()\n`for(decltype(v1.size()) i=0; i<v1.size(); ++i)`\n\n---\n\n### 迭代器\n使用迭代器可以访问容器的某个元素，迭代器也能从一个元素移动到另外一个元素。类似于指针类型，迭代器提供了对对象的间接访问。感觉迭代器就是指针加（索引index）的类型之和，比如说vector的迭代器，每个元素都有一个自己对应的迭代器，迭代器按照元素顺序排列，可以前后移动，如果要通过迭代器修改/访问元素，就用解引用符号。注意⚠️迭代器不是索引，它不是从0开始。v.begin()不是0，而且迭代器没有加法运算，只有减法运算。但是可以把迭代器和 两个迭代器之间的距离（iter1 - iter2相加），之后在iterator + difference_type来移动迭代器。\n在用mid = begin + (end - begin)/2的时候注意， end不是最后一位，而是尾元素之后的一位！\n\n#### 使用迭代器\n\n+ begin成员负责返回指向的第一个元素（或第一个字符）的迭代器。\n+ end成员则负责返回指向容器尾元素的下一个位置的迭代器，也就是说，该迭代器指示的是容器的一个根本不存在的“尾后”元素。\n如果容器为空，则begin和end返回的是同一个迭代器，都是尾后迭代器。\n```c++\nauto b = v.begin() //b表示v的第一个元素\nauto e = v.end() //e表示v尾元素的下一个位置\n// b和e的类型相同\n```\n#### 迭代器运算符\n用==和!=来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则他们相等，否则两个迭代器不相等。\n\n\n\n| 运算符         | 含义                                                     |\n| --- | --- |\n| *iter          | 返回迭代器iter所指元素的引用（解引用）                   |\n| iter->mem      | 解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem |\n| ++iter         | 令iter指示容器的下一个元素                               |\n| --iter         | 令iter指示容器的上一个元素                               |\n| iter1 == iter2 | 判断两个迭代器是否相等                                   |\n\n\n#### 将迭代器从一个元素移到另一个元素\n迭代器使用递增（++）运算符来从一个元素移动到下一个元素。因为end返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用操作。\n例子把string对象中的第一个单词改为大写形式\n```c++\nstring s = \"some string\";\nfor(auto iter = s.begin(); iter != s.end() && !isspace(*iter); ++iter){\n\t*iter = toupper(*iter);\n}\n```\n**for中使用!=而非<进行判断：因为这种风格在标准库提供的所有容器上都有效。只有string和vector等一些标准库类型有下标运算（s[0]），而并非全都如此。所以标准库容器的迭代器都定义了==和!=，但是它们中的大多数都没定义<运算符。因此要养成使用迭代器和!=的习惯，就不用太在意用的到底是哪种容器类型了。**\n\n#### 迭代器的类型\n那些拥有迭代器的标准库类型使用iterator和const_iterator来表示迭代器的类型：\n```c++\nvector<int>::iterator it1;  //\tit1能读写vector<int>中的元素\nstring:: iterator it2; // it2能读写string对象中的字符\n\nvector<int>::const_iterator it3;\t// it3只能读元素，不能写元素\nstring::const it4\t//it4只能读字符，不能写字符\n```\nconst_iterator和常量指针差不多，能读取但是不能修改所指的元素值。相反，iterator的对象可读可写。如果vector对象或string对象是一个常量，只能使用const_iterator；如果vector对象或string对象不是常量，那么既能使用iterator也能使用const_iterator。\n\n#### begin和end运算符\nbegin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator\n```c++\nvector<int> v;\nconst vector<int> cv;\nauto iter1 = v.begin(); //iter1的类型是vector<iter>::iterator;\nauto iter2 = cv.begin(); //iter2的类型是vector<iter>:: const_iterator;\nauto iter3 = v.cbegin(); //iter3的类型是vector<iter>:: const_iterator;\t\n```\n**结合解引用和成员访问操作**\n对一个由字符串组成的vector对象来说，想要检查其元素是否为空，令iter是该对象的迭代器，只需要检查iter所指字符串是否为空就可以了：`(*it).empty()`\n为了简化上述表达，c++语言定义了**箭头运算符**（->）。箭头运算符把解引用和成员访问两个操作结合在一起，也就是说，iter->mem和(*it).mem表达的意思相同。\n\n**但凡使用了迭代器循环体，都不要向迭代器所属的容器添加元素（push_back）。**\n\n#### 迭代器的运算\nstring和vector的迭代器提供了更多的额外的运算符\n|代码|含义|\n|---|---|\n|iter + n|迭代器加上一个整数值仍然得到一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的下一位置|\n|iter - n| 迭代器减去一个整数值仍然得到一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或指示容器内的一个元素，或者指示容器尾元素的头位置|\n|iter1+ = n|迭代器的复合赋值语句，将iter1加n的结果赋值给iter1|\n|iter1 -= n|迭代器的复合赋值语句，将iter1减n的结果赋值给iter1|\n|iter1 - iter2|两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器（iter2）向前移动的差值个元素后将得到左侧的迭代器（iter1）。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置|\n|>, >=, <, <=| 迭代器的关系运算符，如果迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者为元素的下一位置|\n\n\n```c++\nauto mid = vi.begin() + vi.size()/2; //计算得到最接近vi中间元素的一个**迭代器**\n```\n两个迭代器之间的距离（iter1 - iter2），它的类型是名为difference_type的带符号的整型数，string和vector都定义了difference_type，因为这个距离可正可负。\n\n#### 为什么mid =beg + (end - beg)/2而非 mid = (beg + end)/2\nC++并没有定义两个迭代器的加法运算，实际上直接把两个迭代器加起来是没有意义的。与之相反的，C++定义了迭代器的减法运算，两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动多少个元素后可以得到左侧的迭代器，参与运算的两个迭代器必须指向同一容器中的元素或尾后元素。另外，C++还定义了迭代器与整数的加减法运算，用以控制迭代器在容器中左右移动。\n\n在本题中，因为迭代器的加法不存在，所以 mid = (beg + end) / 2; 不合法。mid = beg + (end - beg) / 2; 的含义是，先计算 end - beg 的值得到容器中的元素个数，然后控制迭代器从开始出向右移动二分之一容器的长度，从而定位到容器正中间的元素。\n\n---\n\n### 数组\n数组与vector类似，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与vector不同的是，数组的大小确定不变，不能随意向数组中增加元素。\n**如果不清楚元素的个数，请使用vector。**\n\n数组长度不像vector和string可以用v1.size()\n只能用sizeof(a)/sizeof(a[0])来表示\nsizeof()函数可以返回数组所占的内存，而sizeof(a[0])返回的是数组第一个元素所占的内存。每个元素所占内存一致\n\n#### 定义和初始化内置数组\n\n+ 默认情况下，数组的元素被默认初始化（int是0，string是空...）\n+ 数组的维度必须是常量表达式\n+ 定义数组的时候必须指定数组类型\n+ 不允许用auto关键字由初始值的列表推断类型\n+ 数组的元素应为对象，不存在存放引用的数组\n+ 不允许将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值\n```c++\nunsigned cnt = 42; //不是常量表达式\nconstexpr unsigned sz = 42; //常量表达式\nint arr[10];\t//含有10个整数的数组\nint *parr[sz];\t//含有42个整型指针的数组\nstring bad[cnt];\t//错误，cnt不是常量表达式\nstring strs[get_size()];\t//当get_size是constexpr时正确；否则错误\n```\n#### 显式初始化数组元素\n```c++\nconst unsigned sz = 3;\nint ial[sz] = {0, 1, 2}; //含有3个元素的数组，元素值分别是0, 1, 2\nint a2[] = {0, 1, 2}; //维度是3的数组\nint a3[5] = {0, 1, 2}; //等价于a3[] = {0, 1, 2, 0, 0}\nstring a4[3] = {\"hi\", \"bye\"}; //等价于a4[] = {\"hi\", \"bye\", ''}\nint a5[2] = {0, 1, 2}; //错误：初始值过多超出范围\n```\n#### 字符数组\n字符数组有一种额外的初始化形式，可以用字符串字面值（string）对此类数组初始化。当使用这种方式时，一定要注意**字符串字面值的结尾处还有一个空字符**，但是如果不用string赋值，可以不加空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去：\n```c++\nchar a1[]  = {'c', '+', '+'}; // 列表初始化，没有空字符，用这种方式不需要强制加空字符\nchar a2[] = {'c', '+', '+', '\\0'}; // 列表初始化，含有显示的空字符\nchar a3[] = \"c++\"; // 自动添加表示字符串结束的空字符\nconst char a4[6] = \"Danial\"; // 错误，没有空间可存放空字符，用string初始化会自动添加空字符\n```\n#### 理解复杂数组声明\n+ 存放指针的数组\n+ 不存在存放引用的数组\n+ 数组的指针\n+ 数组的引用\n```c++\nint *ptrs[10]; // ptrs是含有10个整型指针的数组\nint &refs[10]; = /*?*/ // 错误：不存在存放引用的数组\nint (*Parray)[10] = &arr; // Parray 指向一个含有10个整型的数组\nint (&arrRef)[10] = arr; // arrRef 引用一个含有10个整数的数组\n```\n`int *ptrs[10]`定义的是一个大小为10的数组，它的名字是ptrs，然后知道数组中存放的是指向int的指针\n`int (*Parray)[10] = &arr` *Parray意味着Parray是个指针，Parray指向大小为10的int数组\n#### 主函数内外的初始值区别\n```c++\nstring sa[10];  \nint ia[10];\nint main(){\n\tstring sa2[10];\n\tint ia2[10];\n}\n```\n对于 string 类型的数组来说，因为 string 类本身接受无参数的初始化方式，所以不论数组定义在函数内还是函数外都被默认初始化为空串。\n对于内置类型 int 来说，数组 ia 定义在所有函数体之外，根据C++的规定，ia 的所有元素默认初始化为0；而数组 ia2 定义在 main 函数的内部，将不被初始化，如果程序试图拷贝或输出未初始化的变量，将遇到未定义的奇异值。**int类型在main函数内不会被默认初始化**\n\n#### vector和数组的区别\n数组与 vector 的相似之处是都能存放类型相同的对象，且这些对象本身没有名字，需要通过其所在位置访问。\n\n数组与 vector 的最大不同是，数组的大小固定不变，不能随意向数组中增加额外的元素，虽然在某些情境下运行时性能较好，但是与 vector 相比损失了灵活性。vector可以拷贝，数组不能拷贝。\n\n具体来说，数组的维度在定义时已经确定，如果我们想更改数组的长度，只能创建一个更大的新数组，然后原数组的所有元素复制到新数组中去。我们也无法像 vector 那样使用 size 函数直接获取数组的维度。如果是字符数组，可以调用 strlen 函数得到字符串的长度；如果是其他数组，只能使用 sizeof(array).sizeof(array[0]) 的方式计算数组的维度。\n#### 访问数组的元素\n\n+ 范围for语句\n+ 下标运算符\n\n在使用数组下标时，通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。\n\n#### 指针和数组\n使用数组的时候编译器一般会把它转化成指针。\n比如说`int a[5] = {1, 2, 3, 4, 5};`\n此时数组名称`a`就是一个指针，指向数组第一个元素。\n对`a`解引用`*a`得到的是数组第一个元素的值1。\n\n```c++\nstring nums[] = {\"one\", \"two\", \"three\"};\nstring *p = &nums[0]; // p指向nums的第一个元素\nstring *p = nums; //等价于p2 = &nums[0]\n```\n在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针\n\n在使用数组作为一个`auto`变量的初始值时，推断得到的类型是**指针**而非数组\n但是用`decltype()`时上述转化不会发生, decltype(ia)返回的类型是由10个整数构成的**数组**, 但是数组的内容可能是奇怪的值。\n\n```c++\nint ia[] = {0,1,2,3,4,5,6,7,8,9,10};\nauto ia2(ia); //ia2是一个整型指针，指向ia的第一个元素\ndecltype(ia) ia3 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; //ia3是一个含有10个整数的数组\n```\n#### 指针也是迭代器(指针遍历数组)\nvector和string的迭代器支持的运算，数组的指针也全都支持\n通过指针遍历数组有两种方法：\n+ 获取首元素和尾元素下一个位置的指针\n```c++\nint arr[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nint *p = arr; //定义p为首元素的指针\n++p;\t//p指向arr[1]\nint *e =&arr[10];\t//arr的尾元素是a[9], 这里指向了arr尾元素的下一位置\nfor(int *b = arr; b!= e; ++b){\n\tcout<<*b<<endl;\n}\n```\n注意⚠️一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与vector的end函数返回的与迭代器类似的功能。要特别注意，尾后指针不能执行解引用和递增操作。\n+ 使用标准库函数**begin**和**end**，必须要用iterator头文件\n```c++\n#include<iterator>\nusing std::begin;\nusing std::end;\nint ia[] = {0,1,2,3,4,5,6,7,8,9};\nint *beg = begin(ia);\t//指向ia元素的指针，注意给变量命名的时候不要用begin，end等关键字！\nint *last = end(ia); //指向arr尾元素的下一位置的指针,类型是int*而不是auto\n```\n注意区别和**vector的begin和end**\nbegin和end返回的具体类型由对象是否是常量决定，如果对象是常量，begin和end返回const_iterator；如果对象不是常量，返回iterator\n\n```c++\nvector<int> v;\nconst vector<int> cv;\nauto iter1 = v.begin(); //iter1的类型是vector<iter>::iterator;\nauto iter2 = cv.begin(); //iter2的类型是vector<iter>:: const_iterator;\nauto iter3 = v.cbegin(); //iter3的类型是vector<iter>:: const_iterator;\n```\n#### 指针运算\n给一个指针加上或减去某个整数值，结果仍然是指针。新指针指向的元素与原来的指针相比前进（后退了）该整数值个位置。但是移动不能超过尾元素的下一个位置。\n```c++\n\tconstexpr size_t sz = 5;\n\tint arr[sz] = {1,2,3,4,5}; \n\tint *ip = arr //指向arr数组第一个元素\n\tint *ip2 = ip + 4; //指向arr的尾元素arr[4]\n```\n\n和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一数组中的元素，而且指针运算没有加法，只有减法，但是也可以把指针和指针之间相减后的距离做加法运算。两个指针相减的结果的类型是`ptrdiff_t`的标准库类型，它和size_t一样，`ptrdiff_t`也是一种定义在cstddef头文件中的机器的相关类型。因为差值可能为负数，所以ptrdiff_t是一种带符号的类型。之前vector的迭代器之差的类型是`difference_type`。\n如果两个指针指向同一数组的元素，就能利用关系运算<, >, =进行比较\n\n```c++\nauto n = end(arr) - begin(arr)\n```\n#### 解引用和指针运算的交互\n指针加上一个整数所得的结果还是一个指针。假设结果指针指向了一个元素，则允许解引用该结果指针：\n``` c++\nint ia[] = {0, 2, 4, 6, 8};\nint last = *(ia + 4); // 把last初始化成8，也就是ia[4]的值。注意，要加上括号\n```\n#### 下标和指针\n\np[-2], []就等于*()\n\n```c++\nint *p = &ia[2];// p指向索引为2的元素\nint j = p[1]; //p[1]等价于*(p+1),就是ia[3]表示的元素\nint k = p[-2]; //p[-2]等价于*(p-2), 就是ia[0]表示的元素\n```\n### 总结\n\n#### 标准库类型string，vector\n\n##### string::size_type类型\n\n对于size函数来说，返回的是一个string::size_type的类型的值，这是一种新的类型。string::size_type函数返回的是一个无符号的整型数。**如果一条表达式中已经有了size()函数就不要再使用int了，这样可以避免混用int和unsigend可能带来的问题。**\n\n##### vector.size()\n\nvector 的size函数返回vector大小，返回值类型为size_type，Member type size_type is an unsigned integral type，即无符号整数；\nvector a;// 没有初始化时没有元素\na.size()返回一个无符号整型，当a的大小是0时，a.size() - 1返回一个正数18446744073709551615，导致访问越界。\n所以使用for循环的时候可以使用decltype()\n`for(decltype(v1.size()) i=0; i<v1.size(); ++i)`\n\n#### 标准库类型string，vector下标\n\n标准库类型的下标必须是无符号类型 unsigend\n\n#### 数组下标\n\n在使用数组下标时，没有强制要求通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计得足够大以便能够表示内存中任意对象的大小。\n\n#### 数组维度\n\n定义数组的维度必须是常量表达式。\n\n关于数组的拷贝，不可以将整个数组赋值给另一个数组，只能逐个元素的拷贝。\n如果利用vector，可以直接将整个vector拷贝给另一个vector。\n\n#### C风格字符串\n**c标准库string函数**\nc风格字符串不是一种类型，而是为了表达和使用字符串而形成的约定熟成的写法。按照此习惯书写的字符串放在字符数组中并以空字符结束，在字符串后面跟着（'\\0'），一般用指针来操作这些字符串。\ncstring头文件定义的函数\n\n| 代码| 含义|\n|---|---|\n| strlen(p)| 返回p的长度，空字符不计算在内 |\n| strcmp(p1, p2) | 比较p1和p2的相等性。如果p1 ==p2，返回0；如果p1>p2，返回一个正值；如果p1<p2,返回一个负值 |\n| strcat(p1, p2) | 将p2附加到p1之后，返回p1|\n| strcpy(p1, p2) | 将p2拷贝给p1|\n\n传入此类函数的指针必须指向以空字符作为结束的数组，但是空字符不会被计数在内。\nchar ca[] = {'C', '+', '+'};\t//不以空字符结尾\ncout<<strlen(ca)<<endl;\t\t//错误：ca中没有以空字符结束, 长度会被打印，但是打印长度会出现错误。\n#### 比较字符串\n+ string对象的比较\n```c++\nstring s1 = \"A string example\";\nstring s2 = \"A different string\";\nif (s1<s2) //false: s2小于s1\n-----------------------------------------------\n//string的加法操作\nstring largeStr = s1 + \" \" + s2;\n```\n+ c风格字符串\n```c++\nconst char ca1[] = \"A string example\";\nconst char ca2[] = \"A different string\";\nif (ca1<ca2) //\t未定义，ca1和ca2是指向数组首地址的指针，两个指针指向的并非同一对象，所以将得到为定义的结果\nif(strcmp(ca1, ca2)<0) //和两个string对象比较s1<s2效果一样\n------------------------------------------------\nconst char ca1[] = \"A string example\";\nconst char ca2[] = \"A different string\";\nconst char ca3 = ca1 + ca2; //错误，两个指向不同对象的指针相加，无意义\nstrcpy(largeStr, ca1); //把ca1拷贝给largeStr\nstrcat(largeStr, \" \");\t//在largeStr的末尾加上一个空格\nstrcat(largeStr, ca2);\t//把ca2连接到largeStr后面\n}\n```\n**对于大多数应用来说，使用标准库string要比使用c风格字符串更安全，更高效**\n`while(空字符)`就会停止循环\n\n---\n\n### 多维数组\n当一个数组的元素仍然是数组时，通常用两个维度来定义它：一个维度表示数组本身的大小，另外一个维度表示其元素（也是数组）大小：\n```c++\nint ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组\nint arr[10][20][30]; = {0}; //将所有元素初始化为0\n```\n对于二维数组来说，常把第一个维度称作行，第二个维度称作列。\n#### 多维数组的初始化\n```c++\nint ia[3][4] = {\t//三个元素，每个元素都是大小为4的数组\n{0,1,2,3},\t//第一行的初始值\n{4,5,6,7},\t//第二行的初始值\n{8,9,10,11}\t//第三行的初始值\n}\n//没有标识每行的花括号，与之前的初始化语句是等价的\nint ia[3][4] = {0,1,2,3,4,5,6,7,8,9,10,11};\n// 显示地初始化每行的首元素\nint ia[3][4] = {{0},{4},{8}};\n//显示地初始化第一行的四个元素，其他元素执行默认初始化为0\nint ix[3][4] = {0, 3, 6, 9};\n```\n#### 多维数组的下标引用\n如果表达式含有的下标运算符数量和数组的维度一样多，该表达式的结果将是给定类型的元素。\n如果表达式的下标运算符数量比数组维度小，则表达式的结果将是给定索引处的一个内层数组。\n```c++\nia[2][3] = arr[0][0][0]; //用arr的首元素为ia最后一行的最后一个元素赋值\nint (&row)[4] = ia[1]; //把row绑定到ia的第二个4元素数组上\n```\n把row定义成一个含有4个元素整数的数组的引用（是数组的引用，而不是存放引用的数组（数组的元素必须是对象，不能是引用）），然后将其绑定到ia的第2行。\n\n#### 用for语句处理多维数组\n##### 使用两层嵌套for语句\n```c++\nconstexpr size_t rowCnt = 3, colCnt = 4;\nint ia[rowCnt][colCnt]; //12个为初始化的元素\n// 对于每一行\nfor (size_t i = 0; i !=rowCnt; ++i){\n//对于每一列\n\tfor(size_t j = 0; j!=colCnt; ++j){\n\t//将元素的位置索引作为它的值\n\tia[i][j] = i*colCnt + j;\n\t}\n}\n```\n##### 使用范围for循环\n```c++\nsize_t cnt = 0;\nfor (auto &row : ia){\n\tfor(auto &col : row){\n\t\tcol = cnt;\n\t\t++cnt;\n\t}\n}\n```\n因为要改变元素的值，所以得把**控制变量row和col声明成引用类型。**\n**使用范围for语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。**\n原因：因为为了避免数组被自动转化成指针。假设不用引用类型：\n```c++\nfor (auto row : ia){\n\tfor(auto col : row ){\n\t\t\n\t}\n}\n```\n程序将无法通过编译。因为，像之前一样第一个循环遍历ia的所有元素，注意这些元素实际上是大小为4的数组。因为row不是引用类型，所以编译器初始化row时会自动将这些数组形式的元素（和其他类型的数组一样）转化成指向该数组首元素的指针。这样得到的row的类型就是int\\*，显然内层循环就不合法了，编译器将试图在一个int\\*内遍历，这肯定不行了。\n\n#### 指针和多维数组\n当程序使用多维数组的名字时，也会自动将其转化成指向数组首元素的指针。\n因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是**指向第一个内层数组的指针**：\n\n```c++\nint ia[3][4]; // 大小为3的数组，每个元素是含有4个整数的数组\nint (*p)[4] = ia; //p指向含有4个整数的数组\np = &ia[2]; // p指向ia的尾元素\n```\n区别\n```c++\nint *ip[4];\t//整型指针的数组，存放了4个指针的数组 \nint(*ip)[4];\t//指向含有4个整数的数组 是一种类型\n```\n使用指针遍历多维数组\n```c++\nfor (auto p = ia; p != ia+3; ++p ){ // auto p  = ia指向ia的第一行，p+1指向ia的第二行，p+2指向ia的第三行\n\tfor(auto q = *p; q!=*p+4; ++q ){ //*p是一个含有4个整数的数组, 所以auto q = *p，q 指向数组的首地址\n\tcout<<*q<<endl;\n\t}\n}\n```\n也可以通过begin和end实现同样功能\n\n```C++\nfor (auto p = begin(ia); p != end(ia); ++p){\n\tfor (auto q = begin(*p); q!=end(*p); ++q){\n\t\tcout<<*q<<endl;\n\t}\n}\n```\n#### 类型别名简化多维数组指针\n```c++\nusing int_array = int[4]; \ntypedef int int_array[4];\n```\n\n#### 多维数组用for遍历输出区别比较\n```c++\nint ia[3][4] = {{1,2,3,4},\n          \t\t\t{5,6,7,8},  \n          \t\t\t{9,10,11,12}};\n```\n##### 使用范围for循环输出\n```c++\nfor(int (&row)[4] : ia){ //注意：外层一定要有引用\n        for(int col: row){\n            cout<<col<<' ';\n        }\n        cout<<endl;\n    }\n```\n可以使用auto 来替代复杂的数据类型类型\n```c++\nfor(auto &row : ia){ //注意：外层一定要有引用\n        for(auto col: row){\n            cout<<col<<' ';\n        }\n        cout<<endl;\n    }\n```\n##### 使用普通for循环 + 下标运算符\n```c++\nfor (size_t i = 0; i!=3; i++)\n    {\n        for (size_t j = 0; j!=4 ; j++)\n        {\n            cout<<ia[i][j]<<' ';\n        }\n        cout<<endl;\n        \n    }\n```\n##### 使用普通for循环 + 指针\n```c++\n for(int(* p)[4] = ia; p != ia+3; ++p)// 注意 int(*p)[4]是一种类型：指向一个有4个整型元素的数组的指针,ia是指向第一个内层数组的指针\n    {\n        for(int *q = *p; q!= *p+4; ++q)//p是指向一个有4个整型元素的数组的指针，*p是一个有4个整型元素的数组，q是指向数组的首地址的指针\n        {cout<<*q<<\" \";}\n        cout<<endl; \n    }\n```\n可以使用auto 来替代复杂的数据类型类型\n```c++\nfor(auto p = ia; p != ia+3; ++p)// 注意 int(*p)[4]是一种类型：指向一个有4个整型元素的数组的指针,ia是指向第一个内层数组的指针\n    {\n        for(auto q = *p; q!= *p+4; ++q)\n        {cout<<*q<<\" \";}\n        cout<<endl; \n    }\n```","tags":["C++"]},{"title":"C++中string和char的比较","url":"/2020/06/13/C-中string和char的比较/","content":"\n在C++中要想表达字符串有三种可能的方法：\n+  用Standard Library （C++标准库）定义的类string：\nstring表示可变长的字符序列，使用string类型必须首先包含string头文件。\n+ 用C风格字符串char\\*：\nchar\\*定义的是一个字符类型的指针，指向字符串数组的首地址。\n+ 用C风格字符串char []：\nchar[]定义了一个类型为字符的数组。\n\nc风格字符串不是一种类型，而是为了表达和使用字符串而形成的约定熟成的写法。按照此习惯书写的字符串放在字符数组中并以空字符结束，在字符串后面跟着（’\\0’），一般用指针来操作这些字符串。\n\n## 空字符('\\0')和空格符(' ')\n1. 从字符串的长度:——>空字符的长度为0,空格符的长度为1\n```c++\nint main() {\n    char c[] = \"\\0\";\n    char d[] = \" \";\n    cout<<strlen(c)<<endl; //结果是0\n    cout<<strlen(d)<<endl;\t//结果是1\n}\n```\n2. 虽然输出于屏幕是一样的,但是他们还是有区别的:\n```c++\nint main() {\n    char c[] = \"a b\";\n    char d[] = \"a\\0b\";\n    cout<<c<<endl; // 结果是a b\n    cout<<d<<endl;\t//结果是a，因为遇到空字符就自动结束了\n}\n```\n\n\n## 初始化\n\n### string的初始化\n\n```c++\nstring s1; //默认初始化，s1是一个空字符串\nstring s2 = s1；//s2是s1的副本\nstring s3 = \"hiya\"; //s3是该字符串字面值的副本\nstring s4(10, 'c'); //s4的内容是cccccccccc\n```\n### char\\*的初始化\n```c++\nchar *s1 = \"Hello world\";\nchar *s2 = {'c','+','+'}; // 错误，指针不能这样初始化\n```\n### char[] 的初始化\n```c++\nchar a1[]  = {'c', '+', '+'}; // 错误！a1没有以空格结束！使用strlen(a1)将会产生错误长度。strlen可能沿着a1在内存中不断向前寻找，知道遇到空字符才停下来。\nchar a2[] = {'c', '+', '+', '\\0'}; // 列表初始化，含有显示的空字符\nchar a3[] = \"c++\"; // 自动添加表示字符串结束的空字符\nconst char a4[6] = \"Danial\"; // 错误，没有空间可存放空字符，用string初始化会自动添加空字符\n```\n\n\n## 赋值\n\n### string的赋值\n对于string类而言，允许把一个对象的值赋给另外一个对象。\n```c++\nstring s1 = \"hello world\";\nstring s2 = s1;\ns1[1] = 'a'; //\t输出hallo world\n```\n\n### char \\*的赋值\nchar \\*是一个char型指针变量，其值（指向）可以改变。可以把其他字符串赋值给char\\*，实际上的操作是把其他字符串的首地址存放到char\\*指针变量里。修改的为指针变量的值，不是修改字符串常量，是变量赋值操作。\n```c++\nchar *s1 = \"hello world\";\ns1 = \"xuexuexue\"; // 修改了s1作为指针的指向，从指向hello world的首地址改为指向想xuexuexue\nchar *s2 = s1; //正确，把s1地址的值赋给了指针s2\ns1[1] = 'a'; //错误，指针无法这样操作 \n```\n### char []的赋值\n\nchar b[]: b是一个char型数组的名字，也是该数组首元素的地址，是**常量**，其值不可以改变 。但是可以修改其元素的值。\n```c++\nchar s1[] = \"hello world\";\ns1 = \"nihao\"; //错误 s1是该数组原属的首地址，是常量，无法修改\nchar s2[] = s1; //错误 不能这样赋值\ns1[1] ='a'; //正确，可以修改数组元素\n```\n\n\n## 显示长度\n### string显示长度\n使用`.size()`\n```c++\nstring s = \"hello world\";\ncout<<s.size()<<endl;\n```\n### char\\*和char []显示长度\n\n使用`strlen()`\n```c++\nchar s1[] = \"hello world\";\nchar *s2 = \"Hallo Welt\";\ncout<<strlen(s1)<<strlen(s2)<<endl;\n```\n\n\n## 比较\n### string比较\n+ 如果两个string对象长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短string对象小于较长string对象\n+ 如果两个string对象在某些对应的位置上不一样，则string对象的比较结果其实是string对象中第一对想异字符比较结果\n```c++\nstring s1 = \"A string example\";\nstring s2 = \"A different string\";\nif (s1 < s2) //false:s2<s1\n```\n\n### c风格字符串比较\n实际比较的是指针而非字符串本身。\n```c++\nconst char ca1[] = \"A string example\";\nconst char ca2[] = \"A different string\";\nif(ca1 < ca2) //未定义：试图比较两个无关地址\n```\n\n## 连接合并\n### string连接合并\n\n当把string对象和**字符字面值**及**字符串字面值**混在一条语句中使用时，必须确保每个加法运算符（+）的两侧至少有一个是string\n\n```c++\nstring s1 = \"Hello\" + \", \" //错误，“hello”类型是const char[5], \", \"类型是const char[3]，加号左右两边至少要有一个string\nstring s2 = \"Hello\"\nstring s1 = s2 + \", \"\t//正确\nstring s3 = s2 + \", \" + \"world\" //正确 等价于（s2 + \", \"）+ \"world\"\nstring s4  = \"Hello\" + \", \" + s2 //错误 等价于（\"Hello\" + \", \"） + s2\n```\n+ string对象可以和字面值相加\n+ 两个字面值不能相加\n+ 多个相加时注意加法的左结合律\n\n### char\\* 和char []连接合并\n需要先用`strcpy(p1, p1)`复制给一个新的数组（数组空间足够大），然后用`strcat(p1, p2)`添加合并。char\\* 和char []可以合并。\n```c++\nchar s1[] = \"hello world\";\nchar *s2 = \"toll\";\nchar largeStr[100]; //新的数组空间必须足够大\nstrcpy(largeStr, s1); //把s1赋值给largeStr\nstrcat(largeStr, \" \"); //在largeStr后添加空格\nstrcat(largeStr, s2);\t//在新的带空格的largeStr后添加s2\n```\n## string和char\\*，char []之间的相互转化\n### char\\*，char[]----> string\n\nchar\\*----> string 一般来说都可以直接赋值转换\n任何出现**字符串字面值**（“Hello World”）的地方都可以用**空字符结束结束的字符数组**来替代：\n+ 允许使用以空字符结束的字符数组来初始化string对象或为string对象赋值。\n+ 在string对象的加法运算中允许用以**空字符结束的字符数组**作为其中一个运算对象（不能两个都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧运算对象。\n```c++\nchar s1[] = \"hello world\";\nchar *s2 = \"heloo woold\";\nstring s3 = s1;\nstring s4 = s2;\n```\n### string----> char\\*,char[]\n\n如果程序的某处需要一个C风格字符串，无法直接用string对象来替代它。不能用string对象直接初始化指向字符的指针。`c_str()`函数返回的是一个指针，该指针对象指向一个以空字符串结束的字符数组，而数组所存的数据恰好与那个string对象一样。结果指针的类型是const char\\*,从而确保我们不会改变字符数组的内容。\n```c++\nstring s = \"hello world\"\nchar *str = s;\t//错误：不能用string对象初始化char*\nconst char *str = s.c_str(); //正确\n```","tags":["C++"]},{"title":"C++Primer第一章和第二章笔记","url":"/2020/06/09/C-Primer第一章和第二章笔记/","content":"\n## 第一章\n### 读取数量不定的输入数据\n```C++\nwhile (std::cin>>value)\n```\nwhile 会一直执行直到遇到文件结束符（或错误输入）。\n\ncin.get()是保留回车在输入流队列中的，\n而cin是丢弃回车的。\nch=cin.get();是第一次输入，因为是刚开始，所以没有回车保留在输入流的队列中。这时你输入一个字符，然后回车。get()收到回车或空格或制表符就停止输入了、此时，输入流队列中留下一个回车。\n```c++\nunsigned spaceCnt = 0, tabCnt = 0, newlineCnt = 0;\nchar ch;\nwhile(cin>>ch){ //如果就这样写的话输入空格，制表符或者换行符等都会被cin丢弃，所以数量无论如何输入都会现实0.\n\tif (ch = ' ')\n\t\tspaceCnt++;\n\tif (ch = '\\t')\n\t\ttabCnt++;\n\tif (ch = '\\n')\n\t\tnewlineCnt++;\n\t\n---\n\n\twhile(cin.get(ch)){//这样写正确，空格，制表符或者换行符等都会被读入\n\t\tif (ch = ' ')\n\t\t\tspaceCnt++;\n\t\tif (ch = '\\t')\n\t\t\ttabCnt++;\n\t\tif (ch = '\\n')\n\t\t\tnewlineCnt++;\n\t\n\t}\n}\n```\n\n## 第二章（变量和基本类型）\n### 基本数据类型\n当我们把一个非布尔类型的算数值赋给布尔类型时，初始值为0则结果为false，否则结果为true。\n当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为0，初始值为true则结果为1。\n\n---\n|类型|含义|最小尺寸|\n|---|---|---|\n|bool|布尔类型|未定义|\n|char|字符|8 bit|\n|wchar_t|宽字符|16 bit|\n|char16_t|Unicode字符|16 bit|\n|char32_t|Unicode字符|32 bit|\n|short|短整型|16 bit|\n|int|整型|16 bit|\n|long|长整型|32 bit|\n|long long|长整型|64 bit|\n|float|单精度浮点数|32 bit|\n|double|双精度浮点数|64 bit|\n|long double|扩展精度浮点数|96 or 128 bit|\n\n---\n当一个算数表达式中既有无符号数又有int时，那个int值就会转成无符号数。比如：\nunsigned u = 10;\nint i = -42\nstd::cout<< u + i << std::endl; 如果int占32位，输出4294967264。\n\n---\n以0开头的整形代表8进制，以0x或0X的开头代表十六进制。\n科学计数法，其中指数部分用E或e标识。50 = 5e1, 0.01 = 1e-2\n\n---\n单引号字符char，双引号字符串。\n字符串String字面值的类型实际上是由常量字符构成的数组（array）。\n编译器在每个字符串的结尾处添加一个空字符（'\\0')，因此，字符串字面值的实际长度要比他的内容多1。例如，字面值'A'表示的是单独的字符A，而字符串\"A\"则代表了一个字符的数组，该数组包含两个字符：一个是字母A，另一个是空字符。\n\n---\n'a'就是char，L'a'就是wchar_t\nchar占一个字节，wchar_t占两个字节，也就是16个比特（bit），最大值就是2<sup>16</sup>-1=65535，到这里读者可以看出宽字符和窄字符最大的区别就是占字节大小的不同\n![unicode](unicode.png)\n\n10u: unsigned\n3.14L: Long double\n如'\\012'就是八进制数012所对应的字符，也就是ASCII码10所对应的字符，即换行\n\n**需要注意的是转义序列在程序中是被当作字符而不是字符串来使用的**\n\n```c++\ncout<<'2'<<'\\t'<<'M'<<'\\n';\n```\n### 变量\n#### 默认初始化\n三条性质：\n\n1.定义在任何函数体外的变量会被初始化为0。 \n\n2.定义在函数体内部的变量不会被初始化。 \n\n3.类的对象未被初始化，则初值由类决定。\n\n#### 声明(declaration)和定义(definition)\n\ndeclaration: say the function exists. 在一个cpp文件中调用另一个cpp文件（一个函数），需要在cpp中声明这个被调用的函数\n\ndefinition: what the function is.\n\n①变量定义：用于为变量分配存储空间，还可为变量指定初始值。程序中，变量有且仅有一个定义。\n\n②变量声明：用于向程序表明变量的类型和名字。\n\n③定义也是声明：当定义变量时我们声明了它的类型和名字。\n\n④extern关键字：通过使用extern关键字声明变量名而不定义它。\n\n1、定义包含了声明，但是声明不包含定义，\n\n如  int a = 0; //定义并声明了变量 a\n\nextern int a;  //只是声明了有一个变量 a 存在，具体 a 在哪定义的，需要编译器编译的时候去找。\n2、函数也是类似，定义的时候同时声明。但如果只是声明，编译器只知道有这么个函数，具体函数怎么定义的要编译器去找。\n\nvoid fun1();  //函数声明\n\nvoid fun1(){  //函数定义\n    cout<<\"fun1\"<<endl;\n}\n\n---\n\n### 复合类型(具体见另一篇文章)\n#### 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）\n为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化(比如 int &a = b, 之前已经定义b = 10)，使它指向一个已存在的对象(b)\n\n例如：\n\nint i, j;\n\nint &ri = i\t//定义int的引用ri，并初始化为变量i的引用 \n\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n\n#### 指针\n\n可以通过指针来间接访问内存\n##### 定义指针\nint a =10;\n数据类型 * 指针变量\nint * p; \n让指针记录变量a的地址， &这个操作符就是取地址。\np = &a；\n\n##### 使用指针\n可以通过解引用的方式来找到指针的内存，找到指针p（原数据的地址）中的原数据\n* p = 1000；//更改之后a的值也变为1000\n##### 指针所占用的内存空间\n在32位操作系统：占用4个字节\n在64位操作系统：占用8个字节(所有指针，int *，float * ，char *......)\n##### 空指针和野指针\n空指针：指针变量指向内存为0的空间\n用途：初始化指针变量\n注意：空指针指向的内存是不可以访问的, 0~255为系统占用内存\nint * p = NULL;\n\n---\n野指针：指针变量指向非法的内存空间\nint * p = (int * )0x1100; 自己定义的一个16进制数，自己定义的一块内存\n\n### const限定符  \n#### 常量表达式\n常量表达式（**const expression**）是指**不会改变**并且**在编译过程就能得到计算结果**的表达式。\n常量表达式主要是允许一些计算发生在编译时，即发生在代码编译而不是运行的时候。这是很大的优化：假如有些事情可以在编译时做，它将只做一次，而不是每次程序运行时。需要计算一个编译时已知的常量，比如特定值的sine或cosin？确实你亦可以使用库函数sin或cos，但那样你必须花费运行时的开销。使用constexpr，你可以创建一个编译时的函数，它将为你计算出你需要的数值。用户的电脑将不需要做这些工作。\n一个对象是不是常量表达式由它的数据类型和初始值共同决定：\n\n```c++\nconst int max_files = 20;\t// 是常量表达式\nconst int limit = max_files + 1 //是常量表达式\nint staff_size = 27; // 不是常量表达式\nconst int sz = get_size();\t// sz不是常量表达式\n```\n\n尽管staff_size的初始值（27）是个字面常量值，但是由于它的数据类型只是个普通的int而非const int所以不属于常量表达式\n尽管sz本身是个常量，但是具体值到运行时才能获取到，所以也不是常量表达式\n**常量表达式就是等号左右两边都是常量的表达式。**\n一般来说，如果你认定变量是一个常量表达式，那就把它声明成constexpr类型\n\n```c++\nconstexpr int mf = 20;\t//20是常量表达式\nconstexpr int limit = mf + 1; //mf + 1是个常量表达式\nconstexpr sz = size();\t//只有当size是一个constexpr函数时才是一条正确的声明语句\n```\n常量表达式必须是**字面值类型**：算数类型，引用类型和指针类型。\n**非字面值类型**：自定义类Sales_item, IO库，String类不属于字面值类型，也就不能被定义成constexp指针的初始值必须是nullptr或者是0，或者是储存于某个固定地址中的对象。\n函数体内定义的变量一般来说并非存放在固定地址中，因此constexpr指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其固定地址不变，能用来初始化constexpr指针。\nconstexpr声明中如果定义了指针，限定符constexpr仅对指针有效，与指针所指的对象无关：\n\n```c++\nconst int *p = nullptr;\t//p是一个 指向整型常量 的指针\nconstexprint *p = nullptr;\t//q是一个 指向整数 的 常量指针\n```\n\n---\n### 处理类型\n#### 类型别名\n有两种方法可以定义类型别名。\n+ 传统的方法是使用关键字**typedef**：\n```c++\ntypedef double wages;\t//wages是double的同义词,之后出现wages就和出现double一样\nwages x = 10.1；\ntypedef wages base, *p; //base是double的同义词，p是double*的同义词\n```\n+ 使用别名声明来定义类型的别名：\n相对来说更加直观、简单\n```c++\nusing SI = Sales_item; //SI是Sales_item的同义词\nusing x = double; \nx number = 666.66//之后使用x就像使用double一样\n这种方法的关键字using作为别名声明的开始，其后紧跟别名和等号，起作用是把等号左侧的名字规定成等号右侧的类型的别名。\n```\n#### auto类型说明符\nauto类型说明符：auto让编译器通过初试值来推算变量的类型。auto定义的变量必须有初始值。\n```c++\nauto item = val1 + val2;\n```\n此处编译器将根据val1和val2相加的结果来推断item的类型。如果val1和val2是类Sales_item的对象，则item的类型就是Sales_item;如果这两个变量类型是double，则item的类型就是double，以此类推。\n##### 复合类型，常量和auto\n使用引用其实是使用引用的对象，特别是当被用作为初始值时，真正参与初始化的其实是引用对象的值。\n```c++\nint i = 0, &r = i;\nauto a = r; // a是一个整数（r是i的别名，而i是一个整数）\n```\nauto会忽略掉顶层const（常量指针），同时底层const（指向指针的常量）则会保留下来，比如当初始值是一个指向常量的指针时。\n但是\n\n```c++\nconst int ci = i, &cr = ci;\nauto b = ci; //b是一个整数（ci的顶层const特性被忽略了）\nauto c = &i; //c是一个整型指针\nconst auto f = ci； //如果希望推出的auto类型是一个顶层const，则需要明确指出\n```\n注意！！\n```c++\nconst int i = 42;\nauto *p = &i;//此时p的类型是const int*，指向指针的常量，底层const不会被忽略。\n```\n#### decltype\n作用：希望从表达式的类型推断出要定义的变量，但是不想用该表达式的值初始化变量。它的作用是选择并返回操作数的数据类型。\n```c++\ndecltype(f()) sum = x;\t//sum的类型就是函数f的返回类型\n```\n如果decltype使用的表达式是个变量，则decltype返回该变量的类型（包括顶层const和引用在内）：\n```c++\nconst int ci = 0, &cj = ci;\ndecltype(cj) x = 0;\t//x的类型是const int\ndecltype(cj) y = x; //y的类型是const int&，y绑定到变量x\ndecltype(cj) z; //错误：z是一个引用，必须初始化\n```\ndecltype和引用\n```c++\nint i =42, *p = &i, &r = i;\ndecltype(r) = a; //a是int引用类型和通过引用r和i绑定\ndecltype(r+0) b; //正确，加法的结果是int，因此b是一个（未初始化的）int\ndecltype(*p) c; //错误，c是int&，必须初始化\n\ndecltype((i)) d; //错误，d是int&，必须初始化\ndecltype(i) e; //正确，e是一个未初始化的int\n```\n对于decltype：\n+ 推测引用变量本身的类型得到的仍是引用\n+ 如果表达式的内容是解引用操作（\\*p），decltype将得到引用类型\n+  推测变量的类型时，如果多加了一层括号，结果差别很大。双层括号的结果永远是引用，而decltype（variable）单层括号结果只有当varible本身就是一个引用时才是引用。\n\n---\n**总结一下上面的区别**\n\n+ typedef, using: 把一些double，int等已知的数据类型重命名，命名成自己想要的名称。\n+ auto：通过初始值来推算变量的数据类型\n+ decltype：把某一个变量的数据类赋给另一个变量，让这两个数据变量类型相同。\n\n**auto和decltype的区别**\n如果面对一个变量是引用，那么auto会把那个类型看作是和该引用绑定对象的类型（int），而decltype会把它看作是引用本身的引用类型（int &）\n```c++\nint i = 42, &r = i;\nauto a = r; //a的类型是int（和r绑定的对象的类型）\ndecltype(r) b = i; //b的类型是引用int&，所以必须初始化和对象i绑定\n```\n\n---\n### 自定义数据结构\n数据结构是把一组相关的数据元素组织起来然后使用他们的策略和方法。就比如说int就是把所有整数作为一种数据类型，所以我们也可以自己定义某一类具有共同点的元素作为数据类型。\n比如说Sales_data类型\n```c++\nstruct Sales_data{\n\tstd::string bookNo; //书的编号\n\tunsigned units_sold = 0; // 卖出的数量，无符数\n\tdouble revenue = 0.0; //收入\n}\n```\n自定义数据结构以关键字struct开始，紧跟着类名和实体，最后的分号不能省略\n还有一种自定义结构以class作为关键字，也就是常说的类。以后会经常遇到。\n#### struct和class的区别\n在C++中struct和class的唯一区别就在于**默认的访问权限不同**, 继承的时候不推荐使用struct\n+ struct默认权限为public\n+ class默认权限为private\n```c++\nclass C1{\n\tint a;\n};\nstruct C2{\n\tint a;\n};\nint main(){\n\tC1 c1; //实例化\n\tc1.a = 10; //错误，默认的情况下class的成员为private，只能在类内访问，不能在类外访问\n\tC2 c2；\n\tc2.a = 10； //正确，默认的情况下struct的成员为public，既能在类内访问，又能在类外访问\n}\n```\n类内部定义的名字必须唯一，但是可以与类外部定义的名字重复。\n类体右侧的表示结束的花括号后必须写一个分号，因为类体后面可以紧跟变量名以示对该对象的定义所以分号不可少。\n#### 类数据成员（attribute）\n+ 类的数据成员定义了类的对象的具体内容\n+ 每个对象有自己的一份数据成员拷贝\n+ 修改一个数据成员，不会印象其他对象\n+ 创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化（0，空字符...）。\n\n#### 头文件\n为了确保各个文件中类的定义一致，类通常被定义在头文件中，而且类所在头文件的名字应与类的名字一样，例如把Sales_data类定义在名为Sales_data.h的头文件中。\n头文件通常包含那些只能被定义一次的实体，如类、const变量和constexpr变量等\n##### 头文件的书写规范\n+ #include\"header.h\" //表明当前文件和\"header.h\"处于同一工程且同一目录，一般是自己的类文件\n+ #include<header.h> //表明header.h和当前文件不属于同一工程，是外部目录，一般是标准库\n##### 头文件保护符（header guard）\n就是为了在主文件中如果多次引用了某个头文件的话，第一次引用会把头文件拷贝进主文件，之后再引用，就不要再把头文件再拷贝过来一次。\n**/#define** 指令把一个名字设置为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：**#ifdef** 当且仅当变量已定义时为真，**#ifndef** 当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到**#endif**指令为止。这些功能就能有效地防止重复包含的发生：\n```c++\n# ifndef SALES_DATA_H // 如果没有定义过SALES_DATA_H\n# define SALES_DATA_H// 那么定义SALES_DATA_H\n# include<string>\nstruct Sales_data{\n\tstd::string bookNo;\n\tunsigned units_sold = 0;\n\tdouble revenue = 0.0;\n}\n# endif\n```\n后面如果再一次包含Sales_data.h,则#ifndef的检查结果将为假，编译器将会忽略#ifndef到#endif之间的部分。\n\n\n\n\n","tags":["C++"]},{"title":"引用和指针","url":"/2020/05/29/引用和指针/","content":"# 引用\n引用（&）是标识符的别名（引用并非为对象，相反的，它只是为一个已经存在的对象所起的另外的名字）。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。\n定义一个引用时，必须同时对它进行初始化，使它指向一个已存在的对象。\n一旦一个引用被初始化后，引用和初始值对象绑定在一起，就不能改为指向其他对象\n对引用进行修改，也就是等于对和引用绑定的对象进行修改。(可以把绑定之后的引用和对象看成一种东西)\n通常类的数据量较大，采用传值的方式传递和返回对象会调用拷贝构造函数进行对象的拷贝操作，会带来大量内存空间的开辟和释放，导致性能的损耗、降低效率。因此通常采用引用或指针的方式进行对象的传递，而实际上针对对象的操作通常都使用引用来进行。\n```c++\nint a = 10;\nint & ref = a;\nref = 20; //此时a的值也是20。\n```\n## 引用传参\n用一个例子解释引用的作用。\n```c++\n#include <iostream>\n#include \"Sales_item.h\"\nusing namespace std;\nvoid func1(int a){\n    a = a*3;\n}\n\nvoid func2(int & a){\n    a = a*3;\n}\n\nint main() {\n    int b = 10;\n    func1(b);\n    cout<<b<<endl; // 此时b = 10。\n    func2(b);\n    cout<<b<<endl;// 此时b = 30。\n}\n```\n### 使用函数1的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc1(b）等价于func1(**int a = b**）把b的10赋值给a{\n    a = a*3;a等于30。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b等于原来的10。\n}\n### 使用函数2的时候\nint main() {\n    int b = 10; 把b赋值为10。\n\tfunc2(b）等价于func1(**int & a = b**）把b和引用a绑定，此时a是b的别名，a和b的地址相同，修改a的值等同于修改b的值{\n    a = a*3; a等于30，此时b也等于30，因为a和b此时已经绑定在一起了。\n}\n\t函数调用结束，函数内创建的变量（a）都会被销毁。\n\t所以打印出的b已经通过函数2被改变了值为30。\n}\n\n---\n\n## const的引用\n可以把引用绑定到const对象上，就像绑定到其他对象上一样。但是对常量的引用不能被用作修改它所绑定的对象：\n```c++\nconst int ci = 1024;\nconst int &r1 = ci;\nr1 = 42;\t//错误：r1是对常量的引用，无法改变\nint &r2 = ci;\t//错误：试图让一个非常量引用指向一个常量对象\n```\n### 初始化和对const的引用\n！！注意！！\nint &r = 0;\t//错误，引用只能绑定对象\nconst int &r = 0; //正确，允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式\n引用类型必须和引用对象的类型一致，但是有两个**例外**\n在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许一个常量引用绑定非常量的对象，字面值，甚至是一个一般表达式：\n\n```c++\nint i = 42;\nconst int &r1 = i;\nconst int &r2 = 42;\n\ndouble dval = 3.14;\nint &r2 = dval\t// 错误，因为引用和对象类型不同\nconst int &r3 = dval;\t//正确：输出3\n```\n### 对const的引用可能引用一个并非const的对象\n常量引用仅对引用可参与的操作做出来限定，对于引用对象本身是不是常量未作出限定。因为对象也可能是个非常量，所以允许其他途径改变它的值。\n+ 对象：非常量\n+ 引用： 常量\n导致绑定后的引用无法改变值，永远等于绑定前对象的初始值，如果之后对象的值改变，那么对象值将不等于绑定的引用值。\n```c++\nint i = 42;\nint &r1 = i;\t// 引用r1绑定对象i\nconst int &r2 = i;\t//引用r2页绑定对象i，但是不允许通过r2修改i的值\nr1 = 10；\t//r1并非常量，i的值修改为0\nr2 = 0；\t//错误：r2是一个常量引用\ni = 10；\t//此时r2还是等于42，可以修改i的值，i此时为10，但是无法修改与它绑定的引用的值\n```\n\n---\n\n# 指针\n指针是“指向”另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比又有很多不同点：\n+ 指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象。\n+ 指针无需在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。\n\n## 指针的定义\n数据类型 * 指针变量\nint * ipl, * ipl2;\ndouble dp, * dp2;\n\n### 概念梳理\n```c++\nint a = 3;\nint *ptr = &3; //错误，指针必须指向变量不能指向字面值\nint *ptr = a; //错误，a缺少取址符号\nint *ptr = &a;// 正确\n```\n### 对于令指针为0\n```c++\nint *ptr;\nptr = 0;//令ptr指针为空指针\n\n-------------------------------\nint *ptr = 0; //令ptr指针为空指针\n\n-------------------------------\nint *ptr;\n* ptr = 0// 错误\n\n-------------------------------\nint a = 0;\n    int *ptr = &a; //指针指向一个值为0，名称为a的对象\n```\n## 获取对象的地址\n指针存放某个对象的地址，要想获取改地址，需要使用**取地址符&**。\nint ival = 42;\nint * p = & ival;\t// p存放变量ival的地址，或者说p是指向变量ival的指针。\n## 利用指针访问对象\n如果指针指向了一个对象，则允许使用 解引用符* 来访问该对象。 \n```c++\nint ival = 42;\nint * p = &ival; //\tp存放着ival的地址。 \ncout<< *p; // 由符号*得到指针所指的对象，输出42\n```\n对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也是给指针所指的对象赋值：\n\n\n```c++\n*p = 0;\t// 由符号*得到指针p所指的对象，即可经由p为变量ival赋值\ncout<<*p; // 输出0\n```\n## 概念区分\n+ & 和数据类型一起出现：声明一个引用\n+ \\* 和数据类型一起出现：声明一个指针\n+ & 单独出现：取地址符，和对象（变量）一起使用，代表对象的地址\n+ \\* 单独出现：解引用符，和指针一起使用，代表指针包含地址的值\n```c++\nint i = 42;\nint & r =i; // &紧随类型出现，因此是声明的一部分，r是一个引用，并且和对象i绑定在一起\nint *p; // *紧随类型出现，因此是声明的一部分，p是一个指针\np = & i;\t// &出现在表达式中，是一个取地址符\n*p = i；\t// *出现在表达式中，是解引用符\nint & r2 = *p // &是声明的一部分，*是一个解引用符\n```\n在声明语句中，& 和* 用于组成复合类型；在表达式中，它们的角色又转变成运算符。在不同的场景下出现的虽然是同一个符号，但是由于含义截然不同，所以我们完全可以把它当成不同的符号来看。\n## 空指针\n空指针不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。空指针生成方法：\n+ int \\*p = nullptr; \n+ int \\*p2 = 0;\n+ int \\*p3 = NULL;\n```c++\nif (pi)\n...// pi的值是0， 因此条件值是false\nif(pi2)\n...// pi指向ival，因此它的值不是0，条件是true\n```\n任何非0指针对应的条件值都是true。\n\n## void\\* 指针\nvoid\\*是一种特殊的指针类型，可用于存放任意对象的地址。一个void\\*指针存放着一个地址，这一点和其他指针类似。不同的是，我们对该地址到底存放着什么类型的对象不了解。\n```c++\ndouble obj = 3.14, *pd = &obj;\nvoid *pv = &obj;\t// obj可以是任意类型的对象\npv = pd;\t//pv可以存放任意类型的指针\n```\n## 指向指针的指针\n指针是内存中的对象，像其他对象一样也有自己的地址，因此允许把指针的地址再存放到另一个指针当中。\n通过\\*的个数可以区分指针的级别。\\*\\*表示指向指针的指针，\\*\\*\\*表示指向指针的指针的指针。\n```c++\nint ival = 1024;\nint *pi = &ival;\t// pi指向int型的数\nint **ppi = &pi;\t// ppi指向一个int型的指针\n```\n同样对于指针的指针也需要解引用时也要解两次\\*\\*ppi\n\n## 指向指针的引用\n引用本身不是一个对象，因此不能定义指向引用的指针。但是指针是对象，所以存在对指针的引用\n```c++\nint i = 42;\nint *p;\t//p是一个int类型的指针\nint *&r = p;\t//r是一个对指针p的引用,所以是指针的别名，类型也属于指针（引用）\nr = &i;\t//r引用了一个指针，因此给r赋值&i就是另p指向i，因为r和p已经捆绑在一起了\n*r = 0;\t//解引用r得到i，也就是p指向的对象，将i的值改为0\n```\n要了解int \\*&r = p中的r的类型到底是什么，最简单的方法是从左向右阅读r的定义。离变量名最近的符号（&）对变量有最直接的影响，因此r是一个引用。声明符的其余部分用以确定r引用的类型是什么，这里的符号\\*说明r的引用是一个指针。\n\n## 指针和const\n指向常量的指针不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针：\n```c++\nconst double pi = 3.14;\t//pi是个常量，它的值不能改变\ndouble *ptr = &pi;\t//错误：ptr是个普通指针\nconst double *cptr = &pi\t//正确：cptr可以指向双精度常量\n*cptr = 42;\t//错误：不能给*cptr赋值\n```\n指针的类型必须与其所指对象的类型一致，但是有两个**例外**。第一种例外情况是允许令一个指向常量的指针指向一个非常量对象：\n+ 指针：常量\n+ 指针指向的对象：可以是非常量\n```c++\ndouble dval = 3.14;\t//对象：非常量\ncptr = &dval;\t//指针：常量\n```\n和常量引用一样，指向常量的指针没有规定其所指对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值能不能通过其他途径改变。\n\n### const指针\n+ 指向常量的指针（pointer to const）：const int\\*ptr = &pi: 指针变量保存的内存地址是可以修改的，指针变量所指向的内存也是允许读取数据的，但是我们不能修改指针变量里面所指向的内存里面的数据。**底层const：**指针所指的对象是个常量。（const int（被指的对象是个常量）*ptr （指针不是常量，地址的值可以改变）= &pi）\n\n+ 常量指针（const pointer）：int \\*const ptr= &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存也是允许读取数据的，但是我们可以修改指针变量里面所指向的内存里面的数据。常量指针必须初始化，初始化一旦完成，则它的值（存放在指针中的地址）就不能再改变了。**顶层const：**指针本身就是一个常量。（int（被指的对象int不是常量） \\*const ptr（指针自己是个常量，地址无法改变））\n\n+ 指向常量的常量指针：const int \\*const ptr = &pi: 针变量保存的内存地址不可以修改，指针变量所指向的内存是允许读取数据的，我们不可以修改指针变量里面所指向的内存里面的数据。**既是顶层const又是底层const：**指针本身是个常量，而且他所指的对象也是常量。\n```c++\nint main() {\n    int number1 = 233;\n    int number2 = 666;\n    \n    //指向常量的指针（pointer to const）\n    const int *pointer =  &number1;\n\t\tpointer = &number2;\t//可以修改指针变量保存的地址\n    *pointer = 666;\t//错误，不能修改指针变量里面所指向的内存里面的数据\n    \n    //常量指针（const pointer）\n    int *const pointer2 = &number1;\n    pointer2 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //可以修改指针变量里面所指向的内存里面的数据\n    \n    //指向常量的常量指针\n    const int *const pointer3 = &number1;\n    pointer3 = &number2;\t//错误，不能修改指针变量保存的地址\n    *pointer2 = 666; //错误，不可以修改指针变量里面所指向的内存里面的数据\n    \n}\n```\n执行拷贝时，常量是顶层const还是底层const区别明显。其中顶层const（常量指针）不受什么影响。但是底层const（指向常量的指针）的限制不容忽视。当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格，或者两个对象的数据类型必须能够转换。一般来说，非常量可以赋值给常量，反之不行。","tags":["C++"]},{"title":"傅立叶变换在图像处理的应用","url":"/2020/05/09/傅立叶变换在图像处理的应用/","content":"**傅立叶**：任何连续的周期信号，可以由一组适当的正弦曲线组合而成。（Any univariate function can be rewritten as a weighted sum of sines and cosines of different frequencies.）\n\n---\n一个恰当的比喻是将傅立叶变换比作一个玻璃棱镜。棱镜是可以将光分解为不同颜色的物理仪器，每个成分的颜色由波长（或频率）来决定。傅立叶变换可以看作数学上的棱镜，将函数基于频率分解为不同的成分。当我们考虑时，讨论他的光谱或频率谱。同样，傅立叶变换使我们能通过频率成分来分析一个函数。\n\n---\n\n<iframe height=300 width=300 src=\"https://upload.wikimedia.org/wikipedia/commons/7/72/Fourier_transform_time_and_frequency_domains_%28small%29.gif\"></iframe>\n\n---\n\n## 用一个例子解释一维傅立叶变换\n\n我们一般描述一个函数都是基于时间域，如图所示表示了这个函数随时间变化的变化（x轴是时间的变化，y轴是（信号）强度的变化）。\t\n![timedomain](timedomain.JPG)\n但是其实还有一种方法也可以描述这个函数，就是频率域。就比如上图中的函数可以写成\nf(x) = 3sin(0.8x) + 7sin(0.3x) + 2sin(0.2x)\n的形式。就是相当于给了频率为0.8, 0.3和0.2的sin函数不同的权重并把它们加起来。所以也可以由下图来表示。\n![frequencedomain](frequencedomain1.JPG)\n![frequencedomain](frequencedomain2.JPG)\n虽然两张图看起来截然不同，但是他们表述的是同种东西，而傅立叶变换就是描述这种从时域到频率域的变换。\n当然也要考虑相位的变化。\n![phase](phase.JPG)\n\n---\n\n## 傅立叶变换在二维图像处理\n\n![DFT](dft.png)\n傅立叶变换在二维图像处理中想法与之前一维类似，图像处理中的傅立叶变换是基于二维矩阵，如图所示，x轴和y轴共同表示图像中的位置，z轴表示每个位置（像素点）的灰度值。\n![imagedomain](imagedomain.JPG)\n\n和之前的一维函数相比较可以得出对应关系：\n\n|一维函数|二维图像|\n|---|---|\n|时间|距离|\n|信号强度|灰度值|\n\n---\n\n\n### 傅立叶变换的特点\n+ 傅立叶变换吧图像转化成cosin和sin函数的组成\n+ 空间域-------（Fourier Transformation）------->频率域\n\t 频率域-------（Inverse Fourier Transformation）------->空间域\n\t\n\n![dftidft](dftidft.png)\n\n\n+ 一副M\\*N大小的图像可以被看作是M\\*N个指数的基本图像的线形组合\n+ 傅立叶变换前后图像大小不变\n+ 在频率域上的每个幅值对应表示了在空间域上相应存在的灰度值频率。\n+ 频率域F(0, 0)中心点表示整幅图灰度值的平均值\n\n  图像DFT(离散傅立叶变换)的基本属性是其周期性和复共轭对称性。频谱以周期N在两个方向上无止境地重复，即F（u，v）= F（u + kN，v + lN）其中k，l∈[-∞，...，-1，0，1， 2，...，∞]。从具有2D DFT的N×N图像计算出的傅立叶系数F（u，v）的N×N块是此无限序列的单个周期\n  ![equation](equation.png)\n  注意看这里对于频率域的每个点（u，v）都需要时间域所有点的相关信息。\n\n### 二维图像中傅立叶变换的原理\n二维的sin波动可以用如下公式表述：\n*z = a sin(ux+vy)*\nz是波的高度（强度）。\na是幅值，表示波的最高高度。\nu是波浪在x方向上重复的次数（x方向上的频率）。\nv是波浪在y方向上重复的次数（y方向上的频率）。\n如图所示，当v=0的时候，sin的波只在x轴方向波动，当u=0的时候，sin的波只在y轴方向波动，如果u和v都不为0，那么就会在xy叠加方向以角度u/v波动（比如对角线方向）。\n![waves](waves.png)\n如下图，把每个像素点上述的波叠加起来，然后这些波会相互抵消，相互叠加。\n![waves_overlay](waves2.png)\nu是波浪在x方向上重复的次数（x方向上的频率），它可以是1，2，3... \t1表示单位距离内在x方向上重复1次，2表示单位距离内在x方向上重复2次...\n比如，f（2，2）这个像素，它的灰度值在x方向上以sin波波动了3次，在y方向上以sin波波动了4次，那么它在频率域对于点F（3，4）就有一点贡献。F（u，v）的值就是这张图内所有像素点贡献值之和，就是在那个x方向u频率和y方向的v频率的sin波动的强度大小的矢量和。F(3，4)那点的亮度就是表示了整张图的所有像素点在x方向上以频率3灰度的波动和在y方向上以频率4灰度的波动之和的强度（能量大小）。在频率域上的中心点（0，0）表示在x和y方向上都没有波动，它的值是所有灰度值和的平均值。所以在频率域中，中间是低频率，外部是高频率。\n\n### 傅立叶变换如何储存变换前的位置信息\n按照之前介绍的，如果在傅立叶变换之后是频率域，而频率域只有幅值的话，那么就只能用幅值来表示在变换前以各种角度的各种频率出现次数的多少。但是在图片中很可能还需要这些偏移信息，而这些信息就储存在频率域的相位谱信息中，每个频率都有自己的幅值和相位。\n![phase](phase.png)\n频率域是由magnitude和phase组成，phase主要储存了图像傅立叶变换前的基础结构的信息\n![phase2](phase2.png)\n\n### 小例子\n\n![example](example.png)\n为什么在频率域上的水平直线转化到空间域是清晰的竖直的直线呢？\n因为在频率域上的水平直线表示着当u（u是波浪在x方向上重复的次数（x方向上的频率））等于很多值（1，2，3...）时，v（v是波浪在y方向上重复的次数（y方向上的频率））等都于0，这意味着在空间域上灰度值在x方向上有很多各种各样的灰度值的变化，因为直线是有粗度的，粗度上的每个pixel都是一个频率，而高频的代表了是一条清晰的直线（直线的清晰度）。\n![example2](example2.png)\n\n### 傅立叶变换在图像处理的应用\n1. 图像去噪，利用傅立叶变换的线形性质, 在傅立叶变换后在频率域更方便用某些filter去去噪。\n\n\n\n![linear](linear.png)\n![denoise1](denoise1.png)\n![denoise2](denoise2.png)\n\n### 二维图像傅立叶变换在opencv中的实现\n\n```python\nimport cv2 as cv\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimg = cv.imread('messi5.jpg',0) # 读入图片\nf = np.fft.fft2(img) # 用np自带功能把图片进行傅立叶变换\nfshift = np.fft.fftshift(f) # 调换象限，中心化处理\nmagnitude_spectrum = 20*np.log(np.abs(fshift)) #因为进行变换之后是复数，所以要取绝对值，用log函数是为了能把变换后的图像显示的更加清楚。\nplt.subplot(121),plt.imshow(img, cmap = 'gray') #subplot第一个数字是行数，第二个列数，第三个是index\nplt.title('Input Image'), plt.xticks([]), plt.yticks([])\nplt.subplot(122),plt.imshow(magnitude_spectrum, cmap = 'gray')\nplt.title('Magnitude Spectrum'), plt.xticks([]), plt.yticks([])\nplt.show()\n```","tags":["图像处理"]},{"title":"二分法","url":"/2020/05/06/二分法/","content":"\n首先二分法只适用于已经排序过的数组。\n二分法的思想就是通过每次排除一半的数列，在剩余一半的数组中查找目标值并返回其所在的位置。相比于直接查找二分法的效率更高，其时间复杂度是O(log2n)。\n\n---\n\n### python代码实现：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return \"Target is not in the list.\"\n```\n\n### 用例子解释为什么循环执行的条件是left<=right：\n[3，8，15，21，35，54，63，79，82，92，97] #目标数列\n0     1      2     3      4      5       6     7      8       9     10 #目标数列的序号\n\n**第一轮**：\nleft_index = 0,  right_index = 10,  mid_index = (0+10)/2 = 5, taget = 87\n\n**第二轮**：\nleft_index = 0 < right_index = 10\nmid = 54<87\n所以left_index = mid_index+1 = 5+1 = 6\nmid_index = (6+10)/2 = 8所以mid对应的值是82\n\n**第三轮**\nleft_index = 6 < right_index = 10\nmid = 82<87\n所以left_index = mid_index+1= 8+1 = 9\nmid_index = (9+10)/2 = 9所以mid对应的值是92\n\n**第四轮**\nleft_index = 9 < right_index = 10\nmid = 92>87(Target value)\n所以right_index = mid_index-1 = 9-1 = 8\n\n**第五轮**\nleft_index = 9 **>** right_index = 8\n不满足while循环跳出\n\n---\n\n## 题目\n### leetcode 35. 搜索插入位置\n给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。\n\n你可以假设数组中无重复元素。\n\n示例 1:\n\n输入: [1,3,5,6], 5\n输出: 2\n示例 2:\n\n输入: [1,3,5,6], 2\n输出: 1\n示例 3:\n\n输入: [1,3,5,6], 7\n输出: 4\n示例 4:\n\n输入: [1,3,5,6], 0\n输出: 0\n\n---\n\n这道题目可以用二分法查找元素，但是多出了如果被查找元素不在给定数列内，要把它插在合适的位置的要求。\npython解法的代码：\n```\ndef Binary(nums, target):\n    left = 0\n    right = len(nums) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            return mid\n        elif nums[mid] < target:\n            left = mid + 1\n        elif nums[mid] > target:\n            right = mid - 1\n    return left\n```\n只需要把最后的return \"Not in the list\"改成return left就行。\n**为什么最后改成return left就行**：\n从之前举的例子可以看出，在执行到第五轮的时候，将会跳出循环，此时，left和right的值都是要比查找值target大，所以才会跳出循环导致无法查找，所以这意味着此时只要返回left的index就可以了，就相当于把此时的left向后移动一位插入这个需要被查找的元素。\n\n### leetcode 69. x 的平方根\n实现 int sqrt(int x) 函数。\n\n计算并返回 x 的平方根，其中 x 是非负整数。\n\n由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。\n\n示例 1:\n\n输入: 4\n输出: 2\n示例 2:\n\n输入: 8\n输出: 2\n说明: 8 的平方根是 2.82842..., \n\n---\npython解法的代码\n```\ndef mySqrt(x):                              \n    left = 0                                \n    right = x                               \n    while left <= right:                    \n        mid = (left + right) // 2           \n        if mid ** 2 <= x < (mid + 1) ** 2:  \n            return mid                      \n        if mid ** 2 > x:                    \n            right = mid - 1                 \n        if (mid + 1) ** 2 <= x:             \n            left = mid + 1                         \n```\n思路和之前很相似，确定什么时候可以返回刚好是根号数，就是在这个数的平方小于或等于x的时候以及这个数加一的平方大于x的时候，有了这个限制条件就可以写代码了。因为另外两种情况下就正好在mid的左半边和mid的右半边进行寻找。","tags":["算法与数据结构"]},{"title":"相机标定(Camera Calibration)","url":"/2020/05/03/相机标定-Camera-Calibration/","content":"# 相机模型\n\n首先我们知道物体本身是不发光的，我们所看到的有颜色的物体都是都是物体反射太阳或其他光源基于大脑的色觉系统所产生的。而相机就是基于人类的色觉系统所制造成的。比如下图的我们眼中的绿巨人浩克，多条不同方向的光线在他身上反射后会被右侧相机的光学传感器所接收。\n![Hulk](Hulk.png)\n\n如果不对这些光线做处理，绿巨人身上的每一点都会作用于光学传感器上的每一个像素，产生如下图的效果。\n![green](green.png)\n\n很显然，这并不是我们想要的结果，所以人们就想到如果能把多余的反射光线遮住，使得实物上的每一点和相机上的每一个像素相对应，由此就得出来最简单的单孔相机（pinhole）模型，如下图所示。\n\n![pinhole](pinhole.png)\n\n得到了简单的单孔模型之后，我们又引出了焦距（focus length）的概念，根据相似的定义可以知道焦距越小所得到图像也越小，而且是和实物上下颠倒。\n\n![focus length](focuslength.png)\n\n因为单孔模型会遮掉很多多余的反射光线，使得光线的利用率不高，所以为了提高光线的利用率我们想到可以把带小孔的遮光板换成透镜，这样既可以提高光线的利用率，又可以满足我们之前的要求。\n\n![lens](lens.png)\n\n\n\n\n# 为什么需要相机标定\n+ 建立相机成像几何模型：通过拍摄得到的图片来重建3D现实，计算机视觉的首要任务就是要通过拍摄到的图像信息获取到物体在真实三维世界里相对应的信息，于是，建立物体从三维世界映射到相机成像平面这一过程中的几何模型就显得尤为重要，而这一过程最关键的部分就是要得到相机的内参和外参。\n\n\n+ 矫正透镜畸变：我们最开始接触到的成像方面的知识应该是有关小孔成像的，但是由于这种成像方式只有小孔部分能透过光线就会导致物体的成像亮度很低，于是聪明的人类发明了透镜。虽然亮度问题解决了，但是新的问题又来了：由于透镜的制造工艺，会使成像产生多种形式的畸变，于是为了去除畸变（使成像后的图像与真实世界的景象保持一致），人们计算并利用畸变系数来矫正这种像差。虽然理论上可以设计出不产生畸变的透镜，但其制造工艺相对于球面透镜会复杂很多，所以相对于复杂且高成本的制造工艺，人们更喜欢用数学来解决问题。\n# 坐标系\n+ **世界坐标系(world coordinate system)**：用户定义的三维世界的坐标系，为了描述目标物在真实世界里的位置而被引入。单位为m。\n\n\n\n+ **相机坐标系(camera coordinate system)**：在相机上建立的坐标系，为了从相机的角度描述物体位置而定义，作为沟通世界坐标系和图像/像素坐标系的中间一环。单位为m。\n\n\n\n+ **图像坐标系(image coordinate system)**：为了描述成像过程中物体从相机坐标系到图像坐标系的投影透射关系而引入，方便进一步得到像素坐标系下的坐标。 单位为m。\n\n\n\n+ **像素坐标系(pixel coordinate system)**：为了描述物体成像后的像点在数字图像上（相片）的坐标而引入，是我们真正从相机内读取到的信息所在的坐标系。单位为个（像素数目）。\n\n## 四个坐标系之间的关系\n![coordinates](coordinates.jpg)\n\n世界坐标系：Xw、Yw、Zw。相机坐标系： Xc、Yc、Zc。图像坐标系：x、y。像素坐标系：u、v。\n\n\n\n其中，相机坐标系的 轴与光轴重合，且垂直于图像坐标系平面并通过图像坐标系的原点，相机坐标系与图像坐标系之间的距离为焦距f（也即图像坐标系原点与焦点重合）。像素坐标系平面u-v和图像坐标系平面x-y重合，但像素坐标系原点位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。\n\n\n\n而相机标定的过程就是：\n\n**世界坐标系--->相机坐标系--->图像坐标系--->像素坐标系**\n通过确定这些变换过程中的参数，就可以从照片上的像素坐标系的某一点推导出在现实世界中的该点对应点的坐标。\n\n---\n\n## 世界坐标系（3D）--->相机坐标系（3D）\n**外部参数Extrisic Camera Parameters**\n\n![ws2cs](ws2cs.png)\n世界坐标系的原点一般来说和相机坐标系的原点不会相同。\n\n刚体从世界坐标系转换到相机坐标系的过程，可以通过**旋转和平移**来得到，我们将其变换矩阵由一个旋转矩阵和平移向量组合成的齐次坐标矩阵来表示。其中的平移矩阵和旋转矩阵如图所示：\n![ex](ex.jpg)\n比如说绕着z轴旋转：\n![rotationZ](rotationZ.png)\n把平移和旋转结合起来组成一个矩阵，可以先平移后旋转，也可以先旋转后平移。但是顺序不同产生的运动矩阵也不同。\n![tandr](tandr.png)\n\n对于平移和旋转来说，平移有3个参数，分别描述x，y，z轴的位移量。旋转也有三个参数，分别描述绕x，y，z轴旋转的旋转角度。所以总共有6个参数。因为这6个参数只和相机摆放的位置和方向有关，和相机内部无关，所以也被称为**外部参数（Extrisic Camera Parameters）。**\n\n---\n\n## 相机坐标系（3D）--->理想图像坐标系（不考虑畸变）（2D）\n**投影**\n**首先假设相机坐标系的x，y轴与理想图像坐标系的x，y轴重合**。那么如图所示，X是相机坐标系中的一点，坐标为（X，Y，Z）；x是理想图像坐标系上的一点，坐标为（x，y）\n![pcs2ws](pcs2ws.png)\n根据相似定理可以得到(X, Y, Z)--->(fX/Z， fY/Z)\nx = PX\n而转换成齐次坐标系进行运算，P就是一个3\\*4的矩阵。\n\n\n**但是现实中相机坐标系的x，y轴很可能与理想图像坐标系的x，y轴不重合**。如图所示：\n![pcs2ws2](pcs2ws2.png)\n\n此时，就需要对P这个矩阵进行修改了。在矩阵P中添加px和py表示相机坐标系的原点和理想图像坐标系的原点的差距。\n\n---\n\n## 理想图像坐标系--->实际图像坐标系（考虑畸变）\n透镜的畸变主要分为径向畸变和切向畸变，还有薄透镜畸变等等，但都没有径向和切向畸变影响显著，所以我们在这里只考虑径向和切向畸变。\n\n径向畸变是由于透镜形状的制造工艺导致。且越向透镜边缘移动径向畸变越严重。下图所示是径向畸变的两种类型：桶形畸变和枕形畸变。\n![verzeichnung](verzeichnung.png)\n对于畸变描述的数学表达式\n![distortion](distortion.jpg)\n\n---\n\n## 图像坐标系(2D)--->像素坐标系(2D)\n**内参（Instrnsic Camara Parameters）**\n+ 像素坐标系的原点一般都位于图中左上角（之所以这么定义，目的是从存储信息的首地址开始读写）。所以一般情况下图像坐标系的原点和像素坐标系的原点不重合。\n\n+ x，y轴的像素的密度大小可能不一样，分别是ku 和kv。\n\n+ 像素的u轴和v轴的角度有可能不为90度。\n\n![i2p](i2p.png)\n\n所以通过5个参数来描述由图像坐标系转化到像素坐标系的过程。这5个参数被称为**内参（Instrnsic Camara Parameters）。**\n![iP](iP.jpg)\n\n---\n\n## 综合\n把上述的外参，投影和内参综合起来，就可以得到从世界坐标系到像素坐标系的过程\n![mapping](mapping.jpg)\n\n# 标定方法\n+ 传统相机标定\n\n最简单的相机标定为线性标定，即不考虑相机的畸变而只考虑空间坐标转换。\n每个坐标点有X,Y两个变量，可列两个方程，相机内参有5个未知数，外参平移和旋转各3个，共有11个变量，因此至少需要6个特征点来求解。\n\n+ 非线性标定\n\n当镜头畸变明显时必须考虑畸变，一般较为便宜的网络摄像头畸变特别大，而价格较贵的工业摄像头则畸变很小，因为其中已经嵌入了许多消除畸变的程序。这时线性模型转化为非线性模型，需要通过非线性标定方法求解。有最速下降法，遗传算法，高斯牛顿法和神经网络算法等。\n","tags":["图像处理"]}]